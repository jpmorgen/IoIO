[Make a separate software development notebook so my observing
notebook doesn't get mucked up by this stuff]

Wed May  3 01:20:10 2017  jpmorgen@snipe

OK, now that I have Jupiter's center, how do I want to handle it in
real time?  That depends on what is available in the maxim object
namespace.

CCDCamera.ImageArray safearray of Long of size NumX * NumY
containing the values from the last exposure  BINGO!
I need Maxim on puppy.

CCDCamera.GuiderArray analogous for guider

Ah! There are some events that we can monitor, so we can potentially
run in parallel, saving the trouble of loading all of the Python
packages I depend on

CCDCamera.GuiderMoveStar moves the guide star _while tracking_ which
is exactly what I want! (delta move)

CCDCamera.GuiderXStarPosition plus CCDCamera.GuiderXError,
CCDCamera.GuiderYError tell exact position of the guide object


CCDCamera.SetFITSKey ( Key, Value )  Cool!  So I can record FITS
stuff in the raw files!  GetFITSKey returns a key, but you can't
seem to get the whole FITS header

CCDCamera.StartSequence HEY!  So I can do a hybrid interaction,
where I use my existing sequences

CCDCamera.PinPointStatus, ImageScale, PositionAngle, CenterDEC, and
CenterRA get at the Pintpoint stuff, but there seems to be no way to
get the info stored about the scope like the focal length, so this
is stuff we will have to store long-term.

So I envision having MaxIm running and the Python scripts
controlling it.  Lets see if we can really do this

Wed May  3 23:06:14 2017  jpmorgen@snipe

So I can do what I want with CCDCamera.GuiderMoveStar, but I have to
be the one in control of that.  So I need some sort of loop that
updates it periodically.  That would be a good thing to have be an
object, with the property of that object the rate I want, which can
be adjusted by other parts of the module that have that object.
There could be another object that keeps track of the guide scope
flexure...  Hmmm.  My original idea was to keep track of all motion
under the assumption that restarts of the guider picked up just
where the unguided scope motion left off.  I am finding that is not
the case: Jupiter can move around quite a bit when the guider
starts, so I will probably have to start fresh on motion
calculations if I really need to do a reposition.  But while I am
guiding, the motion should be relatively consistent.  So my original
idea was to have a model which set the starting rates.  I guess if
there is a deviation of Jupiter from where I want it, I want to
tweak the value used to move the guide box, but the model can still
do its thing.

Taking a step back, the guide box will have a certain trajectory
which will keep Jupiter perfectly centered.  What we really have is
a trajectory on the main camera and a separate one on the guider,
with the one on the main camera informing the one on the guider.

Trajectory is a listing of:
time, gx, gy, mx, my

We know the plate scales and orientations
(e.g. CCDCamera.GuiderAngle) of the respective cameras, so we can
use that to measure the real offset between the guider and main
scope, whether or not Jupiter is centered.

But fundamentally what we care about is putting Jupiter where we
want it and zeroing its motion.  In offset_guide.py, guide_calc did
the simple delta between adjacent points to calculate new rates.  Ah
HA.  In our move object, we could have space for the model and a
separate space for the measured.  In general, I might want an array
so arbitrary terms can be added, like for guiding on a star for a
faint non-siderial object.  So there could be some sort of a
registration process for the objects that send info to the guide box
moving object

OK, I think I have a good concept of a general guide box moving
object.  The next step is when the telescope takes an image, there
needs to be an analysis that tells us where the object is and where
we want to put it.  That analysis needs to happen in, or at least be
provided to a module that figures out how to tweak the measured
portion of the move object.  That is the module I have been
struggling with thinking about.  If we use the same registration
idea for that, the object finder/center calculators can be easily
added after-the-fact.  The module that does the calculation of the
offset rates that counteract the measured motion and delta from
desired position can then be developed independent of source of
information.

So I now am thinking about a module that uses the measured and
desired positions as a function of time and calculates the
correction rates to feed to the guide box moving object.  This is
where the trajectory concept comes in.  This module accepts a
function that feeds it the input values.  This measurement module
could use CCDCamera_Notify(ceSequenceCompleted)

So the measurement master module, or whatever I want to call it,
would handle all of the interface with MaxIm.  Hmm.  I am finding
that I might want the FITS header, but that does not seem possible.
I can, however, get one card at a time if I know what I am looking
for.  So the MMM could accept a list of FITS keys (e.g. FILTER,
DATE-OBS, etc.) which it would query when a new image is available.
It would pass the image and any desired FITS keys to the module that
does the measurement.  It could return None, if it declines to do a
measurement (wrong filter [might want to measure multiple quantities
like filters separately]).  But if it provides a measurement, the
MMM will process it.  Maybe different filters can be handled by
having different prefered centers....  And/or, it might be good to
have some sort of list of, e.g., filters, where each is only
compared to each other.  Say we do that, with a list of measurement
slots.  The MMM could calculate motions for each one separately.  If
they were "consistent enough," they could then be used by MMM to
derive the offsets.  

OK, so the MMM needs an algorithm for converting a series of
measurements to a rate for the guide box mover.  And here is where
we need the guide box mover to provide its trajectory.  Ultimately,
we just want to subtract our measurement trajectory from the
existing trajectory.  Not sure if we want to work in extrapolation
space or not.  Well, if the data are not slowly varying and
reaosnably consistent, then I am not going to be able to do anything
with them.  So applying that as a test criterion is something I
should do.

Thu May  4 15:59:26 2017  jpmorgen@snipe

OK, after some sleep, I realize that this is going to be some
background job that I am going to want a stop button for.  If I have
a stop button, I might as well have that also be a status display
panel.  Cool.  As far as measurement goes, because I can get the
absolute pixel that the object is on in both the guider and main
camera, I don't think it matters whether or not I have guided
between, just that I am guiding and the errors are reasonable when
the measurement is recorded

Wed May 10 12:31:46 2017  jpmorgen@snipe

On day schedule for concentrated effort on this.  Based on some code
I found at
http://wt5l.blogspot.com/2011/05/automated-astrophotography-with-python_28.html
I am going to make an object that contains stuff having to do with
MaxIm.  I am calling it MaxImData.  Maybe I should call the whole
package maximpy, where the offset guide component would be a
separate program to run for its event loop, but would import all the
code in maximpy.

I have some angst about whether or not maximdata or maximpy should
import numpy or just math.  Clearly I am going to need numpy to
identify Jupiter, etc., but for basic measurement, it will probably
not be needed.... No, I can't say that.  I might want to do some
pretty sophisticated estimation and fitting even if centers are
passed using guide stars or PinPoint.

Thu May 11 10:31:33 2017  jpmorgen@snipe

Got something up and running with MaxIm + now I need to get the
desired center stuff squared away.  At this point, I just want
something that works with the ND filter and a Y coordinate.  Since
the desired center moves, maybe I should call it measured center.
The routine is going to need an NDData and so does jupiter_center.
I think that it makes sense to have the NDData generated by the
desired center routine which is called first, but I can make the
logic so it can go either way.

Hmm.  Angst.  That is not clean and there isn't an easy way to get
values out into a parameter.  Things are expected to come out as
tuples.  But the function jupiter_center doesn't suggest it is
outputing the desired center, I just find it handy to do that.  I
suppose I could check on the receiving end for the second tuple/vector
and if it doesn't exist, assume center of image.

Thu May 11 11:30:13 2017  jpmorgen@snipe

OK, so jupiter_center turns into self.object_center in MaxImData.  But
it is more complicated than that.  I was thinking of having motion
calculated afer each exposure was recorded.  But it makes sense for
something else to trigger that, like a watchdog process monitoring the
events.  So I still need the intermediate level that I want to call
independently.

And I am also thinking that jupiter_center works for one image, but
ultimately I am going to want a more complicated function, like
ensemble_center that monitors the different filters, etc., and makes
decisions on whether or not to move things around.

Thu May 11 15:30:43 2017  jpmorgen@snipe

ACKK!  A hitch in my plans.  I am getting

com_error: (-2147352567, 'Exception occurred.', (65535, 'MaxIm DL 6', 'Image Not Available', None, 0, 0), None)

when I try to read an image with CCDCamera.ImageArray.
CCDCamera.ImageReady is true and the example off the next lets me
save, but it seems as though the approbation to not hand the array off
to vbscript and 

I might be able to get it through the Document object

http://www.newastro.com/tutorials/maxim_objects.html helped me with
that, but it is just from the documentation....

Ack!  What a pain.  It looks like I need to read things with
Document.GetFITSKey to get my own FITS header.  But at least I can do
it.

OK, so fundamentally I would like im to be a real astropy FITS im so I
could slog around in the FITS header at will.  To do that, I would
need to save things in an HDUlist

Fri May 12 08:54:59 2017  jpmorgen@snipe

OK, got the HDUlist thing to work, but the description of the image is
the transpose of what I want it to be.  im.shape reports X, Y as I
expect when I see the image in MaxIm and when it saves it to a FITS
file.  But when I make an HDU out of it, astropy reports the shape as
Y, X, presumably because it goes off the shape of the image assuming C
ordering.  Sigh.

There seems to be no tricky way out of this without transposition,
since the ordering of the bytes in memory are locked into the way
MaxIm sent them and Python received them.  If only a simple 1D array
had been sent, I would be fine.  At some level, that 1D array was
sent..  Let see if we can use flatten to see what it really looked
like.

BINGO!

I am reasonably happy with the solution and it checks out with
plt.imshow and the header

Now there is a problem with my approach, that the last image read in
is not necessarily the one that is going to have focus, if someone is
playing around selecting images with MaxIM.  But the Document object
is the only place I can get at the FITS keys I need.

I guess if this is running in the background the way I envision, I
shouldn't worry too much about it, because as soon as an event
happens, control is passed to the code querying the event, preventing
anything else from happening.

--> I am thinking that it might be a good idea to always have my
    coordinates transposed.  This is a pain, but it completes the job
    of transposing everything and results in things being able to plug
    right through in code.

Fri May 12 14:42:07 2017  jpmorgen@snipe

I want to be a little more clear about center pix vs center
astrometric coord.  I also now see that I can get guider images to
work with too, since I am forced to go through the Document object.

--> The watchdog should just retrieve the FITS keys to see if
    additional code should be triggered.  This saves transferring the
    whole image

Wed May 17 13:30:27 2017  jpmorgen@byted

On the way to the 'scope.

At this point I think it makes sense to subsume the maximdata
development into ioio.py so it is easier to just cut-paste

Wed May 17 17:39:05 2017  jpmorgen@byted

--> Wondering what the Pythonic way to deal with unexpected results
    is.  For now returning None seems to work pretty well.

Revisiting NDData now that I have had a little more experience with
classes.  Since I am going to slog around HDULists, I can define a
FITS key that has the ND prameters + check for that early on.

Wed May 17 19:55:20 2017  jpmorgen@byted

Cool!  I got things in the NDData object to work the way I want!  The
object stores things in the FITS header, which can bubble through
jupiter_center (or whatever I want to call it) without jupiter_center
having to worry about it.  If the MaxIm stuff works the way I think, I
can potentially write those keys back into the header before it
writes, though I may wish to let them be recalculated by reduction,
assuming it is important and needs to be rewritten

--> I want to use add_history from west_aux.py.  This highlights the
    necessity of figuring out the PYTHONPATH stuff on Windows/anaconda

Hmm.  I am running into the problem of tuple of tuple return from
jupiter_center.  It is not working the way I want.  The fundamental
problem is that I am returning TMI.  Or I am returning the I in the
wrong form.  Maybe I need to return an object that when queried, gives
the desired center, etc.

Hmm.  That is a good idea!  So the object would be of a subclass of
GetObjectCenterPix.  That object would be instantiated with the
HDUList_im_or_fname construct and then queried for the center pix of
the object and the desired center.  That object can get more
complicated if it needs to, particularly with respect to keeping track
of the desired center

Sat May 27 19:32:39 2017 EDT  jpmorgen@snipe

Think about what I want to call the object, because the method I want
is really oging to return the desired center + MaxImData.center_object
is going to move it there

So it is really going to be something like ImageHandler, or something
like that + have methods

.desired_center
.desired_rate?

Hmm.  So the ImageHandler object (or whatever I call it) is going to
accept the stream of images and make decisions about what to do with them.

I was hoping to avoid having everything centrally scripted, but the
focus stuff suggests I might need to do that.

But I still should try to keep abstraction layers sensible.  I have an
NDData object + probably should have a JupData object, or more
generally an ObjData object.

At least for JupData, I would have center and desired center

There is another set of stuff I need to keep track of for moving the
guide box.  I could potentially put that into the ObjData base class,
or have another class entirely for that

Thu Jun 01 21:24:28 2017 EDT  jpmorgen@snipe

Well, going with ObjData/JupData for now.  At the moment they are
hollow, in the sense that are not instantiated with the image as
property.  The image does get written in to property, but it can
change.  I am not sure I like that.  Potentially better to have the
layered objects, where the ObjData exists for each image that is read
in and can be queried for its obj center and prefered center.  Then
there is a separate object that keeps track of all of those, perhaps
OffsetGuide or OffsetGuideData.

OK, so how is the ObjData going to be handled with MaxImData?  I guess
a better question to ask is: who should be in charge?  The MaxImData
is going to be there connected to MaxIm.  The ObjData objects get
instantiated when an image is taken.  MaxImData might have the code
for that, but I don't think it is the right thing to be in charge of
that.  In other words, a separate application has the event-driven
logic.  Similarly, I think that I should keep the ObjData stuff out of
MaxImData, since it is just too individualized.  Rather, the ObjData,
or whatever subclass thereof should be driven by yet a third thing for
now.

Fri Jun 02 00:35:04 2017 EDT  jpmorgen@snipe

Ack.  I have to actually select the window for it to be the active one.

So next step is to read in an image

Fri Jun 02 10:36:49 2017 EDT  jpmorgen@snipe

Well, wait a minute.  I need to go back to the NDData logic since I am
using images of different size and binning.

So I want some property for the subimage and binning.  The
default_nd_pos and other nd position parameters should read in binning
= 1.

--> Either that or I just limit myself to binning = 1 cases for now

In any case, I need to make sure I check for out-of-bounds

Fri Jun 02 11:16:57 2017 EDT  jpmorgen@snipe

Now ready to read in an IPT image!

The acid test is to just read one in and have that be the active Document

It worked!

Revisited desire to just have math in MaxImData section and find that
since I am dealing with the astropy FITS stuff, I need to have
np.ndarrays, so np is necessary for MaxImdata

So now I want to see if I can make a script out of it that I can run
from the command line or with MaxIm!

Fri Jun 02 14:22:09 2017 EDT  jpmorgen@snipe

Apparently there is a thing called conda.

Ah.  Conda is like pip3 as a package manager.  It also creates
environments

python at the command prompt does bring up python

Type hello_argv.py + get the option to make a file association.  Took
a while to find python.exe, but now it is there (on puppy)

Hmm

Fri Jun 02 22:42:32 2017 EDT  jpmorgen@snipe

Got ioio.py to work on IoIO1U1! At least during twilight with old
images.

--> I need to get the default position of the current ND filter

ND=NDData('//snipe/data/io/IoIO/raw/2017-05-29/Sky_Flat-0001_Na_off-band.fit')
print(ND.get_params())

Sat Jun 03 15:27:29 2017 EDT  jpmorgen@snipe

<sigh> that is not as easy as I would like it to be.  Plus I need to
deal with binning stuff too.  So think about that for awhile.

I have been trying to keep NDData as a separate object.  I am seeing
there isn't much need for that.  As long as I don't call
get_obj_center on a flat, I am OK + I can potentially do some
safeguards against that. 

I am thinking a little more generally about the JupData.  Yes, I want
to use that to work with Jupiter, but I am also working with other
observations, like stars for focus and maybe other things.

So I am thinking that maybe ObjData should be ObsData, data about an
observation.  And I could have CorObsData for a coronagraph observation 

Wed Jun 07 10:28:03 2017 EDT  jpmorgen@snipe

Tried to work at town office + date was messed up on byted, so work
was lost.  Decided to put NDData into CorObsData.  Just need to add
nd_ to a couple of its methods + move some of the ingest_im stuff into
the base init and CorObsData init methods.

Sun Jun 11 13:39:06 2017 CEST  jpmorgen@byted

<sigh> now that the ND filter is tipped, the ND edge finding algorithm
doesn't work as well.  At least with the flats, I can use small
vertical binning and that fixes the problem for them.  Maybe for the
Jupiter images, I can rotate 

Sat Jul 01 23:34:03 2017 EDT  jpmorgen@snipe

Wonder if I can do the diagonal thing starting from the flats?

Tue Aug 01 19:17:30 2017 EDT  jpmorgen@byted

To do this effectively, I should make a decision when I am
processing the file if it is a flat or not.  I have IMAGETYP in the
list of required_FITS_keys, so it should come over fine in real time.

It would nice to have a place where I store the current paramters.  A
well-organized disk file is the right place.  That would be at the top
level of the raw data directory.  In the short term, it would be nice
to have that number in the property stashed from a previous flat run.

Well, that can just be a CorObsData on a flat!  That can be an
optional input.  Actuality the way to do that is just with a file name
and have CorObsData do it itself.

Hey, if I make the reference_flat a variable that is global to all
CorObsData types, I can at least for one session do what I am thinking of

Tue Nov 14 15:36:20 2017 EST  jpmorgen@snipe

Time to start thinking of getting this up and running, since I am 2
months out from deployment

Tried to send buffer to python:

Python 3.5.3 (default, Jan 19 2017, 14:11:04) 
[GCC 6.3.0 20170118] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jpmorgen/py/IoIO/ioio.py", line 10, in <module>
    from scipy import signal, ndimage
ImportError: No module named 'scipy'

I might need to get anaconda for snipe.  It looks like the latest
version of python is 3.6, but snipe only supports 3.5.

Since I use anaconda on puppy and IoIO1U1, it might be prudent to
install it on snipe....

OTOH, it looks like I can get scipy easily:

https://www.scipy.org/install.html

Sun Nov 26 14:43:54 2017 EST  jpmorgen@snipe

root@snipe> pip3 install -U pip

http://docs.astropy.org/en/stable/install.html

pip3 install -U numpy
  Found existing installation: numpy 1.12.1
    Not uninstalling numpy at /usr/lib/python3/dist-packages, outside environment /usr
Successfully installed numpy-1.13.3

https://askubuntu.com/questions/797058/not-uninstalling-paramiko-at-usr-lib-python2-7-dist-packages-outside-environme

OK, I think that means I have things under apt package management 

So numpy is installed and is at 1.12.1, as suggested by pip.

I have python3-astropy installed already.  Get python3-scipy

ioio.py now works!

But I need to implement the shifted row algorithm.

. Center of image = 0 shift
. dy * tan(angle) = dx, round that
. X + dx = corrected X.  Maybe shift row by -(X + dx)
. collapse shifted rows to increase signal

Sun Nov 26 17:01:28 2017 EST  jpmorgen@snipe

Reading through ioio.py and finding some things are confusing and left
over from previous iterations.

I like the ObsData and CorObsData inheritance construct.  CorObsData
replaces NDData.  "params" is not too illuminating a name.  ND_coords,
ND_edges, and ND_angle are more sensible.  ND_params might be better,
but I don't know if it is worth changing it for that

And I wanted to figure out a good place to store a file with the ND_params

https://stackoverflow.com/questions/7374748/whats-the-difference-between-a-python-property-and-attribute

Ah Ha!  I might want to define some methods __get__, __set__ and/or
__delete__ in some sort of ND_params object, so that when I call
something like print(flat.ND_params), it automatically does the
__get__ method

That is a refinement.  For now, I need to work at making it implement
the tilted algorithm.

The tilted algorithm depends on what I currently call the
default_nd_pos system, but which I think I would like to improve.

In the absence of any recorded previous ND_params and because I used a
variety of angles, 0 or 21 degrees is probably the best to start
with.  Alternately, I hard-code in ones for date ranges

It think it will be important to have a written area for this

Sun Nov 26 18:48:50 2017 EST  jpmorgen@snipe

ypt, ypts, etc. may need to change.

Mon Nov 27 16:45:31 2017 EST  jpmorgen@snipe

Having trouble with inheritance

ObsData.read_im does FITS stuff, but not y_center.  That is why I want
to override it in CorObsData.  But when I try to use the version of
read_im in CorObsData, I get passed the name...

Ahh.  The problem seems to be growing pains between old-style
functions that I am used to and doing things more with objects.  I was
not storing the image from read_im into self!

>>> [[  3.78040775e-01   3.84787113e-01]
 [  1.24664929e+03   1.35807856e+03]]
1.56926110854

Hey, that makes a big difference when I use the wrong value!

ND filter edges are not parallel.  Edges are off by 14.3094258117 pixels.
WARNING: ND filter edges are not parallel.  Edges are off by 14.3094258117 pixels. Returning initial try. [unknown]
[[  3.78040775e-01   3.84787113e-01]
 [  1.24664929e+03   1.35807856e+03]]
1.56926110854

--> Relax edges criterion a bit:
[[  3.74787350e-01   3.87795919e-01]
 [  2.56409969e+03   2.78656027e+03]]
1.57004886213

Hmm.  This seems wrong!  Intercepts are way too high

--> Oops, recursion error with default_ND_params = None

Not putting them back where they belong:

[[ -3.25342466e-03   3.00880626e-03]
 [  1.31745040e+03   1.42848171e+03]]
1.56933962744

Interesting that they are bowed
--> ND_angle is not returning the right thing

>>> [[  3.74787350e-01   3.87795919e-01]
 [  1.18909969e+03   1.41156027e+03]]
1.56925870775

OK, somne things to work on.  First of all, I want to stop the
recursion error and consider working from the center out to find the
best peaks, since the edges of the flatfield confuse the issue.  Maybe
I could just multiply the profile by some function that peaks in the middle....

OK, fixed recursion error and got angle correct

Now onto making flats more reliable.  Note that the second derivative
helps here to pslot the sharp edge and re-multiplying by the profile
de-emphasizes the noise in the middle

            profile = np.sum(subim, 0)
            smoothed_profile = signal.savgol_filter(profile, self.x_filt_width, 3)
            d = np.gradient(smoothed_profile, 10)
            d2 = np.gradient(d, 10)
            s = np.abs(d2) * profile

[[  3.77351116e-01   3.82876712e-01]
 [  1.21697817e+03   1.38464772e+03]]
0.363246546527

Second run through looks even better with no missed points
[[  3.75447820e-01   3.87551301e-01]
 [  1.18163633e+03   1.42002571e+03]]
0.364456703475

Is that algorithm good for non-flats?

[[  3.71191460e-01   4.03051953e-01]
 [  1.17661504e+03   1.29683655e+03]]
0.369355340751

Holy smokes!  That's not bad!

In fact, it is better than the other way

Well, that is because a number are being rejected

Old way:
[[  6.27488411e-01   6.60076892e-01]
 [  1.09770298e+03   1.29057039e+03]]
0.57199207656

That is pretty crummy!

SII with new way:
[[  8.30095570e-01   8.50540538e-01]
 [  1.15190956e+03   1.27540733e+03]]
0.698846271587

Not good.  Of course, I am a little off in the initial
default_ND_params, but I still want to be able to get close.

It might be that I have to just remove stars and cosmic rays first,
so they don't mess up the signal from the edge.  Or I could try that
edge detection routine....

And now that I have a cheap and dirty way to rotate the images, I
might go back to the collapse vertical idea, since mostly I want to
just get the left-right

I am not doing a true rotation, but a shift, which is why Jupiter
looks so weird, as does the flatfield image.

Tue Nov 28 17:39:39 2017 EST  jpmorgen@snipe

Not sure if that matters too much.  After fixing the algorithm to work
differently for flats and images, realizing my bounds did not need to move

[[  3.72612513e-01   3.91825984e-01]
 [  1.12312877e+03   1.47317201e+03]]
0.365084804118

Wed Nov 29 11:48:56 2017 EST  jpmorgen@snipe

OK, I think I can improve on the peak selection algorithm if I choose
peaks that are the right distance apart.   But before I do that, check
things in & re-check for flat performance

Ah Ha!  I should probably iterate when I do the point rejection
algorithm.  I do a second pass, but that is different, since lots are
missing from the first pass

I might do well to include weights.  Or not have absolute difference
but use stdev

Thu Nov 30 07:46:55 2017 EST  jpmorgen@snipe

Ah.  I can use weights in the subsequent iterations

Thu Nov 30 09:21:05 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/23797825/what-is-the-pythonic-way-to-bubble-up-error-conditions

Has a good discussion about how to handle errors and exceptions and
whether or not to return None vs a null object:

http://code.activestate.com/recipes/68205-null-object-design-pattern/

I'll have to think more about this as time goes on.

I think that I will not handle all possible errors, but just in case,
this is an interesting bit of code

        except:
            # Thanks to https://stackoverflow.com/questions/15605925/how-to-get-the-last-exception-object-after-an-error-is-raised-at-a-python-prompt
            log.error(sys.exc_info()[1])
            return None

OK, I am having trouble with the array being the wrong orientation for
my new way of fitting the lines.  When given two sets of lines points
polyfit made the first column the first line, the second column the
second line.  This is pythonic.  I did things row-by-row with

ND_params = np.asarray((ND_params0, ND_params1))

Hmm

SII =  CorObsData('/data/io/IoIO/raw/2017-05-28/Na_IPT-0035_SII_on-band.fit')
print(SII.get_ND_params())
print(SII.ND_angle())

Shows things aren't working all that well for the SII image....

I think this might benefit from the differences method

Na image
[[  3.70590906e-01   3.91039665e-01]
 [  1.11869115e+03   1.47671815e+03]]
0.363859230268

After clean up linfit, max_fit_delta_pix = 5
[[  3.72491235e-01   3.92456403e-01]
 [  1.12169240e+03   1.47507210e+03]]
0.365306905718

max_fit_delta_pix = 25
[[  3.71568935e-01   3.92436721e-01]
 [  1.12235642e+03   1.47245281e+03]]
0.364895956723


OK, that looks good, but the SII image needs help.  In particular, I
need to know when to start looking for peaks, since the cwt finds some
where there are none.

We are generally looking for [1312 1419]

OK, as I am doing the SII flat, I see that I can set an upper limit to
the spread in flat mode as just under 1/2 of the CCD width, though
that is definitely liberal + will likely have problems when close to
the edges.


Ah ha, the bounds can be the size of the SII filter for all the flats

Well, that ended up being worse.  But I can use the vertical size too
350 1900

Beautiful SII flat

[[  3.78470178e-01   3.86181647e-01]
 [  1.21542960e+03   1.38570910e+03]]
0.365177868072

Hickup in one location in Na flat
[[  3.79115598e-01   3.87003140e-01]
 [  1.21585461e+03   1.38458248e+03]]
0.365817629192

SII image
[[  3.67503733e-01   3.89594787e-01]
 [  1.11991952e+03   1.46640214e+03]]
0.361878713669

Na image (slight glip)
[[  3.72051081e-01   3.88777783e-01]
 [  1.12240319e+03   1.47295464e+03]]
0.363509099347

1.12240319e+03 - 1.11991952e+03
2.4836700000000747
>>> 1.47295464e+03 - 1.46640214e+03
6.552500000000009

I'd say that is pretty good!

1.12240319e+03 - 1.21585461e+03
-93.4514200000001

1.47295464e+03 - 1.38458248e+03
88.3721599999999

So there is some bowing, but that is probably because of the 2nd
derivative technique.  This might also explain why I have such a wide
bounds.  For now it looks like I don't need to get the flats precise,
just good enough to get the morph and bounds set

Thu Nov 30 16:37:01 2017 EST  jpmorgen@snipe

OK, reading to clean up code.  Do I want to use the getter and setter?
The advantage of doing it that way is that the caller doesn't have to
know the internal workings.  They just ask for the property and it is
produced.  Disadvantage is that there may be some instances where it
is expedient to pass parameters to tweak the algorithm used to
generate it.  Although that is not necessarily wise, since one of the
whole points is that I calculate it once and then return the cached
value.  It is more set up to tweak the property or attribute, or
whatever they are called on instantiation or shortly thereafter,
before the first call to do the long calculations.

I should have a way to re-do the calculations on an existing file with
the NDPAR* keywords, since they might refine.  Or I could remove them
externally and go with that.

It could be that I do:

ND_params = property(get_ND_params, set_ND_params, fdel=None, 'ND_params characterize the coronagraph ND filter')

for both ND_params and default_ND_params.  Of course that brings up
the long-term storage issue for default_ND_params, but I will deal
with that later.

Thu Nov 30 20:57:08 2017 EST  jpmorgen@snipe

Learning about the property() decorators and their limitations.  The
setter really takes just one argument and can't be used like a
function call to recalculate.  I would have to say something like

Na.ND_params = 'recalc'

The alternative is Na.calc_ND_params()

Either way is fine.  Might as well enable both for now.

As far as ND_angle goes, it is probably safest to recalculate it when
needed, since it is cheap, but in general I would want some sort of
registration system that listed the things that needed to be
recalced.  For now, I can just put the calculation of the angle in 

--> The ND_coords, obj_center, etc. would need to be recalculated
    too.  I could have a flat that indicated for each of those
    components if recalc had happened.  All of this to avoid just
    discarding and restarting the object, which could be expensive
    with an open file, though I could possibly extract the HDUList

My primary use for this is for a live system, with one chance to get
it right.  It will move on to the next image.

This brings up the question of efficiency.  I was hoping I could have
this running all the time, but it looks like ACP wants to call it on a
per exposure basis.  I suppose I could have it be like one long
exposure....  but worry about that later.  The point is, I don't need
to be infinitely flexible here on this particular object.

Fri Dec 01 12:09:10 2017 EST  jpmorgen@snipe

So go back to the ACP question.

It looks like AcquireImage() can completely replace what ACP does when
acquiring a single image.  ** it has to check for the need to flip **
Return True = differ to ACP, OK means user function presumably handled
acquisition and False is abort entire run.  That can handle all of the
filter motion, recentering, guiding, etc.  It could be that I have the
background helper process running & looking for images showing up in
MaxIm that have been initiated by this script.  But at the very least,
I can have this script do periodic centering on a per exposure basis

TargetStart() is also a possibility, but it is before AcquireImage()
and seems to be more for tweaking things you should probably have
tweaked in your observing plan.  TargetStart() could potentially help
redefine things based on moon position, but I might want to put all of
that logic into AcquireImage()

Aside: I still don't see anywhere where I can tweak focus, but that
might be something I can do in AqcuireImage()!
--> Want to make sure I can be tracking Jupiter properly

So if I just set up for one Jupiter AcquireImage(), I grab the
observatory for the whole of when Jupiter is up, make my own flip
decisions, autofocus, etc.  Then when I release, ACP can pick up on
whatever plan/Schedule is available.  Autofocus from there might not
be the greatest, but I could still have a general part of AcuireImage
for that.


--> Hey, on-the-fly exposure adjustment is possible with this!
http://forums.dc3.com/showthread.php?10314-Question-on-UserActions-or-similar&highlight=TargetStart

#tag can be saved in a global part of UserActions

#tag is available to AcquireImage() and Description field of ImageSet
 or Observation is available

--> I will have to dig deep into AcquireImage.js

Either that or I could just have every Nth time through my internal
AcquireImage() loop return True so that there is just a generic
picture of Jupiter recorded and scope flip, autofocus, etc. is handled
automatically

--> HEY WAIT A MINUTE!  There is an autofocus script!  No, that is
    just a shell around SUP.AutoFocus.  But if I tweak all of the
    calls to SUP.AutoFocus in AcquireImages.js to add a little bit to
    the target RA, I should be set.  I can do this in IoIO mode only

In any case, however I end up structuring the AcquireImage()

ret = SUP.UserActions.AcquireImage(Pl, Tc, Is, imgFile + ".fts");   // Call with full name

where Pl is the plan object, Tc is the telescope control object and Is
might be image set?  We would basically replace one image with many.

So my personal AcquireImage could check to see that the background
guiding process was running (if I use that) and then just bang away
and telling MaxIm to record images
--> might need to insert yield statements

Taking a step back... No, I don't think I want to use the default
AcquireImage because it does the whole tracking thing.  So even though
it gets me name logic.  Wait.  Does it?  Not sure.  Anyway it looks
like my original plan should work, with the background task looking
MaxIm and feeding it to my Python script.  If there is a fight going
on for MaxIm, I can just have my script exit (might need to learn how
to pass it messages) when I do the periodic ACP thing.  I mostly want
it running to avoid the long startup time (assuming there is one).

OK, so I should plan for occational starts to ioio.py, or whatever it
ends up being called.

So this means I am going to need a way to read in the
default_ND_params, or have them hard-coded.  It would be cushy to have
a way to write them within the object + read them back + I suppose I
could check for system names like I did for something else.

So all of this is leaning me away from a system that has the
complexity to re-process the innards

Looking into the fitsio stuff, it looks like I can extract the HDUList
object from a running ObsData and shove it into a new ObsData for
processing there.  So there is no need to do the reprocessing within &
there is possible motivation for having multiple objects storing the
results

OK, so if I open a file, keep it open, if I read a file from a
filename, close it

Fri Dec 01 20:13:05 2017 EST  jpmorgen@snipe

For some reason, when **kwargs is empty, an empty dict is passed
instead on None

Just look for falseness

Mon Dec 04 14:17:23 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference

arguments are passed by reference.  Once I rebind the reference
(physically set the parameter name to something else), it is separated
from the outer object.  But I can operate on the parameter name 

So the way I have read_im written, I assign the value of the argument
to something else, but I think that means the full object goes along
and I can mutate it

def try_to_change_list_contents(the_list):
    print('got', the_list)
    inner_list = the_list
    print('assigned to inner_list')
    inner_list.append('four')
    print('changed inner_list to', inner_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)

Confirms that the inner name mutates the actual object

OK, so when I read_im an nd_array, if I were to del self.HDUList, I
would delete that original nd_array?  No, I think I would delete the
self.HDUList pointing to it, but the original nd_array would live.
No, only if something else is pointing to it.

I am planning to have a process monitor the MaxIm notify events and
grab the image then.  Whatever loop is doing that is going to call the
MaxImData.get_im and receive a tuple from MaxIm and shove that into an
NDarray that will eventually get into an ObsData.HDUList.  If the
MaxImData.get_im returns an HDUList into a loop variable, presumably
all past versions of that loop variable are not kept.  But if there
are objects that reference the NDarray(s), they will stay hogging
memory.  So the trick is to delete the objects referencing the NDarray.

Hmm.  Deleting obj.HDUList removes it from the namespace, which is
different than setting it to None.  Either one will deference and let
the memory free, but one is a little more gentle than the other.

If I really am using the ObjData to store data about the observation
and not the observation itself (which could be stored outside without
being deleted when I delete the HDUList inside), I should definitely
delete the HDUList, because there will be a hard error when I try to
improperly use the object.  The object is only for calculating,
storing and delivering the property of the obj_center and
desired_center and whatever else I may need (e.g. y_cent)

OK, I am now running into problems with the binned and unbinned
center.  I absolutely need unbinned to be able to do the re-centering
calculations.  I may want to 

Mon Dec 04 17:10:26 2017 EST  jpmorgen@snipe

OK, now I am facing the binning issue.  It might be that I just need a
method that takes care of unbinned coordinate calculation.  Maybe
something like "unbinned."

Ah, then I could have another function that would be for binned.  That
might be motivation for having the center type property be methods
again, or I could just have a separate property.

To be clear I might need to have unbinned always referenced in my
calls.  Or have both so it is always clear

Not necessarily!  I can use ObsData.binned() to do the conversion!

As far as binned exposures for calc_ND_params, the best thing might be
to just rebin them.  Apparently I need to write my own code or get
some from a wheel.

Tue Dec 05 15:55:36 2017 EST  jpmorgen@snipe

I think I can get the rebin code into ioio.py

Done!  Might be slow the way I do it rather than binning all the
calculations

Background seems to confuse:

atv, '/data/io/IoIO/raw/2017-05-28/Na_IPT-0001_moving_to_SII_on-band.fit

--> need to have checks for inside image

/data/io/IoIO/raw/2017-05-28/Trius_SX694-0009_1x1_bias.fit

crashed program

Fixed that.  Did whole directory in 1123s.  That is 252 files
1123.5540227890015/252
4.458547709480165

I can cut that a bit maybe by making the n_y_steps smaller, say 8

Center of mass is used for obj_center, so there is no risk that it
would be outside of the image, though it might be wrong.

Tue Dec 05 21:03:22 2017 EST  jpmorgen@snipe

Rj = np.asarray((50.1, 29.8))/2. # arcsec
plate = 1.59/2 # main "/pix

Rj/plate # Jupiter pixel radius
array([ 31.50943396,  18.74213836])

np.pi * (Rj/plate)**2 # Jupiter area
array([ 3119.11276312,  1103.54018437])

np.pi * (Rj/plate)**2 * 5 # Jupiter 5 sigma
array([ 15595.56381559,   5517.70092183])

Wed Dec 06 08:02:13 2017 EST  jpmorgen@snipe

Down to 966 seconds with 8, as expected
--> I should do a comparison of values



/data/io/IoIO/raw/2017-05-28/Na_IPT-0018_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0016_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0013_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0025_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0022_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0024_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0029_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0037_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0010_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0039_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0020_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0023_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0005_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0038_moving_to_SII_on-band.fit

Seems to be the problem here is that there is just not enough signal,
which is fine


/data/io/IoIO/raw/2017-05-28/Na_IPT-0038_moving_to_SII_off-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0027_moving_to_SII_off-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0015_moving_to_SII_off-band.fit


/data/io/IoIO/raw/2017-05-28/Na_IPT-0040_moving_to_Na_on-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0001_moving_to_Na_off-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0036_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0011_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0026_SII_off-band.fit


Go over worrisome pathological cases
atv, '/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit

That was cleared up with medfilt with a kernel size of 3.  Harder to
get rid of saturated moons.  On the moving_to, they are not saturated.

As I am moving on in this, I am wondering if the right thing to do is
let the files be written and handle the calculations off-line with
another program, since I am not sure they can happen quickly enough to
keep MaxIm happy.  It would be great if I could fork a child process
that takes the HDU and does its work while the primary process
returns.  But ultimately, I just need to know where Jupiter was at a
particular time and how to tweak the guider, if I am going that far.
If I am just setting things up, I have to wait for my process anyway,
reading a file might not be that much more time.

--> last thing I need to do is a sensitive adjustment for the distance
    between the peaks

Wed Dec 06 12:45:02 2017 EST  jpmorgen@snipe

Hey, I can save some time with the savgol_filter by only checking
around bounds.  Better check code in before I mess with that....

Wed Dec 06 15:58:25 2017 EST  jpmorgen@snipe

Well, I have the sorting stuff working, but it doesn't necessarily
give a better value.

Thu Dec 07 09:44:18 2017 EST  jpmorgen@snipe

Whew!  Found an error in rotating ND_params back.  Things look a bit
better now + check with reality in a very difficult case.

I am starting to think that the best place to put the
default_ND_params determination is where I call CorObsData, not in the
object itself.

OK, so I am facing the problem I had earlier, that to jump-start the
process the flats need different parameters than the objects.  DO I
want to deal with this inside the object or outside?

For now it is handy to do so inside.

Last bit of bullet proofing would be default width


1st time
[[  3.73167520e-01   3.66137275e-01]
 [  1.19204226e+03   1.40353646e+03]]
2nd time
[[  3.80135555e-01   3.84551127e-01]
 [  1.24392453e+03   1.35668924e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit
[[  3.80797076e-01   3.83683119e-01]
 [  1.24304866e+03   1.35375702e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
[[  3.89720321e-01   3.82599096e-01]
 [  1.24469871e+03   1.34865465e+03]]

I am liking this now.

1.24469871e+03   -1.34865465e+03
-103.95594000000006
>>> 1.24304866e+03   -1.35375702e+03
-110.70836000000008
>>> 1.24392453e+03   -1.35668924e+03
-112.76470999999992
>>> 1.19204226e+03   -1.40353646e+03
-211.4942000000001
>>> 

That is inverse order

1st
[[  3.73167520e-01   3.66137275e-01]
 [  1.19204226e+03   1.40353646e+03]]
2nd (one missing point in lower profile)
[[  3.79288017e-01   3.84777194e-01]
 [  1.24398821e+03   1.35656141e+03]]
3rd
[[  3.79288017e-01   3.84777194e-01]
 [  1.24398821e+03   1.35656141e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit
[[  3.79359014e-01   3.84492566e-01]
 [  1.24230393e+03   1.35360561e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
[[  3.90798410e-01   3.82329457e-01]
 [  1.24535857e+03   1.34778286e+03]]

Looking very nice

The next thing I want is a distance from the center of the ND filter

https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

They prefer the parameterized form of the line

ax + by + c = 0

http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html

Has

y = -a/b x - c/b

That is what I am looking for

m = -a/b
h = -c/b

where h is the intercept

b = -a/m = -c/h
c/a = h/m
h = mc/a

This is just chasing my tail.  Use 2-point form:

abs((x2 - x1) * (y1 - y0) - (x1 - x0) * (y2 - y1)) /
((x2 - x1)**2 + (y2 - y1)**2)**0.5

Thu Dec 07 20:51:44 2017 EST  jpmorgen@snipe

Got that working.  It was a problem with the X origin.

Now doing the long run and finding that, predictably, all dy valyes in
the desired_center are 0.  Nicely, the dx values are pretty darn small
too.

--> the variation in the obj_center is unexpectedly large

Fri Dec 08 12:48:05 2017 EST  jpmorgen@snipe

--> first few exposures on 2017-05-28 might be having a problem with
    background being so bright -- my silliness of exposign during
    civil twilight

--> consider subtracting median of cropped image or use histogram
    technique to spot that background.


/data/io/IoIO/raw/2017-05-28/Na_IPT-0011_moving_to_SII_on-band.fit
/usr/lib/python3/dist-packages/scipy/signal/_peak_finding.py:412: RuntimeWarning: invalid value encountered in double_scalars
5.73232033471
[ 0.          7.23630139]
[ 0.  0.]
4^---8>-----
[ 0.          5.37101387]
[ 0.04228364  0.00387351]

/data/io/IoIO/raw/2017-05-28/Na_IPT-0013_moving_to_SII_on-band.fit
2.15110699901
[ 0.          4.60368123]
[-0.81430089  2.35449183]
4^---8>-----
[ 0.          2.41291612]
[-0.79947457  2.29283603]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0017_moving_to_SII_on-band.fit
0.461735778369
[ 0.         -3.19025364]
[ 0.8024765  -1.35503926]
4^---8>-----
[ 0.          5.44327348]
[-0.42432581  2.11040623]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0021_moving_to_SII_on-band.fit
3.00364028726
[ 0.          5.28533696]
[-0.16645221  0.48286966]
4^---8>-----
[ 0.          1.97240713]
[-0.00626509  0.02047843]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0022_moving_to_SII_on-band.fit
1.63188808341
[ 0.         -3.67625137]
[ 0.01745688 -0.31393855]
4^---8>-----
[ 0.        -7.4422813]
[ 0.0973593  -0.86116534]

Where the top is the desired center difference between tries with
different y_steps and the bottom is the difference in the
obj_centers.  Basically, the obj_centers are very stable except for
the case where the background sky was very bright.

Sun Dec 10 15:03:27 2017 EST  jpmorgen@snipe

I think the ioio.py algorithm is shaping up pretty well.  Did a little
more streamlining and checked it in with an amendment.  I love git!

Now the big test is to see if I can find an off-ND filter image.

First of all, I can test some of my current logic with a flat

I think the way to do that is to do a walk and see if I can find any

Sun Dec 10 18:07:53 2017 EST  jpmorgen@snipe

Looking like I am having trouble with my Jupiter in ND filter testing
algorithm

Mon Dec 11 09:21:20 2017 EST  jpmorgen@snipe

Consider making ND_coords faster with some coordinate math
/data/io/IoIO/raw/2017-05-20/Sky_Flat-0010_SII_on-band.fit
((0.37978158134653572, 0.38067280430080175), (1286.5410005790682, 1286.2680292376658))

Fixed that with some proper indexing!  Lists stack up in the first index

O = CorObsData('/data/io/IoIO/raw/2017-04-18/IPT-0001_off-band.fit', default_ND_params = ((-0.07286433475733832, 1251.595679328457), (-0.068272558665046126, 1357.3942953038429)))
  File "/home/jpmorgen/py/IoIO/ioio.py", line 1055, in ND_params
    this_ND_center-subim_hw:this_ND_center+subim_hw]
ValueError: could not broadcast input array from shape (0) into shape (1456)



/data/io/IoIO/raw/2017-04-15/IPT-0017_on-band.fit
[ 1104.69385143  1273.05462992]
WARNING: Large dist: 18 [unknown]

/data/io/IoIO/raw/2017-04-15/IPT-0027_off-band.fit
[ 1114.43688405  1251.88337244]
WARNING: Large dist: 40 [unknown]
(reasonable center)

/data/io/IoIO/raw/2017-04-20/Filter_sequence-0001_10s_Na_on-band.fit
/usr/lib/python3/dist-packages/scipy/signal/_peak_finding.py:412: RuntimeWarning: divide by zero encountered in double_scalars
  snr = abs(cwt[line[0][0], line[1][0]] / noises[line[1][0]])

Good example of a complete lack of signal to detect ND filter and a
star that doesn't saturate

I want to create a routine that derives the default_ND_params for
a particular directory.  Should that be in CorObsData?  I don't think
so.  It is a separate utility that needs to be in the module and uses
CorObsData.  Hey!  It could be an object itself.  Hmm.  That is a
little awkward.  It is basically just an ndarray, so I am not sure I
need to be all that sacred about it.  If I had some larger object that
kept track of many CorObjs, I might do it as an object with property,
but that doesn't stop me from making it a simple method in the ioio module

--> Might want to test to see if ND in default par has any signal
    before trying to look for one

got ND filter, but missed star
/data/io/IoIO/raw/2017-04-20/Filter_sequence-0001_1s_open.fit
WARNING: Jupiter outside of ND filter?  obj_ND metric expected > 5000 calculated =  [unknown]

<fixed algorithm>

Bad!!!  ND filter problem?  Need wider margin?
/data/io/IoIO/raw/2017-05-27/IPT-0007_on-band.fit
[ 1059.67224866  1349.63286885]
WARNING: Large dist: 60 [unknown]

<found better flats>

Star image, not even close, metric must have been off
/data/io/IoIO/raw/2017-04-21/Filter_sequence-0001_1s_open.fit
[ 1144.33194632  1216.89788347]
WARNING: Large dist: 72 [unknown]

Mon Dec 11 19:53:54 2017 EST  jpmorgen@snipe

While I am getting more things to look into on that front, start to
look into the MaxIM/ACP side of things.

Based on behavior noted in the logs, it looks like in order to use the
guider on a non-siderial object, I need to define a SUP.UserActions.
That apparently operates on that Count level.  But I don't want to be
launching a big Python script all the time, which is why the
invitation to replace a large section of AcquireImages.js.  It would
behoove me to copy as much of Bob's code as I can to get the basics
set up, but I did the Python because there is just way too much
sophistication for that to be done in .js.

/data/PSIScope/observing/AcquireImages.js line 1774 is where he starts
the autoguider.  I may opt to just do it with my own code, since I
think he checks lots of other thigns, though I could try it either
way.  It would get the error graphs onto the the website.

Either way, once the guider is started, the next most important thing
for my code to do is command MaxIm to take pictures and watch them
come in to get the obj_center and desired_center.  Those *_centers go
on a stack that helps move the guide box or stop the guider and
totally move the telescope.  I guess the later makes it clear that I
should probably not have ACP handle the guider.


Note AcquireImages.js line 1806 + things above that got orbTrackRealRates
                       if(orbTrackRealRates)
                            SUP.SetTrackOffset(Tc.RARate, Tc.DecRate);      // Complier assures scope can do tracking

Since he is doing those calculations, it might be nice to have a user .js
script do them.  But I think I should be able to have access to all of
those objects, just like in MaxIm, which is beyond way cool!

In any case, my script is going to be called when Jupiter is near the
center <see below for argument that I can do this one image at a time>

Check if need flip (see line 2941 of AcquireImages.js), --> add time
for first alignment if not guiding and/or tracking

If not guiding and/or tracking (first entry)
def center_loop
    Loop:
        Preliminary exposure (R-band)
        Check close enough
            break if so
        Move to expected center

    Start guider
    Loop:
        Preliminary exposure (R-band)
        Check if close enough
            break if so
    	if too far warn & recenter with loop above
        Move Jupiter with guide box (separate Loop)

    else:
        Take Requested filter image
	<Possibly with ImageEnd()>
        Process image with CorObsData
	Accumulate CorObsData
	If not too far off
	    Generate guide box rate + send to guide box mover section of code
	else:
	    warn
	    If way too far off:
	        Turn guider off & return OK to trigger loop to recenter
                and initialize guider
	    else:
	        Use Start Guider loop


Guide box mover
    Initialize when guider initialized -- remember initial guide box
    position
    
    Accept rates

    Independent Loop:
        Move guide box according to rates
	
    Fail if getting close to camera edge
    Fail if Jupiter fades
    --> Add script fail to shut down

The way Bob has it structured, AcquireImage() is designed for a single
image, but I don't see why it could't be a very long image.  It is
like going off and doing DAWNFLATS.

ret = SUP.UserActions.AcquireImage(Pl, Tc, Is, imgFile + ".fts");   // Call with full name

So the first thing I need to do is check to see if I can access the
Pl, Tc, etc. objects from Python.  I kind of doubt it.  But I can
write a .js that does the looping after preliminary set up in Python.
The Python event catcher can do the guiding thing.

http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/scr-ovw.htm

Says that Python should have it

--> how are the user scripts interrupted by weather?  AcquireImages
    doesn't seem to handle weather, so maybe that is done somewhere
    else.

Tue Dec 12 08:47:57 2017 EST  jpmorgen@snipe

I think I am just going to need to work with a simulator on this.
Consider setting puppy up as the completely independent simulator 

I already have MaxIm.  It complains that my PinPoint license has
expired.  Looks like I should get a full version of that

scp "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/ACP/acp-811-setup.exe" jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/data/io/IoIO/observing/ACP/

scp "/cygdrive/c/Users/PLANETARY SCIENCE/Downloads/NOVAS(2.1.1)Setup.exe" jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/data/io/IoIO/observing/ACP/

Email from 04/26/2017 in Proposals/NSF folder gives download locations
for DC3 products

Oh, but I want to just install ACP and PinPoint comes along for the ride

Or so it says.

Getting USNO A2.0 catalog for snipe

/data/USNO_A2.0/


cd /data/USNO_A2.0/
ftp ftp.nofs.navy.mil
anonymous
jpmorgen@psi.edu
cd usnoa
bin
prompt noprompt
mget *

Seems to be stuck on readast.v10

Seems to stick if I try to download the whole thing at once.  After a
break, it goes OK.  Although I am trying to avoid it, possibly best to
just get from IoIO1U1.

rsync -auv  "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/From Dean/usno/" jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/data/USNO_A2.0/

Interesting.  250kb/s from PSI, 1Mbs from observatory

some stars that showed up as Jupiter
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_off-band.fit

Hey, that looks like Jupiter!

Install FocusMax 3.8.0.20, which comes with the focuser software

turn on AutoFocus on ACP restart, now that I have FocusMax installed

Choose Simulator ASCOM Focuser Driver.

Having a little trouble with the simulated focus because the MaxIm
star is too dim and it doesn't respond to exposure time changes.  But
I can lower the minimum flux requirement to 10k.

That worked.

Wed Dec 13 13:29:49 2017 EST  jpmorgen@snipe

Playing with weather simulator, which is a separate app.  Needed a
kick start to get that working, but after second try, did what I
expected.

Back working on

/data/io/IoIO/raw/2017-04-26

This is a great directory because it has some stars that are saturated
and Jupiter!

Saturated star
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0002_10s_SII_off-band.fit
sum >=40000 397222.621745
Only 9.93055 pixels, which is just a star

Others have sum >=40000 0.0 because of setting pixels to 0

'HIP62757'
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0002_1s_open.fit
sum >=40000 6768073.49695
169.201825

No OBJECT, which suggests its Jupiter + it looks like it too!
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_off-band.fit
sum >=40000 203992874.26
5099.8218565

In my code I have 65000* 250 pixels
16250000 = 16E6.

Actual Jupiter image was 203E6.  Bright star 6.7E6

I think I am pretty good.

Check centers.  Within a pixel!

/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_on-band.fit
sum >=40000 155408846.013
155.40884601300002E6
Within 4 pixels

OK.  Together with the fact that this runs in 0.5s suggests that I am
ready to roll!

Wed Dec 13 13:53:39 2017 EST  jpmorgen@snipe

OK, back to the ACP simulator stuff.  Before I add user scripts, I
should make sure that a basic plan works

#DOMEOPEN

#Filter   R, [SII] on-band, Na on-band, [SII] off-band, Na off-band
#Binning  1,   		 1,          1,              1,           1
#Count    1,   		 1, 	     1,		     1,		  1
#Interval 0.5,		 0.5,	     0.5,	     0.5,	  0.5

test_meridian	17:00	00:00

#SHUTDOWN

Worked fine

Thu Dec 14 09:11:32 2017 EST  jpmorgen@snipe

At some point, I need to decide when to merge this stuff back to
IoIO.notebk.  For now continue thought here.

Camera not connected so I can't check, but I seem to recall that I did
exposures in 1-hour chunks.  Io's orbital period is 42.45930686
hours.  Sampling it during its ortbial period 10 times seems fine if
orbital period is all that is going on.  But since I am able to
resolve structure close to the moon which might be affected by the
torus, having more frequent sampling would make sense.  The torus ansa
itself changes on 15 minute time scales.  Changes at Io could be even
more frequent

1m Na off-band
5m Na on-band
9
5m [SII] on-band
1m [SII] off-band

For a total of about 60 minutes of observing time per cycle.  I could
have this be chopped up in a different way if I want.

Looking at logic in /data/PSIScope/observing/AcquireImages.js and find
that the AcquireImage user action continues back to the Count loop so all of
the logic below there is skipped, which includes messing with the
guider and it looks like tracking too.  So in my user action script, I
need to take care of all of that.  But to give me flexibility of
messing with exposures at the Scheduler level, I should probably have
my script just handle things one at a time after launching the Python
background job.

Ah, the code above the AcquireImage user action is not all that
extensive, but does include autofocus and reslew.  This means that
Jupiter might spontaneously end up in the wrong place sometimes if I
use the Count loop and the autofocus periodic or adaptive features.

The alternative is just using an hour-long (or however long)
"exposure" in scheduler and handle all of the exposure looping in
there.  Given that I want to, that sounds reasonable.  But think for a
miniute how it might work with the independent Python job.  Given that
it is only looking at the images as they are taken from MaxIm and has
no control over the initiation of the images, I don't see it working
to do guider stop, telescope move, reinitialize.  That has to be
handled by the code asking MaxIm to take an image.  But I would need
to have some code asking for the image anyway.

OK, so it looks like a question of overhead.  I could use the
individual image stream from ACP/Scheduler and do a pre-image every
time, which would be a waste, but would get me in line.  I could live
with up to a 5-minute exposure lost each hour after a focus.  That
might be more time lost to find itself.

Hey, there is a flag that gets set when the autofocus stuff is done.
That is what I was looking for!  It is AG (auto guider) and Orbital
Tracking

--> hmm.  Not sure I want to use his autoguiding stuff

This is how I would turn it on and off
SUP.AutoGuide(true);
SUP.AutoGuide(false);

This is how I test --> not sure which is best
SUP.Guiding
SUP.GuiderRunning

Other indication:
var orbTrackRealRates = (Tc.OrbTrack && (Tc.RARate !== 0 || Tc.DecRate !== 0));

This is how I would set it

if(orbTrackRealRates)
    SUP.SetTrackOffset(Tc.RARate, Tc.DecRate);      // Complier assures scope can do tracking

But not sure if that has the real test.

Anyway, I can get to that when I need to.  It definitly looks like my
first-level user action can use something like these to test to see if
it is the first time it has been entered and go through the necessary
logic loops above (search for Loop:)  Amend that

Hmm.  So where am I going to have my event loop for moving the guide
box?  That has been the hard thing.  I guess to start with I could
just skip that part and do periodic recenters when the distance gets
too large.  But what I really want is that process to be running in
the background to help MaxIm keep the object in the primary mirror
centered.

To do that I would need to learn how to launch a separate process and
pass messages to and from it.  At the most basic level, all those
messages need to be are the _rates_ in RA and DEC that I want to move
the guide box.  The process would then generate a string of the
appropriate MaxIm object commands to move the guide box.  It would
also need to have some way to know when it got to the edge

OK, back to the scheduler aspect.  I might be able to have the
Jupiter plan include a calibration star.  That would be where it gets
the right autofocus HFD.

Work in PSIScope.notebk on getting scheduler up and running for more
objects.

Sun Dec 17 15:22:07 2017 EST  jpmorgen@snipe

Ack!  Scheduler doesn't like the Foster Systems roof controller.
Sigh.

Anyway, I can get by with ACP until I resolve that issue.  Go back to
getting my Python code to run on Windows & with ACP or MaxIm or
however I do this. 

Ah, I remember why I wanted to have it running in the background: it
takes a long time to load all of the modules it needs.

This was a little complicated because I have Daniel's thing, but as
long as I put it in the same directory (as a link), it loaded OK.
First time I launched it, it took a minute.  Second time was more like
10s, but that extended back to 30s or so after another try.

Individual files in a process_dir take about 1s, as expected on a
slower computer.


https://www.pythonstudio.us/introduction-2/implementing-com-objects-in-python.html

Hey, it looks like I can create a python server!

import pythoncom

etc.  Whew!  It looks like I can get what I want in both directions.

If I end up using TakePicture to take the image, I might want to use
the ImageEnd() user action.  Or I can just do everything myself in
AcquireImage, which might be a little cleaner

Sun Dec 17 20:47:07 2017 EST  jpmorgen@snipe

http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/scr-wsc.htm

This shows how I can create some WSC that lay around and do things I
want.  I think that is what the pytonstudio.us stuff is giving me in Python

Mon Dec 18 19:32:11 2017 EST  jpmorgen@snipe

So at some point, I am going to want to separate the Windows-specific
stuff from the CorObsData stuff.  I am finding thanks to Daniel's work,
that as long as the import is in the same directory as the original
script, it works just fine.  Plus I could probably figure out how to
make it work other ways.

So to start off with, I want to enable the WSC components in ACP.  No,
actually, I think I want to make sure the simulator works OK first.
Oh, I already did that with simulate.txt plan.

OK, set up WSC JS version

Tue Dec 19 09:02:53 2017 EST  jpmorgen@snipe

Did a test object in ioio.py which shows that an object with a wait
loop is not an independent thing.

So I need to create an independent program for both the guide box
mover and the CorObsData component.

Along those lines, I need to start thinking about what to call the
components of the [Python] program that are going to be collecting the
CoObsData and calculating guide box rates.

--> Check to see if FITS headers are persistent, otherwise make a list
    of keys I want to extract and have be permanent

The guide box move code should be simple enough for a js program.
that program has to run continuously and accept events

But I don't know if I want to bother learning how to do that, since I
am going to need to learn how to make one in Python anyway for the

I am sensing that I can make ioio.py have some arguments to main that
launch the various servers/clients that I want.  Otherwise, I just
import it and use the objects for reductions (or reductions will be
other arguments to main)

I have a MaxImData class definition that I will need in my guide box
mover, but the mover itself should not be in the cclass definition: it
instantiates a class member.

I wonder if I could have everything in one event loop, so the guide
box mover doesn't have to be a separate thing + can share property.
That seems to keep things a little more simple.  But I could
potentially split them out within the module if I need to.

OK, so what to call this.  We are making a server for precision
centering and dealing with differential flexure.  The fact that
Jupiter is involved is secondary

So there is basically one entry point: precision_center

Back to the guider loop.  I don't see how I can get around the fact
that I need a background process.  Looking into sched event
scheduler.  Still seems to block or need to be re-called.

Circuits is an event driven module

--> It may be that the server allows the loop to go on independent of
    other calls!  That would mean I would use the COM service to
    connect to my own server!
    
Tue Dec 19 14:47:06 2017 EST  jpmorgen@snipe

Hmm.  Doing some simple tests with HelloCom and HelloClient and find
that the COM object is instantiated on a per-client basis.  In other
words, dispatching the server starts its own instantiation of it.  I
have a feeling that what I am asking it to do is rather complex....

It might be that I can instantiate an object and store it as a global
variable in the place Bob gives me.

Looking into asyncio

Looking into ASCOM driver video https://youtu.be/XVlrDyIBd5I further
and find that the persistent state is maintained via the arduino board
not in the object.

Looking more at
http://timgolden.me.uk/pywin32-docs/html/com/win32com/HTML/QuickStartServerCom.html

_com_interfaces_

https://msdn.microsoft.com/en-us/library/windows/desktop/ms686618(v=vs.85).aspx

Ah Ha!  Persistent Object Interfaces

But there is not much by way of actual examples + it is not clear if
this is implemented in Python.

Fundamentally, if I have a process that I run separately that reads a
file with the rates, that would be sufficient.  The file could have a
control flag built in that would latch off when the MaxImDL guider
turns off.  It would work for me to do this in the ioio.py and have
the instantiation of it be a command line option.

Actually, the more politically correct way might be to have it serve
up COM object that does the interface!  Note that I have to run the
.py file once to register, but it is not clear if that goes across
boots

--> Check that object registration is persistent.  May be related to
    having MaxIm start once before all COM hooks are active and is
    likely so

--> Figure out where this goes possibly /cygdrive/c/Program Files (x86)/ACP Obs Control/Scripts/

OK, now that I think I know the limitations of the COM system, go back
to rethink the whole thing.

I basically want two things that are running all the time, or at least
persistent in memory.  The guide box mover is the one that has to
click continuously.  The rest of the code in ioio.py I just want to
sit there, ready to call.

I could make ioio.py an active X COM object with a set of exposed
methods for doing things that are called by AcquireImage.  If I make
the object a global variable, it is persistent as I want it.  I
probably wouldn't need too many exposed methods: append_obs

It would be Most Elegant if I could have guidebox_mover be an event
loop controlled within that object.

Ah. I see that what I really want is a coroutine, since that can go
along with yields

Maybe what I want is concurrent
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future

That still seems like the executors are separate processes.  The
coroutine has the example of being all one blob.  --> I could
potentially do it that way if I am not picky about how often the
GuideBoxMover gets called.  I just need to know it will be called
often enough

This just seems more trouble than it is worth

Really what I want is inter-process communication (IPC)
https://docs.python.org/3/library/ipc.html

mmap might be a way to keep this in memory

Wed Dec 20 10:20:47 2017 EST  jpmorgen@snipe

Looking into JSON and finding that I might be able to share a StringIO
object?  Maybe not.  I can't share objects across the processes

https://docs.python.org/3/library/json.html

JSON produces str not bytes, so that might not be the best choice for
mmap.

mmap seems really primitive in that it needs the size of the file and
stuff like that.

Probably a good idea to start with the regular old file first

Hey, they give me the child process example I am looking for!  Well,
that is on an OS that I would rather be working on....

So back to a JSON written to a regular file read by the

Thu Dec 21 13:20:20 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3

and

https://docs.python.org/3/library/asyncio-subprocess.html

http://dabeaz.com/coroutines/Coroutines.pdf

So I think the idea is that I am going to have a generator talk to the
pipe

But https://stackoverflow.com/questions/1196074/how-to-start-a-background-process-in-python

suggests that Popen without a pipe is the right way.  I would then
need to talk to it via a file

Thu Dec 21 17:36:16 2017 EST  jpmorgen@snipe

ioio.calc_main_move is what I want when Iwant to center the object.  I
have something commented out called center_object that does that.
That would be a public method in my AcuireImage user action

--> I still need to write the thing that does the guide box rates.
    But those are looking like they will be a tuple or np.array in y,x order.

So CCDCamera.GuiderMoveStar is what I want to eventually plug into.
It can do fractional pixels, so I can do this as often as I want but
should limit bandwidth.

I like the idea of letting GuideBoxMover decide the rate at which it
will poll

Sun Dec 24 14:07:39 2017 EST  jpmorgen@snipe

At some point I will want to add the complication of flexure.
Ideally that would be done as a separate process that looks at the
scope position, calulates the rate and feeds that to the GuideBoxCommander

Hmm.  On Windows, getting an error that a Python file is not a valid
Win32 applicaiton.

<sigh> because python defaults to python 2.7, I can't use the same
command on windows and Debian

I can consider doing an update alternatives on snipe....

Did that (see snipe.notebk) and things work more smoothly across
platforms

Now think about where I am going to put the centering command.  I have
the MaxImData object, which needs to be persistent for connecting
continuously to MaxIm.  So in that loop code, I need to instantiate it
and keep it around.

That suggests that I need to make a controller object

ObsData, MaxImData.  ObsControl?  PrecisionCenter?  PrecisionGuide?
ObsGuide?

This one object is going to have property that keeps track of the
accumulation of ObsData and has methods to control the initial
centering and guide box mover.

Sun Dec 24 20:13:20 2017 EST  jpmorgen@snipe

OK, I have written PrecisionGuide.center.  How can I test it?

P = PrecisionGuide() # defaults should be good
P.center('//snipe/data/io/IoIO/raw/2017-05-28/Na_IPT-0007_Na_off-band.fit')

After a bit of struggle, seems to have worked!  At least in info message

Now that connects to MaxIm's telescope and I think I got it to work on
the real thing before.

One thing I could potentially do is just record a pre-image in R
before every image and do a move & then return "true" to move on.

Mon Dec 25 17:23:29 2017 EST  jpmorgen@snipe

So if PrecisionGuide.center doesn't have an input, maybe I should have
it take one!

So that means I am going to need to learn how to record images with
MaxIm.  And handle the filters.

Fri Dec 29 14:03:11 2017 EST  jpmorgen@byted

It looks like I don't have Python for the laptop?  No, I do, but
somehow .py files are not associated.

Sat Dec 30 14:05:53 2017 EST  jpmorgen@byted

Got python properly registered on the laptop.  Really slow to bring
MaxIm up and do P.center(), but it does seem to work!

OK, so now I think I might be ready to implement the loops above for
centering and guiding.  As I plan that, I also need to look at the ACP
side of things.

Sat Jan 06 16:40:07 2018 EST  jpmorgen@snipe

Ack.  I am getting messed up by the importlib stuff when I try to do
isinstance because Python is super literal about where the
module/class comes from.

https://stackoverflow.com/questions/4821104/python-dynamic-instantiation-from-string-name-of-a-class-in-dynamically-imported

https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string

So the idea is that getattr uses the formal import.  But the locals
and globals

Sun Jan 07 19:57:48 2018 EST  jpmorgen@snipe

https://docs.python.org/3.6/howto/argparse.html#id1

That is all well and good and I can even do the func coolness, but it
goes back to whether or not the arguments are specified

--> Getting command line to work in Windows
https://stackoverflow.com/questions/29540541/executable-python-script-not-take-sys-argv-in-windows

Tue Jan 09 12:00:43 2018 EST  jpmorgen@byted

Put that as a note in ioio.py.  Will need documentation

Need to work on

Integration with ACP UserActions <not on laptop>
Guide box rate calculation system
GuideBoxMover system

I have GuideBoxMover and GuideBoxCommander.  What is missing is
whatever takes the sequence of ObsDatas and analyses it to produce
GuideBoxCommands.  That could be GuideBoxCommander

Reading from def center_loop above and wondering if I should separate
some tasks or combine them.  start_guider looks like something I am
going to need to do.  Do I have it do a center_loop or should
I assume center_loop is done first?  I could have it do the center
loop and raise any errors itself.

Fri Jan 12 11:55:07 2018 EST  jpmorgen@byted

Thinking more about start guider.  Having it separate means I can do
what I want to position the object where I want it

there is a maxim CCDCamera.GuiderRunning property, but that only tells
if the guider is running already

CCDCamera.GuiderTrack ( Duration )

is what I want to turn it on, where duration is the exxposure time
(need to think about that)

but before I do that I need to set the position of the guide start

CCDCamera.GuiderAutoSelectStar [= Boolean]

Does that to the brightest star in the FOV.  I of course want that
for Jupiter and generally for sideral targets, but when I am going to
be doing non-sideral guiding, I am going to want to override, or
something like that to pick a star off to one side so it can move a bit

GuiderSetStarPosition is needed if this AutoSelect is False

The PrecisionGuide.acquire_image is going to need to take (all?) the
parameter that ACP shoves at it.

Or do I want one that just has regular parameters I can pass from a
script instead of ACP.  Maybe I need two, since I was thinking of
having one do ACP's take_image and one just do it by itself.

I think I can leave it to run-time, since Bob makes available the
Util, etc., objects.  I can pass them in, defaulting to None.  If they
are there, that could be a signal I want them to be used.

Fri Jan 12 16:20:17 2018 MST  jpmorgen@byted

Thiniking GuideBoxController might eventually be a separate process
that receives input from PrecisionGuide.GuideBoxAdjuster, which just
runs once per image, and separate processes of TrackRateAdjuster and
DifferentialFlexAdjuster.  GuideBoxController would have each of these
objects registered in it with file-oriented (or better) communications
which tweak the ultimate rate at which GuideBoxController commands
GuideBoxMover to move the guide box.

Hmm.  GuideBoxAdjuster could be its own object with the property of
the ObsDataList.  I could have one for each filter, but I was thinking
I would figure out how to combine them.  

Maybe it would make more sense to have the GuideBoxAdjuster make the
list of ObsDatas

Mon Jan 15 11:17:16 2018 MST  jpmorgen@byted

Tried to use at telescope!  Got as far as getting an ND_params from a
flat, but was too hard to get it into PrecisionGuide.center

--> Think about how to get ND_params into PrecisionGuide

Mon Jan 15 11:51:32 2018 MST  jpmorgen@byted

For a standard ObsData, PrecisionGuide.center is easy.  What I want is
some way to get parameters in by hand.  So rather than having the
ObsData class be a parameter, I should probably just have made a
subclass.

But really I just need arguments to the ObsData class.

What can **kwargs do for me?  It is a dictionary of keywords

OK, I think I implemented that.  But now how to pass that in from the
command line?  I might want to do a * after something like --ObsDataArgs

--> think about making an emulator of MaxImData for Linux

Hmm.  Not sure if the **kwargs is really going to work with argparse.
I basically need to just know what the arguments are going to be

OK, should now be able to do

ioio.py --ND_param_dir "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\data\2018-01-16"

Mon Jan 15 20:10:30 2018 MST  jpmorgen@byted

Ack!  Passing **kwargs only works once.  Once the keywords have been
stuffed into a dictionary, they are a positional parameter [ah, I need
to pass them again as **kwargs, which puts them back into keyword
args]

--> ! script disconnects camera!

Fri Jan 19 08:08:11 2018 MST  jpmorgen@byted

So it looks like I need to do some work with the WCS keywords in order
to control guider slews properly

--> check to see where guider rate is set in APCC & if guider rates are
    different because of rectangular pixels in guider

--> I can do a sanity check with what it in MaxIm

--> guidebox move is going to need to know about rectangular pixels.
    Maybe guidebox move command should be expressed in arcsec


Indeed, I think having the WCS transformations from main camera pixels
to delta arcsec.  Guider move is going to be in delta arcsec which
needs to be translated into delta pix

--> should print be a function or a procedure?
--> a function

--> return is just a statement but can be a function

--> BASIC

Fri Jan 19 19:12:54 2018 EST  jpmorgen@byted

So I have been struggling with what to do with all of the command line
parameters that would get added by people's different modules.
Fundamentally what needs to happen is that a bunch more
center_parser.add_argument calls need to be made.  So center_parser
could be an object that gets passed around to the modules that add to
it.  So there could be some registration system.  It could be part of
CorObsData, but it really doesn't fit there.  It would need a
component that would add to the center_parser and the general parser
too.  And to the cmd_center

Mon Jan 22 08:20:19 2018 EST  jpmorgen@snipe

--> anti-stiction in DEC

Ack!  I think I have a bad pin point solution in the guider

--> get another guider plate solve

OK, PIERSIDE is what I want and not FLIPSTAT

I will want to have the MaxImData connect to the telescope itself,
since the MaxIm properties don't do all the work I need

FLIPSTAT should be '' or FLIP/MIRROR

In any case, for some reason it is not being used

--> I need to figure out what telescope object is being used

--> get guider rates

Guider rate is a setting on the Rate settings menu in APCC
http://www.ascom-standards.org/Help/Developer/html/P_ASCOM_DriverAccess_Telescope_GuideRateDeclination.htm

<sigh> so just like all ASCOM components, I have to separately specify
the equipment

AstroPhysicsV2.Telescope

Before I forget, tweak the run_level_default_ND_params

ioio.py ND_params '/data/io/IoIO/raw/2018-01-22'
    = [[  3.63686271e-01,   3.68675375e-01],
       [  1.28303305e+03,   1.39479846e+03]]

Now I would like to use that.  Difficult logic in the __init__.  I
think that I might have to use run_level_default_ND_params in the
invocation of 

Mon Jan 22 17:16:46 2018 EST  jpmorgen@snipe

--> Hey, ACP doesn't like to have MaxIm connected to the telescope, so
    maybe I should avoid doing that too, if possible

So how invovled do I want to get with the MaxIm stuff for the
telescope?

Auto Scope Dec would presumably need the scope connected to MaxIm.
But ASCOM direct might sort of do that.

Looking at the behavior of MaxIm, unless I am connected to the
telescope, Auto Scope Dec and Auto Pier flip are grayed out + Pier
Flip is active

Bob has SUP.AutoGuide(true) to turn on his own autoguiding algorithm.
I suppose I could use that.  Ugg.  That means I need to determine if I
am in his stuff or not.  Alternately, I can connect and disconnect
MaxIm to the telescope when I get out of my stuff.

No, I could potentially keep disconnected from the scope in MaxIm and
copy all that in myself.....

So what is the best way to get run_level_default_ND_params?  That
happens in populate_obj, when we would have otherwise thown an error.

Tue Jan 23 11:22:08 2018 EST  jpmorgen@snipe

So I think the astrometry files should be done in a similar way.  Got
those in with host specific paths

I think I want to have a separate astrometry routine that gives me
what I want.

--> AlignmentModes will be in that tweak
CanPulseGuide?
SideOfPier

<Sigh> I am not sure if pierEast pierWest is going to give me what I
need.  But looking at the PinPoint solutions, I see the CDELT* are
_both_ of opposite sign on pier flip.  Ah.  The trick is that the RA
axis goes in the opposite direction!

 a = np.array([[1, 2], [3, 4]])
 a[:,::-1]
array([[2, 1],
       [4, 3]])

Hey, I can use Ellipsis, or ... to skip to the last index, which helps
ensure program works if just one tuple is given

 a = np.array([[1, 2], [3, 4]])
 a[...,::-1]

Wed Jan 24 07:57:05 2018 EST  jpmorgen@snipe

OK, so I may want to rename guider_move in MaxImData

Looking at ASCOM standard to see if there is a matching name, no, I
did it with guider_move, since that matched MaxIm!

http://www.ascom-standards.org/Help/Developer/html/P_ASCOM_DriverAccess_Telescope_GuideRateDeclination.htm

PIERSIDE =EAST/WEST in hdr
SideOfPier =pierEast pierWest in ASCOM

So guider_move takes a ddec_dra pair

--> remember to set DEC in MaxIm guiding property

OK, I have center working with pixels.  But what if I can get it in
world coordinates?  That would require a special ObsData that used
PinPoint.

Hey, I could probably squeeze that in by reading the HDUList[0].header
in the ObsData.

I can standardize on having the ObsData provide pixels for obj_center
and desired_center and do the transformations on the fly as needed.

Hmm  What if I want to pass an astrometry to center?  It can be
authoritative or approximate

Ack.  I was zealous in saving memory and deleted HDUList_im_or_fname
from ObsData.  I still want the header around, if possible.

I guess that means I want to have self.header around

OK, took care of that, hopefully without inducing bugs

Now I need to think about flow.  I have scope_wcs, which returns an
HDUList (should just be a header) that

test del withhout copy in ObsData

https://stackoverflow.com/questions/22069727/python-garbage-collector-behavior-on-compound-objects

suggests I don't need to do the copy, since individual objects have
individual reference counts even if they are within a compound object

--> consider using a sequence of plate solves to get the filter
    offsets

scope_fname_HDUList_or_header

Fri Jan 26 06:55:15 2018 EST  jpmorgen@snipe

Working on ioio.py

--> enumeration of Telescope. AlignmentMode Property

--> not getting astrometry of guider right

reversing RA helped, but rates are way too high

push north button, Jupiter moves down
on east of pier, push west, Jupiter moves right

upper left resulted in dra_ddec

[ 0.15581682  0.08760853]

lower right

[-0.1570902  -0.07768477]

and that after the RA axis flip (still on ease side of pier)

KIt is almost like we are off by a factor of 2

Jupiter (star) in upper left moving -20, +34

Hmm.  Factor of 2 on guider rate did it!  Oops, that was to absolute
center of image

Oops, was using standard center!  Wow!  That worked!

ioio.py center --ObsClassName CorObsData

Works too!

Pier flip.  Jupiter is near meridian, but I should be able to track
past the meridian for a bit + I can go to Vega if worse comes to worse

Hmm.  Now it is totally not working try center again.

Moved it farther away.  But sky is super bright

Whew.  What a pain.  Lets see if we can break it down into some constituents

Fri Jan 26 11:51:56 2018 EST  jpmorgen@snipe

Ah HA!  I think I found the factor of 2!  It is the binning!

Fri Jan 26 13:24:57 2018 EST  jpmorgen@snipe

Working on understanding rates

Scope actual rates
0.004178075
0.004178075
Rates calculated from guider
0.00536077057072
0.00401567330861

Actually not too bad!

Fri Jan 26 15:28:20 2018 EST  jpmorgen@snipe

Whew!  Finally got the thing to work on the east side of the pier

Sat Jan 27 05:21:04 2018 EST  jpmorgen@snipe

Works on west side of pier!

I still have the residual E/W flip I am not sure is correct.  Delta RA
is relative to what positive RA is, which is negative X in the sense
that east is left when you look at the sky and east is positive RA.
Noted that in the code.

Now that centering is working, the next step is to work on guiding,
since I think I am going to need to turn that on and off myself

CCDCamera.GuiderCalState == 2 may be a nice thing to assert to make
sure the guider is calibrated, though I am not sure if that is on a
per launch basis

--> desired center is not right when Jupiter is off the ND filter.
    See R-band_off_ND_filter

C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts>ioio.py center --ObsClassName CorObsData
INFO: Setting default_ND_params from run_level_default_ND_params[[  3.63686271e-01   3.68675375e-01]
 [  1.28303305e+03   1.39479846e+03]] [__main__]
INFO: pixel coordinates (X, Y) of obj_center and desired_center: (array([ 1355.45544679,  1130.19268443]), array([ 1330.70602846,  1100.        ])) [__main__]
WARNING: FITSFixedWarning: RADECSYS= 'FK5 ' / Equatorial coordinate system
the RADECSYS keyword is deprecated, use RADESYSa. [astropy.wcs.wcs]
INFO: Seconds to move guider in RA and DEC: [-1.252552   -1.58959738] [__main__]
INFO: Setting default_ND_params from run_level_default_ND_params[[  3.63686271e-01   3.68675375e-01]
 [  1.28303305e+03   1.39479846e+03]] [__main__]
INFO: pixel coordinates (X, Y) of obj_center and desired_center: (array([ 1356.57265208,  1129.56084018]), array([ 1331.59988387,  1100.        ])) [__main__]
INFO: Seconds to move guider in RA and DEC: [-1.26475488 -1.55706983] [__main__]
INFO: Setting default_ND_params from run_level_default_ND_params[[  3.63686271e-01   3.68675375e-01]
 [  1.28303305e+03   1.39479846e+03]] [__main__]
INFO: pixel coordinates (X, Y) of obj_center and desired_center: (array([ 1363.30603524,  1089.87094489]), array([ 1332.07164868,  1100.        ])) [__main__]
INFO: Seconds to move guider in RA and DEC: [-1.62873262  0.49398182] [__main__]
INFO: Setting default_ND_params from run_level_default_ND_params[[  3.63686271e-01   3.68675375e-01]
 [  1.28303305e+03   1.39479846e+03]] [__main__]
ERROR: Failed to center target to 10 pixels after 3 tries [__main__]

Center is clearly over at X = 1500 or so

--> would be good to have a brightest star algorithm

--> Ah Ha!  I think the cooler was off, which messed with my absolute
    algorithm for Jupiter not in ND filter


Sun Jan 28 06:21:50 2018 EST  jpmorgen@snipe

Consider making my own module for ASCOM name space

Sun Jan 28 06:45:30 2018 EST  jpmorgen@snipe

--> So I am having two problems.  The pier flip logic is not working
and CorObsData is not finding the center of Jupiter reliably

Centered nicely on Procyon while on east side of pier (looking west).
Ah, I think the problem is AstroPhysics might define east and west
differently, which continues to confuse me.  But getting run-away

So confusing thing is that PinPoint solution clearly shows flip in
both X and Y axes when doing CDELT and friends.  That reflects that
the telecsope tube is physically rotated through 180 degrees on pier
flip.  But what happens to the axes?

--! Ah, when through the pole, the sense of the DEC axis gets flipped,
    so it happens to match the flipped sense of the DEC direction on
    the CCD.  But RA doesn't.

OK, so where to implement this?

<sigh> The way I implemented this with absolute coordinates, I think I
need to do the flip in both places, since +DEC is in the wrong
direction


--> Now wait a minute.  In scope_wcs, I do the pier flip to get the
scaling astrometry correct, but I don't do it to get the pier side of
the actual observation correct

So I lined things up when pierEast was in effect, which is presumably
why that worked correctly on that side

--> I think I need to get the flip into guider_move

--> CCDCamera.GuiderMove might have flipped X axis for me!
--> Check autoflip if scope connected

Sun Jan 28 12:11:21 2018 EST  jpmorgen@snipe

Reading Autoguider Calibration section of MaxIm manual.  It says
calibraitons are in +/- X and +/-Y, implying that X, Y buttons are
real mount directions
GuiderAutoPierFlip when scope connected
GuiderReverseX when scope not connected

There is no property for the Pier Flip check box, though it may be
reflected in GuiderReverseX.  Documentation implies that
GuiderReverseX could re-reverse a Pier Flipped state.

From the looks of it, MaxIm is set up to just fiddle with the buttons
until it works, not have a systematic replacement of a GoTo mount interface.



  And even more confusingly, MaxIm can flip X
            # for a GEM if the appropriate check box(es) are checked.
            # And the worst yet, MaxIm does not tell us what kind of
            # mount it is connected to, since it can guide just by
            # having the camera connected to the guide buttons on the
            # mount paddle

? Guider motor control box options on Guider Settings Advanced tab
aren't anywhere in property.

--> This means that I am going to have to separately keep track of the
    guider orientation and pier flip options

So GuiderAutoPierFlip is a method that is going to deal with this.  It
will return a tuple indicating if thigns are flipped.

Ack!  My astrometry is not going to know about PIERSIDE unless it was
taken from a GoTo scope.  This is starting to be pretty impossible to
accomodate a nonGoTo scope

--> Bob says something about calibrating guider when mount is on east side

Ah, but I can use the astrometry? .... No, I don't know what state the
mount was in when it was calibrated.  Based on the pier collision last
year, it is clear that MaxIm keeps track of that, at least for "Point
telescope here"

Ah, I can tell what side the calibration was done on because I have an
absolute guider calibration and the angle

So guider calibration is done +X, -X, +Y, -Y

Right now, the calibration is (+3.407, -3.384) at -178.4 deg

I know the
CD1_1   =   1.16034386481E-003
CD2_2   =   1.18245542821E-003
PIERSIDE= 'WEST    '

I guess what I want is a method that takes the guide_astormetry and
CCDCamera.Guider* info and returns ra rates and pier side on which

I might want to make my guider dictionary a separate object.  [No,
just make it part of the object, filled after connect]

Mon Jan 29 07:09:05 2018 EST  jpmorgen@snipe

--> Check to see the various states of the
self.Application.TelescopeConnected whether or not guider is on

Do some work to see why the R-band Jupiter off ND filter didn't work

O = CorObsData('/data/io/IoIO/raw/2018-01-28/R-band_off_ND_filter.fit', plot_dprof=True, plot_ND_edges=True)

suspect it is because there is too much flux on ND filter

Mon Jan 29 09:29:12 2018 EST  jpmorgen@snipe

Got errors out, but Y reversed

CRVAL2 is wrong [fixed]

Sensing a circular argument with guider_cal_pier_side [nope]

number of significant pixels 9457074.77866 = 9E6

Well, after all that, Jupiter is going in the wrong direction

So my flip state is depending on the guider astrometry file, which it
should not

Guider west:
Guider X is +
dp = 120,135
sides = 0, 0
flip state 1 1

Guider east
dp = -117, -138
sides = 0 1
flip state = -1 1

Fixed problem with west because was doing product, when both change
(always results in 1) and checking for pier_flip as boolean, not == 1

But now I am still going in the wrong direction

--> Check that guider cal changes numbers with changed sides.  Was
    calibrated on side 1 = west.  I am on east now.  Numbers are 
    search back on "Right now, the calibration is"

West side, the calibration was (+3.407, -3.384) at -178.4 deg [looking east]
East side, the calibration is  (+3.405, -3.205) at 0.825 deg [looking west]

plus x went to the right, plus Y went up

So indeed, the calibration depends on the pier side
Calculated RA rate is now the second of these
(0.004178075, 0.0050202733987532609).

Am I forgetting cos DEC?  Yes.  That makes the calculated RA rate
closer.

Now that I am calibrated on the east and doing astrometry on the east,
my pier flip state is 1 1, suggesting that this should work!  Indeed,
got there on the first try!  Then proceeded to get lost since I am not
doing CorObsData, but the directions are correct.

Review: calibrate with scope on west, (looking east), got pier flip
state wrong on west side of meridian (scope on east looking west)
ASSUMING that MaxIm keeps track of what side it was calibrated on.

Hmm.  There is another thing going on here.  The rates are the same
sign but the angle is different.  Well, I think that means MaxIm did
the conversion into pixel coordinates from motion, like I expected it did.

Hmm.  Maybe it is wrong to not take the angle into consideration when
doing the pier side?  No, I am getting the right answer there.

All signs are pointing to MaxIm calling east of pier, looking west,
"flipped"

OK, another thing I have to look at: what does MaxIm really mean by X
and Y?  Fundamentally there are RA and DEC motors.  X and Y are what
line up along those 

Ack!  I am still getting it wrong!

What if I simplified it

Tue Jan 30 10:06:37 2018 EST  jpmorgen@snipe

Well, got it to work (some juxtaposition with IoIo.notebk)

Wed Jan 31 06:47:42 2018 EST  jpmorgen@snipe

--> error on unbinned array.  Saved to Problem-R-band

  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 442, in populate_obj
    self.ND_params
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 764, in ND_params
    this_ND_center-subim_hw:this_ND_center+subim_hw]
IndexError: index 350 is out of bounds for axis 0 with size 32

Hmm.  Did not repeat.  Worrisome.

subim_hw should be consistent and indeed that is not the axis that is
casuing problems.  It is y_bin.  Ah Ha.  That sounds like a begin-end
problem.  Checked for slicing bug and that doesn't seem right

y_top = 32
y_bot = 132
y_bin = 10
yrange=np.arange(y_top, y_bot, y_bin)
print(yrange[-1])
if yrange[-1] + y_bin > y_bot:
    yrange = yrange[0:-1]

print(yrange[-1])
print('Sequence')
for ypt_top in yrange:
    for rowpt in np.arange(y_bin):
        print(ypt_top+rowpt)

<sigh> not finding a hole in my logic.

Hey, what I want is

np.linspace(y_top, y_bot, 8, endpoint=False, retstep=True)
(array([  32. ,   44.5,   57. ,   69.5,   82. ,   94.5,  107. ,  119.5]), 12.5)

No, it is a pain to deal with the integer

--> Probably because I touched the guider image or something

--> I might want to have a general "take exposure and then wait"
    routine, since I am having to do that a bit

Thu Feb 01 13:41:22 2018 EST  jpmorgen@snipe

I have a take_im for the main camera.  That does CCDCamera.Expose()
--> consider making it also do guider optionally

now I want to do a center with guider.  But at the MaxIm level, this
is move_with_guide_box

Thinking about expanding scope_wcs to include delta pixels and/or RE/DEC

--> how is move_with_guide_box going to be called?  Do I need to
    calculate dra*cos(dec), or is that going to be in it already?
    Ultimately, I am going to have a dpix from the main imager

--> deal with guide star fading

Hey, I can completely reuse the PrecisionGuide center logic for
center_with_guider

Might consider putting it into center_loop too

ioio.py center --ObsClassName CorObsData
ioio.py guide
ioio.py center --ObsClassName CorObsData

guider.exptime is not defined unless we start the guider

Might want to have an occational message that I am moving with the
guide box

Moved guide box to 296, 244.8 and counting, but main image hasn't
moved a bit

--> read time for guider

Might have been offset file causing the problem

--> Autoguider image on top & gave array error.  Think of way to make
    sure correct docuiment is selected

Am I going to have to stop the guider to change the coordinate?
Indeed.  <sigh>  So this is not going to work as advertised, or I
am doing it wrong

Advertised move while tracking, but it is not doing that

NO!  The problem was I was using GuiderSetStarPosition instead of
GuiderMoveStar

No, I *was* using GuiderMoveStar.

OK, so there are a couple of things here that look like show
stoppers. (1) GuiderMoveStar doesn't and (2) the Documents system is
messed up

(2) --> Might be able to take care of with DOcument next and checking
for document name of Autoguider Image


Work more with GuiderMoveStar

OK, simple case worked

Oops, induced a pier flip with telecsope move

--> Should I apply pier flip logic to move with

FLip and see if problem goes away

Definitely going up when should go down.  Might even be 90 

--> my start guider doesn't seem to be getting the right star.
    Because I need to set CCDCamera.GuiderAutoSelectStar.  It doesn't
    read it from a dialog box

Direction is totally messed up!  Depends on where I am on CCD?

Guider stuff might matter some, but still, the pixel calculation seems
totally off

In the lower right, seems to go totally wrong direction with +

Try my tracking again.  398, 292 is what it came up with even after I
set it to something else.  But it was sort of close.


lower right got  +44, +45, which was in the right direction
lower left gets +47 -51 flip signs (or transpose)
upper left  -13, -41 transpose

Correct transpose (I think)
upper left 47, 33 (wrong way)
upper right -41.93768271  21.16033724

Where the upper right is definitely closer to the X axis.
So I think that means I have a minus sign

upper right very low 56 -8

Next up is getting the guiding to be a little more gentle in an
intelligent way.  But that is not absolutely necessary right now

Sat Feb 03 10:16:48 2018 EST  jpmorgen@snipe

--> consider doing guider_settle and only triggering that when
    commanded move is more than a threshold of arcsec

Consider an all arcsec interface
--> Would need to make a delta option in scope_wcs

Sun Feb 04 08:46:44 2018 EST  jpmorgen@snipe

For some reason scope is going the wrong way.  Oh, it is day.

Sun Feb 04 17:32:02 2018 EST  jpmorgen@snipe

Need to work with Document object more in MaxIm

I really need to work with the Documents collection, not CurrentDocument

Mon Feb 05 03:39:07 2018 EST  jpmorgen@snipe

Worked!

So now I need to give myself a series of exposures.  My original plan
was to use events for this at the MaxIm level.


Looks like I need to start with CCDCamera.EventMask.  Notify event is
what I look at, I guess

Ah, the events is how I could have done the guider stuff

--> have to set EventMask first

ceExposureCompleted

is what I want

So how do I handle events in Python?


Threading might be a way to talk between my 
https://docs.python.org/3/library/threading.html

But MaxIm says I can use events just to avoid polling, which sounds
like am optimization I can skip for now

--> RMS coming back to fast on first guide
Ah, might be before first exposure, so no error

Mon Feb 05 14:10:19 2018 EST  jpmorgen@snipe

Notify event is confusing.  Trying to figure it out.  I get that I
have to set the Mask Bit value

ioio.py MaxImCollector

Hmm.  Events are a little tougher

https://stackoverflow.com/questions/33208969/how-to-pass-arguments-to-win32com-event-handler

But try simple case to see if it works

https://vlasenkov.blogspot.ru/2017/03/python-win32com-multithreading.html

Hmm.
http://docs.activestate.com/activepython/3.4/pywin32/html/com/win32com/HTML/QuickStartClientCom.html

This is getting quite complicated.

All this to avoid generating some filename.

So I can try this out with acquire_image and just feeding it images

GuideBoxAdjuster is what I need to work on now.

--> I can run it with a bunch of files to see what I come up with

Note that arcsec/hour is a more common thing than guider pix per 10s.
I am at

0.020*4.42/10*3600
31.824

That is a sizable drift.

Tue Feb 06 05:02:43 2018 EST  jpmorgen@snipe

So we now have a list of times and dra_ddec.

--> was thinking about separately controlling position vs nearness to
    desired center, but stay simple for now.

Hey, wait!  The delta of dra_ddec is my literal motion that I was
thinking about separately controlling!  The instantanous dra_ddec gets
factored in there if I want

So do we want one guide box rate?  Ultimately, the guidebox will be
moved at a particular rate for a particular amount of time & then
that will change.  So we will need a history to match up with our
object movements.  But some of guidebox motion may be due to 

So we really have two things, the guide box motion due to differential
flexure and guide box motion due to non-siderial guiding with a star.
Right now, we are taking care of the former, which is just one
component of the total.

Current design has me writing this to a file & reading it with the
GuideBoxMover

I can use list.insert(0, element) to insert an element at the
beginning, if I want to do that

Or I can just do things in regular order and then reverse.  But the
point is that we derive a new rate just by subtracting the measurement
movement from the current movement

OK, decide to stay in regular order.  Also figured out why image of
Jupiter moves and not ND filter.  The field lens focuses the pupil of
the telescope onto the camera lens.  When it moves/tips (which is
equivalent to tiping the filter), the pupil moves, moving the apparent
image of everything in the focal plane.  The ND filter is not imaged
by the field lens onto the camera lens.  It is close enough to
basically be part of it.  So movement of the field lens does not
effect its apparent position in the focal plane.

The upshot of this is that I really do need to keep track of the
position of Jupiter for each filter.  I can build up a list of
observed filters and dt and dra_ddec for each filter.  What data
structure is best for that?

Ultimately I want the filters to be in a list.  If I keep the same
enumeration, I might be able to have a list of 

Ah, I can use the index() method of the list and so have a parallel
list of lists.

What I would like would be a way to have dictionary...  No, figured
out how to have a list comprehension grep it out for me

--> now is when I need delta=True in scope_coords.  No, I actually may
    not need w_coords in ObsData

--> self.ObsDataList needs to be cleared when I restart the guider

Hmm.  I have the logic down for stopping the motion of the object, but
what do I do with the center?  Previously, I moved it during an
exposure using a typical exposure length and the amount I wanted to
move it.  Now I am wondering if the right thing to do is a
move_with_guider.

--> Do the move_with_guider and keep track of those deltas in
    guide_box_flex_rates (or whatever I want to call it)

Wed Feb 07 05:10:09 2018 EST  jpmorgen@snipe

ioio.py from command line is now back to killing the camera when it
exits.  This makes sense in a way, since we

Somehow CCDCamera.LinkEnabled is being set to False when the object is killed.

--> Consider handling it with a __del__ method? or with atexit?

Or maybe I need to set it to False instead of violently exiting?

Neither seems to work

!! after disconnection and reconnecting FocusMax, seems to work OK
--> That seems to be repeatable, but double-check all failure modes

DATE-OBS is the start of the exposure

So we can do the midpoint again.

Hmm.  We have a phasing problem.

An observation was taken before we knew about it.  We can potentially
initialize our rates on first entry to 0.  The point is that we start
an obs_center_rate a the beginning of an exposure (technically when we
get our first response from GuideBoxMover).  The measurement of the
center is done at the midpoint of the exposure.  At the end of the
exposure, we calculate the rate for the next image.

Lets think about the GuideBoxCommander for a minute.  Right now it
does the subprocess opening.  That might be something I'd rather do in
the __init__ method, with __del__ doing the p.terminate (though I am
not sure if this is necesesary)

I could have the units be in the same as HORIZONS    Units: ARCSECONDS PER HOUR

So basically, I am ready to put the guide box rates into the
PrecisionGuide object

The more I think about it, the more I want to put every thing I need
for PrecisionGuide into the ObsData

Wed Feb 07 14:44:44 2018 EST  jpmorgen@snipe

Making progress.  I have logic that will hopefully null out motion and
have the Jupiter images cluster around the desired_center.

--> Check if on-off subtraction works OK this way.  May need to keep
    track of filter positions relative to each other and move them
    into the center

--> consider making desired_center a little to the left of center

Thu Feb 08 05:43:48 2018 EST  jpmorgen@snipe

Wrote to the end of PrecisionGuide for now.  Now all I need to do is
test it.  Critical Juno time right now

On telescope tab, MaxIm reports "Pier flip" when scope is west of
pier looking east.  This is opposite of what I assumed and means
my initial east = -X was correct and my argument for what pier flip
means was incorrect

Changed sense of MaxImPierFlip and made -X = east + center still works
(which uses guider_move)

Next up is testing PrecisionGuide

I basically need something like this: <start to write data_collector>

Fri Feb 09 04:25:20 2018 EST  jpmorgen@snipe

--> Need to think more about when I get bad measurements for Jupiter,
    like it is too faint.  Considering quality flag

--> getting NaN.  Save as Jupiter_NAN_coords.fit so I can think about
    it.  Oops, that was because of wrong filter, but still....

Back to logic of data_collector.  Ultmately, I am looking for one
routine, I am currently calling it acquire_image, which checks to see
if the closed-loop system is running, does the initial centering,
turns on guider, takes and analyses the 

--> Need a section of PrecisionGuide namespace for initial

--> Might want a separate part of calc_flex_pix_rate for recentering
    and turning the system on

!!! Hey, since I am taking the data rather than passively swatching it
    go by, I can enforce a uniform filter for centering !!!

--> Add a filter selection logic and filter delay

Wondering if it might be wise to have a self.lastO in precision guide
so that I can effectively have a global return value from center_loop
et al. when I need it.  Either that or I have something in ObsData
that says that it was centered and to what tolerance!  No.

--> Really want quality check in center

Fri Feb 09 19:44:05 2018 EST  jpmorgen@snipe

Checking things still work on Sirius just at sunset

ioio.py center
ioio.py guide --filter 3
ioio.py center

Still works OK

ioio.py data_collector

Fri Feb 09 23:21:17 2018 EST  jpmorgen@snipe

Making progress

--> Need to deal with time delta stuff

Oops, was out of focus!

What is arcsec/hour compared to what I was doing

Guider plate scale is 4.42"/Pixel.  Was doing 0.020 in 10s

0.020/10*4.22*3600
30.383999999999997

Ah Ha.  The delta moves are causing lots of problems

getting a main dpix of .333 and a guider of 0.12
.333/.12
2.7750000000000004

4.42/(1.59/2)
5.559748427672956

--> If I take away that factor of 2 binning that I know is there, I get
the "right" answer

--> Also a severe guider rate error.  That might be from dt being too small

First main camera, with note about modifying

 CDELT1  =   0.0002165594294585 /
 CDELT1  =   0.0002165594294585 

Second one is the same.  Note I might want to change the pixel size
and NAXIS

DEBUG: coords before: [-1.5 -0.5] [__main__]
DEBUG: coords after: [ 1373.5  1099.5] [__main__]
DEBUG: w_coords before: [array(-152.3409460713296), array(-11.838782685738101)] [__main__]
DEBUG: w_coords after: [-0.00011274  0.0001062 ] [__main__]
DEBUG: dra_ddec: [-0.00011274  0.0001062 ] [__main__]


2018-02-10T07:52:42.661(UTC) [87.9055875228736, -195.2200697858324]

np.asarray((87, 195))/(3600*4.22)*10
array([ 0.05726698,  0.12835703])

Hmm.  That is zooming.  I expect something like 30

DEBUG: plate scale: [ 1.62339896  0.50977459] [__main__]
DEBUG: plate scale: [ 0.6785298   0.86515492] [__main__]
DEBUG: plate scale: [        inf  0.24989594] [__main__]
DEBUG: plate scale: [ 0.92216446  0.65228332] [__main__]
DEBUG: plate scale: [        inf -0.41227988] [__main__]
DEBUG: plate scale: [ 0.36747519  0.70156471] [__main__]
DEBUG: plate scale: [-2.38919199 -0.01123073] [__main__]

<sigh> fundamentally, the delta algorithm is not working the way I expect.

How does it work properly?  In populate_obj, I do it the same way,
though I let the wcs stuff do its magic....

Hey, I wonder if I am fighting MaxIm's guidebox mover!

2018-02-10T09:35:04.747(UTC)---- GuideBoxMover Started ----- 
2018-02-10T09:35:04.729(UTC) [0.0, 0.0]
2018-02-10T09:35:43.929(UTC) [-31.935516179681695, -42.476564923871855]
2018-02-10T09:36:22.757(UTC) [233.87095668683753, 20.21097317363958]
2018-02-10T09:36:59.392(UTC) [-135.63725364278997, 86.19725434812861]
2018-02-10T09:37:38.147(UTC) [-73.0761363093667, -42.426954765861794]

I am also unstable

--> Plate scale in RA is consistently high, as if I am missing a
    cos(dec) or something

DEBUG: plate scale: [ 0.84173601  0.77053104] [__main__]

See IoIO.notebk.  Consider some measurement error estimates to help
the process along.  Maybe just let it slide, measuring the rate and
nulling that + only making a correction when we are beyond a certain
threshold from the center or after the dispersion on our current
location is low enough to be confident that our rates are good enough
to reset their measurment after a one-time move

Sat Feb 10 16:13:45 2018 EST  jpmorgen@snipe

Thinking more about errors and using them to trigger a correction.
What I see when I do this myself is Jupiter moving a noticeable amount
and then I apply a one-time correction to the rate, recenter and start
over.

Sources of error:

. Ability to determine the center of the object.  Without a
sophisticated algorithm, I can just estimate that at 1 pixel for now

. Seeing.  If I have a short exposure compared to seeing motion time,
I can be off by that amount.  Seeing is the spread in a long-term
exposure assuming good guiding.  Seeing can also be related to the
dispersion in the guider, assuming good tracking, though if the guider
exposure is long, that will average out.

. Guide box not in right place.  The is realted to the average error.
I currently calculate RMS and have that be less than a critical value
in order to minimize the average error

Seeing and the center error add in quadrature, at least for exposures
short compared to seeing motion.  Seeing variation can be up to 100
Hz, but consider 1s as a reasonable limit

--> I should separate things out so that run calc_pix_rate does just
    that + doesn't run the GuideBoxCommander so that I can potentially
    take its intermediate output on a list of files.

Sat Feb 10 20:26:15 2018 EST  jpmorgen@snipe

Need to come up with a formula that gets seeing error.  For large
exposure time seeing error -> 0.  For times < 1s (or whatever I decide
is the threshold, seeing starts to be important

2/(1 + exptime)

Can express seeing exposure time in terms of a frequency.  See code

I also want to have some sort of weight based on the length of time
between exposures, but maybe that will come out when I look at the
whole graph.

No, I want something for time ago so that really old data don't mess
things up.  But I am not able to come up with that just yet.  Keep it
simple for now and include all data

OK, I got myself a rate from the polyfit.  Now how do I use it!  If I
apply it right away, I do a rate change.  So I need to see if
this_rate is significantly different than the previous one.
Ultimately it is about motion.  I am building up a set of average
exposure times, so I can talk about motion in one exposure.  I also
have my desired_center_tolerance.  I also have the total amount of
time I have been observing.

I think time since last rate change might be best self.current_flex_pix_TStart

ioio.py data_collector --ObsClassName CorObsData

Seems to be working smoothly doing nothing when Sirius is just past
meridian.  Make it busy!

10 -0.100 +0.200

Seems to be working at moving the total pixels at new rate numbers
relative to previous!

Well, I have a measurable shift, but didn't start the rate change soon
enough.  self.center_tolerance would be a good metric!

--> I have too many center tolerances.  Sort these out

So there is the deadband I have tolerance for when I am centering by
guider slews or guider moves

--> I might need to check for small duration moves?

INFO: Seconds to move guider in RA and DEC: [ 0.0005036   0.28759885] [__main__]
Traceback (most recent call last):
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 3369, in <module>
    args.func(args)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 3229, in data_collector
    filt=args.filt)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 2982, in acquire_image
    self.center_loop()
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 2525, in center_loop
    self.center(O)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 2493, in center
    self.MD.guider_move(dw_coords)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\ioio.py", line 1914, in guider_move
    RA_success = self.CCDCamera.GuiderMove(ASCOM.gdMinusX, dt[0])
  File "<COMObject MaxIm.CCDCamera>", line 2, in GuiderMove
pywintypes.com_error: (-2147352567, 'Exception occurred.', (65535, 'MaxIm DL 6', 'Invalid duration', None, 0, 0), None)

Was going up and to the right

--> need a try around polyfit since it failed occasionally

There is a weird loop going on that I don't understand with the guider
<sigh> another logic error: need to keep long guide box slew logic in
center, not in move_with_guide_box


Sun Feb 11 05:25:43 2018 EST  jpmorgen@snipe

--> Might think about another figure of merit for slope determination

Sun Feb 11 12:42:21 2018 EST  jpmorgen@snipe

Taking a minute to look at my logic.  acquire_image now acquires the
image, no matter what, but warns if not guiding or precision guiding.
Hmm.  It also shoves the image thorugh the system no matter what,
which I may want to avoid voluntarily

--> restructure logic

make delta pix threshold from actual motion, 3*error

As written calc_flex_pix_rate is more like "adjust rate and center."
But I am still determining if I wnat to try to use the guider rate to
move the image back to the center

Focused on Vega

Multiple instances of GuideBoxMover got started because it takes a
while for that to happen

play with log file on /cygdrive/c/Users/PLANETARY SCIENCE/.astropy/config/astropy.cfg

--> think about reading command file on first entry to calc_... to get
    the rate from the previous run 

05:47:53   Position = 38785  Mean HFD =  4.57
05:47:53   Temperature = 11.44

Initial try left Sirius wandering off. Try -1.8 aggressiveness on off
chance sign flip is the problem

Seems to be much happier!

After restart, which used the old rate, motion semed to be less, but
since it is based on motion, not position, and it keeps zeroing the
list, it still wanders off.  What is the best way to proceed?

If I add in motion based on delta from center, that motion would be
canceled out by my motion logic

--> Not sure if GuideBoxMover should be checking for guider settling,
    since that delays it + makes it unstable

So the main question I have about guiding by error from the center is:
what do I use for a rate?  MaxIm moves the telescope, so it doesn't
matter how long it takes to get there.  I could use the maximum
exposure again, but that might be too slow.

Maybe I could have some logic that would test which direction I am
going.  If toward the center, then I don't mess with that rate

Alternately, we can look at where it is now and where we want it to be
+ the amount of time we have been going and use that to establish a rate

How 'bout we consider a simple error based on our measurement that
goes at a rate that is weighted

dpix from desired_center/dt(longest exp)

That is not working.  Though the rate is increasing, it is just going
to lsow it down, not reverse it.

So I need both a component to measure the rate, which I have + a
component to do the recentering, which I don't.  If I kept track of
the recenting rate separately, I could take it out of the motion rate
when measuring the motion rate.  This is realted to what I was doing
before but possibly not as floppy

Before I do that, try a very short longest exposure (10s)

That is working a little better, actually a lot bettter!  But still
error based, with the target up and to the right.  I'll take it,
though, since the motion is so exaggerated

But I think I am confused as to sign.  What worked for sign here is
having dra_ddec_rate in GuideBoxCommander come straight from pix_rate,
no minus sign for what I though I needed to do for star motion on
guide camera.  But I was also sending it -dpix/10, where dpix was
obj_center - desired_center.  That is the actual motion I want it to
do.  That is right because I take out the guide box opposite motion in
move_with_guide_box.

So this means I have a sign flip in my motion code.  Hmm.  Not seeing
it.  slopes are dpix/dt.  Ah, but dpix in this sense is the
progression of obj_centers, not necessarily relative to
desired_center.  But still, it is the motion we want to null

Motion converged to 
2018-02-12T07:49:08.519(UTC) [2807.0785188547225, -1129.790736587323]

Best I got to with old code was:

2018-02-12T06:15:32.428(UTC) [225.10602712837584, -1027.4851575469136]

But it was unstable and had the minus sign

10 -0.100 +0.200
--> putting back to Jupiter setting
np.asarray((-0.100, +0.200))*(3600*4.22)/10
array([-151.92,  303.84])

Not even close to a real measurement and may suggest I have a
transpose somewhere.  dpix = O.obj_center - O.desired_center should
all be in proper transpose space

Well, the error method works on a single filter, but I am still not
sure about what to use for the denominator.  I guess the average time
between exposures might work.

Ah.  The center error method converges to something that is based on
its error from the center.  If it stuck in a different place it might
be a different value?

np.asarray([-1129.790736587323, 2807.0785188547225]) / (np.asarray((-0.100, +0.200))*(3600*4.22)/10)
array([ 7.43674787,  9.23867338])

So that assumes there is a transpose somewhere + I get close to the
factor of 10 I was using?...

Well, go back to the rate, since ultimately that gave something closer
to the right absolute number, though Jupiter didn't stick quite the
way I wanted it to.

So I have a way of measuring the rate that is reasonable.  I can also
add a component of center correction that I can take out when I
calculate the rate, or something like that.

I wonder if I could use the 

... ! Hey, I think I neglected to put in the previous rate when
calculating the new rate on my flex_rate calculations.  So a
combination of my logic might work

Mon Feb 12 08:24:01 2018 EST  jpmorgen@snipe

Consider having a routine that checks if new rates are significant

Mon Feb 12 17:23:57 2018 EST  jpmorgen@snipe

Working on weights for fitting.  The obvious is 1/obj_center_errs, but
I also wanted to include time and number of rate change transitions.
Rate change transitions 

Rate changes are easy because they can be integer multiples.  Time
could be expressed in exposure number the same way, or by a
realtionship to the average deltaT

Tue Feb 13 04:43:38 2018 EST  jpmorgen@snipe

When we (re)center on a target, we are doing some slews that make the
center come to a different place, which would mess up the sequence of
obs_data.  So we should delete that.  There should be a single routine
that handles this

does **kwargs complain when there are extra args?  Yes.  But I can
solve my underlying problem by preparing a MaxImData separately

So when I am looking at an object, I want to keep adding to
ObjDataList.  When I go to a new object or reset the telescope, the
ObsDataList will likely become obselete, since it deals in the
absolute pixel location.  The current_flex_pix_rate and GuideBoxMover,
however, need not necessarily change if I am in the same general
location on the sky.

So reinitialize could have an option to keep the current_flex_pix_rate
but not the current_centering_rate.

So I could have an option in center to turn off the recentering rate.
Turning off the centering rate should be a separate thing, like maybe
with a property method.

Maybe what I need is a property setter/getter system for
flex_pix_rate.  I could potentially have a dictionary filled with
items

Wed Feb 14 10:34:31 2018 EST  jpmorgen@snipe

Actually, a dictionary of dictionaries might be good to pass to
GuideBoxMover so that I can pass parameters to the routines that are
doing the tweaking of the individual compoenents of the total
flex_pix_rate.  But if they tweak them with a time constant, that
information own't be recorded back to the flex_pix_ratein the main
routine unless I run those calculations in parallel.  Plus that
defeats the ObsDataList model I have been using, since the time
changes could be in the middle of an exposure.  But that is not the
end of the world, since ultimately, I am just looking for the total
amount the guide box moved in pixels.

--> Do it the simple way first + if it works, figure out the best way
    forward.  Might eventually go for an event loop or something like that.

Sat Feb 17 10:32:57 2018 EST  jpmorgen@snipe

Have some time to do a dry run on the rate adjustment using files.

Note that the update_flex_pix_rate seems to all be independent of 

on Puppy

ioio.py test_flex '//snipe/data/io/IoIO/raw/2018-02-12' --ObsClassName CorObsData

ioio.py test_flex r'\\SNIPE\data\io\IoIO\raw\2018-02-12' --ObsClassName CorObsData

ioio.py test_flex r"\\SNIPE\data\io\IoIO\raw\2018-02-12" --ObsClassName CorObsData

Mon Feb 19 09:36:40 2018 EST  jpmorgen@snipe

None of the above work!

Copy files to Desktop\data.  I am in Scripts.  No, I am at the top level

ioio.py test_flex 'data'  --ObsClassName CorObsData

ioio.py test_flex r'\Users\jpmorgen\Desktop\IoIO\data' --ObsClassName CorObsData

ioio.py test_flex '/Users/jpmorgen/Desktop/IoIO/data' --ObsClassName CorObsData

OK, this is apparently something with command line arguments or Puppy

Try on IoIO1U1

ioio.py test_flex '../data/2018-02-12' --ObsClassName CorObsData

Same problem.

Must be some sort of command line issue?

Back on puppy.  Put in raw_data_root and just use subdirectory

Ah!  Quotes!

ioio.py test_flex 2018-02-12 --ObsClassName CorObsData

Tue Feb 20 05:32:25 2018 EST  jpmorgen@snipe

OK, that is working, but now I am seeing that I have inconsistent
logic about whether or not to use the full ObsList or just
OThisFiltList

Tue Feb 20 19:44:32 2018 EST  jpmorgen@snipe

Something funny is going on with the effective_obj_centers.
Backward/forward?

Ack!  It is time.  Trying to get the bleeding edge time at which the
guidebox starts to move, I set the time to Time.now(), which is way
out of sync with the files I am reading!

So when do I want to have the effective rate change be for off-line
processing?  I guess the shutter time of the current file

Thu Feb 22 14:04:28 2018 EST  jpmorgen@snipe

ioio.py data_collector

Seems to be working, sort of.  The centering is the only thing that is
doing anything, though.  It is working

-3, 8 is latest DPIX.

Seems to be going back up again.  The guidebox mover rate is larger
than I can really move

I wonder if the problem is that the centering is fighting the motion 

Fri Feb 23 04:30:56 2018 EST  jpmorgen@snipe

Well, in the wild, my algorithm totally did not work.

I need to go back to the drawing board about how to handle centering
with multiple filters.

I guess I need to keep track of which filter is which in the centering
calculations as well and not make a move until I have multiple ones

Sat Feb 24 08:35:27 2018 EST  jpmorgen@snipe

When I changed the code the other day to take out the D.says I also
broke the motion calculations?  No, there is still a motion rate, but
I think it is induced from the centering rate

Sat Feb 24 21:18:37 2018 EST  jpmorgen@snipe

Changed IPT_Na_R to just center so that I can get decent data and some
sleep.

Sat Feb 24 22:02:11 2018 EST  jpmorgen@snipe

So it loks like I am getting a good measurement on the new rate, but I
am filtering out when I use it incorrectly.

Sun Feb 25 03:39:53 2018 EST  jpmorgen@snipe

What I really need is the error bar, which I think I get from the
diagonal elements of the covariance matrix:

di**2 = (covar(i,i))**0.5

ioio.py guide --filter 3
--> THIS CRASHED WHILE GUIDER WAS RUNNING

Oops, but guider didn't!

Tue Feb 27 07:28:56 2018 EST  jpmorgen@snipe

The thing that bugs me amount the deadband is that I can be far away
from center forever.  I would like to have some sort of elastic
deadband that gets more insistent with times the object has been away
from the center

--> limit how short a move can be in regular centering

Fri Mar 09 04:10:50 2018 EST  jpmorgen@snipe

!  Looks like something is reversed in ioio.py!

Ahh!  It is because the telescope was not connected and I had not
--> Print warning if telecsope not connected

--> No, I need to be able to do this without telescope connected.


This migth be a good night to debug this, since my logic looks like it
"should" work.  The real problem seems to have been that when I pushed
the buttons, the telescope moved in the opposite direction, suggesting
I never needed my pier flip logic in the first place.

Well, I didn't have the pier flip box checked, yet the scope was in
pier flip mode.  I told the guider to go + in RA and it went the wrong
direction.  When I asked it to go + while the scope was connected, it
went in the right direction (to the ri ght on the image).

--> Looks like I might simply have to insist that the user not check
    the Pier Flip box

So I will need to apply the scope flip for MaxIm to guide properly

--> had trouble starting guide when telescope not connected

Fri Mar 09 08:57:02 2018 EST  jpmorgen@snipe

So if the telescope is not connected, then I need to do my own pier
flip logic and somehow tell MaxIm to flip while guiding.

--> Questions for Bob

. MaxIm observatory telescope not connected lead to problems in my
software with guiding and pier flip when pierWest (east of meridian)

. Filter offsets with MaxIM only or do they need to be duplicated in ACP?

Fri Mar 16 07:54:36 2018 EDT  jpmorgen@snipe

--> set binning on guider to what I want it, otherwise remains stuck
    to previous value (e.g. from binned biases)

--> Hey, when the quality is too low, consider upping the eposure time
    automatically!  Cold also add eposure time argument to center command

Tue Mar 27 21:02:43 2018 EDT  jpmorgen@snipe

--> Think about quick and dirty telescospe rate implementation
right now, GuideBoxCommander isn't in use

Main camera pixels per second is what GuideBoxCommander wants.

Currently I use 0.020 guider pixels per 10 s

guider/main 
4.42/(1.59/2)
5.559748427672956

So I can call the method that does this something like diff_flex.
Ultimately, it is going to read a mapping file/model.

Also, I would like to have it continually monitoring.  but to do that
properly, I would need to have a separate background process


Nu Hya/HIP52943 (Star)

02:14:22   Position = 37889  Mean HFD =  3.83
02:14:22   Temperature = 10.06

--> could propagate guider filter and exptime to command line
 or work on auto filter

ioio.py data_collector --filt=1

is pix_rate in transpose or not?  It is transposed.  And since I have
a little camera angle, I can't get a perfect guide angle

--> Need to figure out what to do when I want to change the guidebox
    rate more rapidly than I move the guide box.

--! When the C-c event times out connection to MaxIm and scope, MaxIm
returns to the preset it was at when the connection was made.  This is
where I get the magic change I have been seeing

Thu Mar 29 06:33:43 2018 EDT  jpmorgen@snipe

--> Get updated rates for near meridian from IoIO.notebook this AM

Sat Mar 31 08:46:41 2018 EDT  jpmorgen@snipe

--> Need to add logic to pop guider off to do large moves.  -->
    Consider bringing center and center_loop inside of MaxImData

Mon Apr 02 02:25:25 2018 EDT  jpmorgen@snipe

--> Add logic to test for too may guidebox moves

Sat Apr 14 04:09:33 2018 EDT  jpmorgen@byted

--> Need to do T focussing in ioio.py

Mon Apr 23 00:53:02 2018 EDT  jpmorgen@snipe

--> East of pier is only one that works on main, west of pier is only
    one that works on guide!

guider_move: Standard pier flip sign (-1 for pierWest) on guider
astrometry in scope_wcs would work

center with guider slews: probably flipping twice, once in 
--> Conisder fixing PIERSIDE in astrometry headers to EAST

Mon Apr 23 08:29:18 2018 EDT  jpmorgen@snipe

--> Add horizon limits

Thu May 03 21:30:25 2018 EDT  jpmorgen@snipe

Time to do the horizon limits!

Fri May 04 20:17:25 2018 EDT  jpmorgen@snipe

That sort of worked, but new centering logic did not.

I have 4 levels here.  The initial IPT_Na_R, which calls center_loop,
which calls center for the first time, which calls guider_move, then
returns to IPT_Na_r, which starts the guider and recenters with
guidebox moves which are ultimately done in move_with_guide_box.  It
is only move_with_guide_box that knows that there are too many steps,
but it is only in center_loop that I take a picture to get the
recentering that I want.

Sat May 05 08:16:47 2018 EDT  jpmorgen@snipe

O = CorObsData('/data/io/IoIO/raw/2018-05-05/R_010.fits')
O.obj_center[::-1]
array([ 1306.33932366,  1108.02146345])

I get 1381, 1069

Fix this.  Think I need a better way to determine if it is off or on

Sun May 06 07:57:53 2018 EDT  jpmorgen@snipe

--> Consider putting some horizon limit code in the guider stuff
--> And a catch to keep from bombing

Mon May 07 02:04:41 2018 EDT  jpmorgen@snipe

DEBUG: Target centered to 5 pixels [__main__]
DEBUG: IN GuideBoxCommander [__main__]
Traceback (most recent call last):
  File "ioio.py", line 4106, in <module>
    args.func(args)
  File "ioio.py", line 3726, in GuideBoxMover
    rates_list = json.loads(com.read())
  File "C:\ProgramData\Anaconda3\lib\json\__init__.py", line 354, in loads
INFO: Guide box rate: 2018-05-07T06:02:04.383(UTC) [0.0, 0.0] [__main__]
    return _default_decoder.decode(s)
  File "C:\ProgramData\Anaconda3\lib\json\decoder.py", line 339, in decode
INFO: Collecting [SII] [__main__]
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "C:\ProgramData\Anaconda3\lib\json\decoder.py", line 357, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

Coming in at 6 clients, but guidebox mover definitly not running

Tue May 08 22:48:58 2018 EDT  jpmorgen@snipe

--> Probably need to do a center or something like that after I turn
    off guider when guide box moves don't work.

--> Really need to get logic for horizon limit in center loop

Wed May 09 18:59:47 2018 EDT  jpmorgen@snipe

Above horizon might be a better way to think of it

tracking and alt > horizon limit

not(tracking and alt > horizon limit)

not tracking or alt < horizon limit

Sat May 12 07:34:15 2018 EDT  jpmorgen@snipe

Add an exit script that turns off guiding and does anything else.  I
think the Application.ShutDownObservatory() does that

--> Consider having a check for the exposure time and brightness.  Or
    justr a time for nautical twighlight end 

Sun May 13 01:38:13 2018 EDT  jpmorgen@snipe

Flip

Focus at 3.74 stilll!

05:39:37   Position = 34884  Mean HFD =  3.22
05:39:37   Temperature = 17.69

Tmp comp back on

Sun May 13 06:03:26 2018 EDT  jpmorgen@snipe

Temp comp still active

Sun May 13 07:56:09 2018 EDT  jpmorgen@snipe

Shutdown script didn't work, but it was called

--> Maybe because reset wasn't pushed?  In that case I don't want to
    rely on it.  Indeed, when I pressed reset, it automatically
    started to shutdown


Temp comp still enabled

Something I did popped Temp comp off.  Possibly closing Focus Max 

Wed Jun 06 21:57:40 2018 EDT  jpmorgen@snipe

DEBUG: Setting to: [ 367.71538329  277.39762213] [__main__]
DEBUG: guider AV, RMS = (3.8042393480279619, 6.00234083938083) [__main__]
ERROR: Horizon limit reached [__main__]
ERROR: GuideBoxMover: Horizon limit reached [__main__]
DEBUG: Saved file: C:\Users\PLANETARY SCIENCE\Desktop\IoIO\data\2018-06-06\Na_off-band_011.fits [__main__]
DEBUG: Horizon limit reached [__main__]

--> Didn't shutdown

Mon Jun 11 10:11:17 2018 EDT  jpmorgen@snipe

Looking at tweaking read_im to work more generally.  Right now it is
all intertwined.  I could still run some of the tests I need in the
method read_im while having a general get_HDU routine at the top level.

Tue Jun 12 21:02:27 2018 EDT  jpmorgen@snipe

median filtering was happening in the wrong places for ND_params

--> not being consistent about whether or not HDUList[0].data is being
    used for work or if a scratch copy should be maintained

cd ~/py/IoIO
ioio.py ND_params_tree >& /data/io/IoIO/analysis/ND_params_tree.log &

Hmm.  That seems to be not in order

Total elapsed time: 52060.81957936287s
20294 obj files took 50086.02242708206s
Average time per file: 0.4051829036642928s
Total torus: 4003
Total Na: 1091

Same average per file even though I increased the copying and amount
of median filtering

Wed Jun 13 15:25:52 2018 EDT  jpmorgen@snipe

JPL horizons astropy!

http://astroquery.readthedocs.io/en/latest/jplhorizons/jplhorizons.html

from astroquery.jplhorizons import Horizons

https://github.com/astropy/astroquery

su
pip3 install astroquery

Wed Jun 13 21:34:14 2018 EDT  jpmorgen@snipe

http://photutils.readthedocs.io/en/stable/aperture.html

is another one I could use to do aperture photometry on Juptier to get
accurate scaling

Fri Jun 15 13:36:35 2018 EDT  jpmorgen@snipe

thinking with Daniel about how to break up ioio.py since with these
new analysis modules, things are going to get complicated.

Doing a test with define.py which suggests that when you do

from define import wait

the entire module is read in.  Reading
https://stackoverflow.com/questions/3162810/stop-evaluation-within-a-module
gives me the idea of breaking things up into more modules.

PrecisionGuide needs to have ObsData as an object.  When I use ObsData
in reduction code, it should be

from PrecisionGuide import ObsData

The problem with that is the win32 stuff.  But wait a minute.  Is
MaxImData the only thing that uses the win32?  YES!  But
PrecisionGuide uses MaxIm data, so we are back to square 1

Ah, but maybe I can use an exception.

Tue Jun 19 11:26:47 2018 EDT  jpmorgen@snipe

Indeed, exception works!

Rearranged some things so I can start to import things on snipe for
reduction and analysis that don't get in the way of PrecisionGuide on
IoIO1U1

I would like to think about what to do with raw_data_root, since I am
now using it in three places.

Revisiting the wisdom of having MaxImData separate.  It is really part
of PrecisionGuide, just like ObsData.  Someone could use it
separately, but that is just a from PrecisionGuide import MaxImData.
The point is PrecisionGuide could have a chooser which for now is just
hard-coded stuff.  Right now the names are in
PrecisionGuide.raw_data_root, etc.  If I do a real ASCOM chooser, that
will depend on win32com.client, I think.  But that is only for the
ASCOM stuff.  raw_data_root has two purposes.  Storage of astrometry,
which could be in the same Windows directory that chooser stuff is
stored.  And then the general stuff for data storage, which could
eventually be split out, which I essentially do.

So the question is, do I need an object to do all of this or are
properties OK.  Go with the property for now.  Objects can set
property


Tue Jun 19 18:47:01 2018 EDT  jpmorgen@snipe

Here is an idea for making a movie

http://zulko.github.io/blog/2014/11/29/data-animations-with-python-and-moviepy/

So that suggests I have make_frame (or whatever the "iterator") would
be somewhere that has access to all of the reduced images.  I make a
VideoClip object (e.g. animation) and then write it in whatever format
I want.

The flow would be for me to reduce things to FITS files first, since
that is likely to take a while.  Then the thing would be how to best
display and 

Matplotlib has animation, but blog claims moviepy is better

numpy arrays go directly to MoviePy.  See jpm_fns for scaling, which
is really good news!  I do it in the np array

So for doing the animation, I don't really need objects, I just need
some code segments.  For doing the collapsing, as well, I don't see
the need for an object right now.  Though I could potentially do the
reduction like a cache.  If it recognizes a file, it would read that
for collapse, movie making, or whatever

I would need to have some sort of /redo, which could be keyed to the
reduction level automatically!

So the real thing I am making is the iterator function that is going
to return the movie frame or collapsed thing (which might eventually
get written as a FITS extension or companion file).  But maybe I only
want part of that.  As in the make_frame would be something that
called the read/reduction code.

Hmm.  That is a nice idea, but I won't necessarily know the name of
the reduced file + there are decisions during reduction to limit bad
ones....

Thu Jun 21 13:47:32 2018 EDT  jpmorgen@snipe

I want to be able to flip the images properly, but maybe first make
the movie, since one frame of that gives me the proper orientation
compared to Nick's image

pip3 install moviepy

Fri Jun 22 10:47:52 2018 EDT  jpmorgen@snipe

OK, when PIERSIDE = 'WEST' things seem to match Nick's picture, but
that doens't make it right

Indeed, the astrometry suggests Y is flipped

--! Stopped CrashPlan from backing up /data/io/IoIO/reduced

Sun Jun 24 20:50:59 2018 EDT  jpmorgen@snipe

Need skikit

pip3 install -U scikit-image

Hmm.  Might regret that as things might break....

ReduceCorObs.py movie '/data/io/IoIO/reduced/2018-04-21'

That is not working.  I might need ffmpeg at the distro level

Mon Jun 25 08:20:34 2018 EDT  jpmorgen@snipe

ReduceCorObs.py movie '/data/io/IoIO/reduced/2018-04-21' --crop 500x250

Mon Jun 25 09:14:24 2018 EDT  jpmorgen@snipe

doing integral of filters so I can scale Jupiter properly.

Integral of curve gives equivalent width

Na = 11.22
[SII] = 9.95

ReduceCorObs.py reduce /data/io/IoIO/raw/2018-04-21

ReduceCorObs.py movie '/data/io/IoIO/reduced/2018-04-21' --crop 500x250 --speedup=24000 --frame_rate=40

Hmm.  I can't make the image too big because mp4 doesn't support that.

640 x 360 and 640 × 480 

And I don't want to do a general scaling because that would change the
size as the array angle changes.  Dimensions are 2750*2200

(2750**2+2200**2)**0.5
3521.7183305880667

(2750**2+2200**2)**0.5 / 640
5.502684891543854

c = np.asarray((1632, 1488))
e = np.asarray((3000, 1988))
np.linalg.norm(e - c)
1456.5108993756278

Call it 1500, so I can crop to 3000x3000

3000/640
4.6875
3000/480
6.25

Aim for easy calc of 6
(2750**2+2200**2)**0.5/6
586.9530550980111

480*6
2880

pip3 install --no-deps photutils

Really needed -U

pip3 install -U photutils

ReduceCorObs.py reduce /data/io/IoIO/raw/2018-04-21

Tue Jun 26 10:40:17 2018 EDT  jpmorgen@snipe

Working with astroquery

https://minorplanetcenter.net/iau/lists/ObsCodesF.html
Looks like 
V09 249.74202 0.849537 +0.526080 Moka Observatory, Benson
might be the closest 

name, Lon, Cos, Sin

Lon = 249.74202 east = 110.25798
Cos = 0.849537 = rho cos(lat)
Sin = +0.526080 = rho sin(lat)

rho = Sin/sin(lat)
Cos = Sin/sin(lat) * cos(lat)
Cos/Sin = cos(lat)/sin(lat)

cos(lat) = Cos/Sin*sin(lat)
Cos = rho * Cos/Sin*sin(lat)

... Well, this code is not going to change, so it is OK to use it.

I have longitude = 110.257500 west, they have 110.25798

110.25798 - 110.257500
0.00048000000001025

1 min = 1 nautical mile = 6076.12 ft
1 second of lat = 6076.12/60 = 101.26866666666666

0.00048000000001025*60 * 6076.12
174.9922560037368

That is accurate enough for me!

Tue Jun 26 11:44:02 2018 EDT  jpmorgen@snipe

Ack!  They don't collect everything!  They jhust collect things that
are relevant for the position of the object in the solar system, not
things intrinsic to the body itself

Well, looking at the __init__.py in the package and seeing in the Conf
object, which inherits from the astropy config class, the
eph_qualities and eph_columns are defined.  Presumably I could just
edit those

Wed Jun 27 14:58:49 2018 EDT  jpmorgen@snipe

--> for the reactive correction algorithm in PrecisionGuide, make an
    emulator so I don't have to take data!

ReduceCorObs.py reduce /data/io/IoIO/raw/2018-04-21/Na_on-band_011.fits /data/io/IoIO/raw/2018-04-21/Na_off-band_011.fits --overwrite

Was thinking about going parallel at the individual file reduction
level, but Python is so slow to load that would have too much overhead

ReduceCorObs.py reduce --directory /data/io/IoIO/raw/2018-04-21

ReduceCorObs.py movie '/data/io/IoIO/reduced/2018-04-21' --crop 800x800

Wed Jun 27 23:03:42 2018 EDT  jpmorgen@snipe

Need to get components of imagemagick to get fonts to work.

apt install libmagick++-dev

Still having a heck of a time with movie caption.  Turned out to be
parentheses!  (problem with being tired)

Thu Jun 28 10:09:18 2018 EDT  jpmorgen@snipe

Now I need to run this on everything.  See if parallel processing
gains me anything

ReduceCorObs.py reduce --directory /data/io/IoIO/raw/2018-04-21
ReduceCorObs.py reduce --directory /data/io/IoIO/raw/2018-04-23
ReduceCorObs.py reduce --directory /data/io/IoIO/raw/2018-04-24

Just these three.  Seems like the first one is faster, but we will see
9s per file!  Parallel works!

One crashed because of NAN in header from

DEBUG: /data/io/IoIO/raw/2018-04-24/SII_on-band_028.fits [__main__]


ReduceCorObs.py movie /data/io/IoIO/reduced/2018-04-21 --crop 600x600
ReduceCorObs.py movie /data/io/IoIO/reduced/2018-04-23 --crop 600x600
ReduceCorObs.py movie /data/io/IoIO/reduced/2018-04-24 --crop 600x600




ReduceCorObs.py reduce --directory /data/io/IoIO/raw/2018-04-26

In order to do parallel, I am looking at

https://docs.python.org/3.5/library/multiprocessing.html#multiprocessing.pool.Pool

So I have the iterable as the directory name, or if I do this at the
individual directory level, the file name.  But I have a bunch of
other arguments to pass.  That seems to be what the initializer and
initargs does

class multiprocessing.pool.Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])

So initializer is going to be something that returns something into
the process, where the process...  No

https://stackoverflow.com/questions/10117073/how-to-use-initializer-to-set-up-my-multiprocess-pool

suggests that initializer and args are something that float in global
namespace?

ReduceCorObs.py movie --tree

Thu Jun 28 17:05:45 2018 EDT  jpmorgen@snipe

After parallelizing individual directory, time is down to 1s per file,
~60s total.

12 processors
INFO: Average per file: 1.0895171892845024 [__main__]
24 processors
INFO: Average per file: 0.7718984555389922 [__main__]
6 processors
INFO: Average per file: 1.7209861925092793 [__main__]
3 processors
INFO: Average per file: 3.0761179843191373 [__main__]
18 processors
INFO: Average per file: 1.0278544143094854 [__main__]

1 processor was about 7 -- 9 

Consider going with either 12 or 24

Go with 12 which was my initial default

ReduceCorObs.py reduce --overwrite --movie --directory /data/io/IoIO/raw/2018-04-21


OK, after chasing down some bugs on that, run the big one!

Thu Jun 28 18:53:55 2018 EDT  jpmorgen@snipe

(a few minutes late)

ReduceCorObs.py reduce --overwrite --movie --tree

while that is working, do some work on logic of recalculation

ReduceCorObs.py movie '/data/io/IoIO/reduced/2018-06-27'

ReduceCorObs.py reduce /data/io/IoIO/raw/2018-06-27/SII_on-band_016.fits /data/io/IoIO/raw/2018-06-27/SII_off-band_016.fits

Thu Jun 28 20:33:48 2018 EDT  jpmorgen@snipe

Just finished!  Only 1.5 hours!
/data/io/IoIO/reduced/2018-03-28/Na_SII.mp4

Now try concatenation!

ReduceCorObs.py movie --concatenate

WORKS!  And takes 1000% of CPU.  So I am parallel processing with that
stuff too!  SO COOL

Marking directories as _marginal if they have
--> This needs to get copied into raw if it is going to stick
--> Ultimately it would be nice to find individual cloudy frames and nuke them


Fri Jun 29 09:49:12 2018 EDT  jpmorgen@snipe

See if I can get rid of fold effect.  See in 3/28 and beyond

ReduceCorObs.py reduce --movie --directory /data/io/IoIO/raw/2018-03-28/

Shifting is not the root of the fold effect.  Ah, but it is primarily
seen in the early days.  May 6+ dpesn't seem to show it

mp4 not working on picture frame but jpgs are.  Try gif?

ReduceCorObs.py movie --concatenate

gif not supported.  Plus it is HUGE!

Ah Ha!  I can get a small mp4 to be read.  What is the difference?

The Andoer DH says it is 1024x600
The small video is 560x320, but scales to full-frame
My dual video is 1240x600.  Maybe that is the problem?


ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2018-05-06

get 600x600.  Doesn't work.

let's assume I have to match the aspect ratio

1024/600 = 1.7066666666666668
560/320 = 1.75
1240/600 = 2.066666666666667

I like the torus at 600x600.  It is the 

ReduceCorObs.py movie --SII_crop 560x320 --recalculate /data/io/IoIO/reduced/2018-05-06

Well, that didn't work either.

From moviepy:     ftypisom   isomiso2avc1mp41

small.mp4:       ftypmp42    mp42isomavc1

Ah HA!  Got sinc_mll.mp4 to work!  So there is something I am doing
wrong with the way I am creating my file

That was 500x300 = 1.6666666666666667

so aspect ratio is not the key

ReduceCorObs.py movie --SII_crop 320x160 --recalculate /data/io/IoIO/reduced/2018-05-06

Video size is not it.

Tried data type int and that didn't do it

Try 20 fps

That was it!

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2018-05-06

OK, lets see if I can just bring in the higher frame rate movies and
slow them down OK

ReduceCorObs.py movie --concatenate

tweaked fstab to add this particular thumb drive.  Deleted the .dat
file that the frame was picking up on.

WORKS!

Sat Jun 30 21:24:44 2018 EDT  jpmorgen@snipe

Working on ccdproc.ImageFileCollection

import ccdproc

collection = ImageFileCollection('/data/io/IoIO/raw/2018-05-04')

Having trouble because of an old version of astropy I got with
debian.  Uninstall

--> Had to install astropy-helpers separately --> send note about dependency

This is getting me toward a CCDData which has uncertainty, but I won't
go there just yet because that would require gain correction and I
would want to cosmic ray remove, etc.

OK, so my design might need to change a little bit because I was
calling ephemeridies inside ReduceCorObs.  npang is the only thing I
really need to know in there.  Since the cost of the query is pretty
high, I can plug in the rest of the values on the way out, or in there
if I provide them

Sun Jul 01 13:44:06 2018 EDT  jpmorgen@snipe

It looks like FITS extensions are allowed now in PDS, which is good
news.  Do I want to have my info on aperture sums (Na) and profiles
(SII) in the FITS extension?  I think so

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2018-05-08

Wed Jul 04 16:14:47 2018 EDT  jpmorgen@snipe

collection = ccdproc.ImageFileCollection('/data/io/IoIO/raw/2018-05-04')

collection.values('filter', unique=True)
['[SII] continuum 40A FWHM', 'Na continuum 50A FWHM', 'R', 'Na 5890A 10A FWHM', '[SII] 6731A 10A FWHM']

SII_on_band_files = collection.files_filtered(imagetyp='LIGHT', filter='[SII] 6731A 10A FWHM')

SII_off_band_files = collection.files_filtered(imagetyp='LIGHT', filter='[SII] continuum 40A FWHM')

[print(f) for f in SII_on_band_files]

weird output.  Lots of Nones on the end.  I think I need a generator method

#[print(HDUList.filename()) for HDUList in SII_on_band_files.hdus()]

#[print(HDUList.filename()) for HDUList in collection.hdus()]

[print(h['DATE-OBS']) for h in collection.headers()]

Still has junk on the end of Nones

[print(fname, ' ', h['DATE-OBS']) for (h, fname) in collection.headers(return_fname=True)]

t = collection.summary
t['date-obs']

SII_on_band_date_obs = [l['date-obs'] for l in t if l['filter'] == '[SII] 6731A 10A FWHM']

tlist = [(l['file'], l['date-obs']) for l in t if l['filter'] == '[SII] 6731A 10A FWHM']

ReduceCorObs.py reduce --movie --directory /data/io/IoIO/raw/2017-04-27

Now that we are using ccdproc.ImageFileCollection (which I didn't want
to burden ioio.py with, but which is OK)

Thu Jul 05 16:15:27 2018 EDT  jpmorgen@snipe

Hmm.  What I really want now is an object that has the table for a
directory in it that things refer to.  Or I could just pass it as a parameter

ReduceCorObs.py ND_params /data/io/IoIO/raw/2017-04-27

ReduceCorObs.py ND_params /data/io/IoIO/raw/2017-04-28

Working in parallel!

But now I want to have some sort of persistent default_ND_params for
directories that don't have flats

--> put obj_to_ND in header and maybe ND angle?

ReduceCorObs.py reduce --recalculate --directory /data/io/IoIO/raw/2017-04-28

That is working a little better now

Astrometry: Other than my notes, do I save any astrometry from 2017?!

ReduceCorObs.py reduce --recalculate --directory /data/io/IoIO/raw/2017-05-01

Seems good

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2017-05-01

ReduceCorObs.py reduce --recalculate --movie --tree

--> The moving_to is presenting a problem

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-02-12

Fri Jul 06 19:23:20 2018 EDT  jpmorgen@snipe

Getting weird behavior with movie.  Skipping way too frames.

300s * 20f/s = 6000 = maximum speedup

Ah.  The problem is file order vs time order.  Did a
collection.sort('date-obs') to fix that.  Could potentially do a sort
on reduction, but I don't think it matters since that is all
asynchronous anyway.

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2018-02-12 --Na_crop 600x424

!  I can get the test zombie infection to go at 80fps.  Really not
   sure what magic happened to have the movie write!

So what frame rate do I really want?  Speedup = 24000 is right

24000fps/300s =  80

Hey, 6/20 is kind of nice in terms of double-sided and minimal moon

Sat Jul 07 08:28:59 2018 EDT  jpmorgen@snipe

Took about 3 hours

--> should put writing the movie into the reduce tree code

ReduceCorObs.py movie --tree --recalculate

oops, that was wrong

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2017-06-02

ReduceCorObs.py movie --concatenate

/data/io/IoIO/reduced/2017-04-18/

Sat Jul 07 12:10:34 2018 EDT  jpmorgen@snipe

2017-04-24 is a good example of bad background light

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2017-04-24

ReduceCorObs.py reduce --recalculate --directory /data/io/IoIO/raw/2017-04-24

Sat Jul 07 13:41:20 2018 EDT  jpmorgen@snipe

Move off previous run to /data/io/IoIO/reduced.previous_versions/movie_on_Andoer_frame/

ReduceCorObs.py reduce --tree --movie --recalculate

ERROR: 'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-07 [__main__]
ERROR:astropy:'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-07
ERROR: 'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-08 [__main__]
ERROR:astropy:'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-08
ERROR: 'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-09 [__main__]
ERROR:astropy:'MovieCorObs' object has no attribute 'last_persist_im' skipping movie for /data/io/IoIO/raw/2018-05-09

set last_persist_im = None
do next if last_persist_im is None

Sat Jul 07 16:21:56 2018 EDT  jpmorgen@snipe

Job just ended!  

More complicated than I thought to deal with the first image being
bad.  might be able to deal with it using a self.catch_up variable to
skip precision timing search

OK, so I need to be able to search forward.  Maybe the thing to do is
to call next, but mess with the dt_cur


ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/2018-05-07

ReduceCorObs.py movie --concatenate

lots of bad movies.  Nevertheless, still 2112 frames.  Save to
Na_SII_before_recalc.mp4

ReduceCorObs.py movie --tree --recalculate

Tue Jul 10 12:13:33 2018 MDT  jpmorgen@byted

--> Change sort for off-band time to include same side of meridian as
    on-band image

Tue Jul 24 13:19:28 2018 EDT  jpmorgen@snipe

Need to work on sodium time history for AGU ASAP.  Abstract deadline
Aug 1

Basically wanting a time series of residual background light.

Can start just with the whole total.  How do I want to store it?  Can
be in header value.  Also want something in a file kind of like I did
the movie.  ASCII file:

FNAME LINE TMID EXPTIME TOTAL [VARIOUS APERTURES]

do this before and after filtering out cosmic rays

cd, '/data/io/IoIO/reduced.previous_versions/2018_MOP_version/2018-05-20/
atv, 'Na_on-band_007r.fits

Looks like there is a lump in the middle as expected.  Away from
center, vector is zero.  Corners are <0 suggesting off-band
over-subtraction from bias or something

Hmm.  Might need to do real bias subtraction because it looks like the
BACKSUB picked up the background level of the whole image, not the
off-image corners like I had hoped

atv, '/data/io/IoIO/raw/2018-03-16_bias_dark/Trius_SX694-0005_1x1_bias.fit
-20C 1635

cd, '/data/PSIScope/raw/BIAS_DARKS
atv, 'Bias-S001-R001-C001-B1.fts
4.5C 1680 -- 1630

atv, 'Bias-S001-R012-C001-B1.fts
0C   1655 -- 1635 or so

atv, 'Bias-S001-R079-C003-B1.fts
-5C   1650 -- 1633 or so

atv, 'Bias-S001-R144-C001-B1.fts
-10C  1640 -- 1638

atv, 'Bias-S001-R210-C001-B1.fts
-15C 1635

im = readfits('Bias-S001-R210-C001-B1.fts')
median(im)
       1634.0000

atv, 'Dark-S001-R030-C001-B1.fts
in 1000 s dark image at -15C

im = readfits('Dark-S001-R030-C001-B1.fts')
median(im)
       1655.0000

so that is 21/1000 # c/s/pix dark current

0.021

atv, 'Bias-S001-R276-C001-B1.fts
-20C  1635

im = readfits('Bias-S001-R276-C001-B1.fts')
median(im)
       1633.0000

1000s dark
im = readfits('Dark-S001-R036-C001-B1.fts')
median(im)
       1652.0000

Not much different?

1s dark
im = readfits('Dark-S001-R031-C001-B1.fts')
median(im)
       1631.0000

So there really is dark current.  Doesn't change much between sensor
measured T -15 and -20C

Supposed to be 0.003e-/s at -10C

Gain is 0.3e-/ADU

0.021 *.3
0.0063

So it is a factor of 2 high

Could be high because of cosmic ray hits?  No, checked with 
im = readfits('Dark-S001-R030-C001-B1.fts')
imm = median(im, 3)
median(imm)

for a bias
stddev(im)
       15.475665

Readnoise should be < 5

stddev(im) * 0.3
       4.6426997
       
So I should subtract bias and dark, which is pretty much one number

ReduceCorObs.py reduce --recalculate --num 1 --directory /data/io/IoIO/raw/2018-05-20 
atv, 'Na_on-band_007r.fits
atv, '/data/io/IoIO/reduced.previous_versions/2018_MOP_version/2018-05-20/Na_on-band_007r.fits

The previous was definitly over-subtracted in the corners

Fixed code to do biases + there was som oscillation in the corners
between +/-20- 20 or so, but other than that, it looks pretty good

Don't want to kill Na because of on-band background level because that
is my measurement!

atv, 'SII_on-band_007r.fits

looks nice,  compare to 

atv, '/data/io/IoIO/reduced.previous_versions/2018_MOP_version/2018-05-20/SII_on-band_007r.fits

0 scaling says they are a little different, but hard to tell

Wed Jul 25 07:34:37 2018 EDT  jpmorgen@snipe

I seem to have a time dependent difference between bias+dark and first
hist peak: 14.79574140168711 -> 1 -> -15

That is enough so that I should do better.

After a while it get as big as -28, -38, -78, -84 (still on [SII])

Consider taking a run through the [SII] images to get the real
bias/dark as a function of time and then use that for all files.

--> consider being more careful with patch of CCD used for dark.
    Chance I see might be it just getting dark

--> Long-term, make a bias_dark component that goes through and does
    the study and informs final bias_dark subtraction

Thinking of making a file with both Na and [SII] in it with the
photometry from various apertures.  The [SII] would be a control.
Keep in mind I am doing this asyncronously, so I will eventually need
to sort the file.

Looks like PDS4 wants CSV files.  There is a csv module in Python....

import csv
with open('ap_sum.csv', 'w', newline='') as csvfile:
    csvw = csv.writer(csvfile, quoting=csv.QUOTE_NONNUMERIC)
    csvw.writerow(['FNAME'] + ['LINE'] + ['TMID'] + ['EXPTIME'] + ['TOTAL'] + ['AP_WHOLE'] + ['AP_STRIP_300'])
with open('ap_sum.csv', 'a', newline='') as csvfile:
    csvw = csv.writer(csvfile, quoting=csv.QUOTE_NONNUMERIC)
    csvw.writerow(['asd'] + ['Na'] + ['1998-02-03T00:00'] + [1234] + [123])

with open('ap_sum.csv', newline='') as csvfile:
    csvr = csv.reader(csvfile, quoting=csv.QUOTE_NONNUMERIC)
    for row in csvr:
        print(row)

The alternative is dictionary, which is a little prettier maybe

import csv
with open('ap_sum.csv', newline='') as csvfile:
    csvr = csv.DictReader(csvfile, quoting=csv.QUOTE_NONNUMERIC)
    for row in csvr:
        print(row)

Prints None for things I haven't defined yet.  Looks like DictReader is nicer.

But what I really want is something that gives me the rows in some way
like a database

import csv
dlist = []
with open('ap_sum.csv', newline='') as csvfile:
    csvr = csv.DictReader(csvfile, quoting=csv.QUOTE_NONNUMERIC)
    for row in csvr:
        dlist.append(row)

print(dlist[0]['TMID'])

Tlist = [dlist[i]['TMID'] for i in range(len(dlist))]

Tlist = [row['TMID'] for row in dlist]

np.argsort(Tlist)


dlist[0].keys()

import csv
with open('ap_sum_dict.csv', 'a', newline='') as csvfile:
    csvw = csv.DictWriter(csvfile, dlist[0].keys(), quoting=csv.QUOTE_NONNUMERIC)
    csvw.writeheader()
    for row in dlist:
        csvw.writerow(row)

This puts the keys out of order.  It might be nice to define the keys
first.  Also will need to check if overwrite, file has been written
for header, all that stuff.

OK, where do we put the writeheader?  Best in reduce_pair if I can get
the logic right.

reduce_pair doesn't know about other things that have run before.  So
I should probably have ReduceDir delete the ap_sum (or whatever) file
if it is going to recalculate a directory.  Then I check to see if the
file exists on each call to reduce_pair, so I can make sure to start
the file with the header.  After the directory has been processed,
then I want to go back and look at the file.  This can be done in the
same way do the movie tree, I suppose.

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/SII_on-band_007.fits /data/io/IoIO/raw/2018-05-20/SII_off-band_007.fits

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/SII_on-band_042.fits /data/io/IoIO/raw/2018-05-20/SII_off-band_042.fits

atv, '/data/io/IoIO/reduced/2018-05-20/Na_on-band_007r.fits
im = readfits('/data/io/IoIO/reduced/2018-05-20/Na_on-band_007r.fits')

im35 = median(im, 35)
taking a long time, like > 30s

im3 = median(im, 3)

im6 = median(im, 6)

That looks the best

There are some nasty negative things.

mean(im)
       57.027342241515456
IDL> mean(im3)
       56.118599598610693
IDL> mean(im6)
       57.167417728216272
IDL> mean(im35)
       51.595598239034388


ReduceCorObs.py reduce --recalculate --directory /data/io/IoIO/raw/2018-05-20 

Getting some big negative in the IPT images

I suspect this is because of problems near the ND filter

Thu Jul 26 10:03:24 2018 EDT  jpmorgen@snipe

No, the problem on [SII] seems to be a general below zero

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/SII_on-band_007.fits /data/io/IoIO/raw/2018-05-20/SII_off-band_007.fits

On-band difference between bias+dark and first hist peak:  1.7966763942929447      
Off-band difference between bias+dark and first hist peak:  -2.240000000000009  

That is pretty good so it is presumably not

atv, '/data/io/IoIO/raw/2018-05-20/SII_on-band_007.fits
atv, '/data/io/IoIO/raw/2018-05-20/SII_off-band_007.fits

There is definitly an edge from scattered light that can presumably be
found by the first peak algorithm.

But even after that is found to fairly high precision there is still
this residual background.  For the [SII], this is relatively easy to
deal with since we expect 0 and can set it to 0 by making the
assumption we are seeing some sort of atmospheric emission in the
off-band filter at the ~50R level.  This makes some sense because it
is uniform across the field, not patterned after the scattered light

OK, that potentially explains why [SII] is such a large negative sum.

How can we make sure Na is OK?  I expect there to be earth atmospheric
Na, which would make a pedestal.  The question is: do I have a large
enough FOV to measure that.  Looking at Wilson et al 2002, 10Rj up or
down is still 50 R or so from the intrinsic nebula.  I am getting an
average of 57R

Rj = np.asarray((50.1, 29.8))/2. # arcsec
plate = 1.59/2 # main "/pix
(2627-1467) * plate / Rj
array([36.81437126, 61.89261745])

So I do go up.down more than Wilson.

im = readfits('/data/io/IoIO/reduced/2018-05-20/Na_on-band_007r.fits')
plot, im[1522, *], /ylog, yrange=[1, 10000]

Looks like residual might be 30 at an edge

plot, im[1522, *] - 30, /ylog, yrange=[10, 1000]

Fiddling with things convinces me I probably have a constant
background issue in both the [SII] (off-band) and Na (on-band)

I am also seeing the best way to present this is by average pixel
value, so I need to do some pixel counting

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/Na_on-band_007.fits /data/io/IoIO/raw/2018-05-20/Na_off-band_007.fits

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-05-20 

Consider doing edge masking from both on- and off-band images

--> Note that the interpolate shift and rotate mess up the perfect 0
    values at the edges of the ND filter

--> note on this day the movie is messed up because it looks like the
    center of Jupiter is messed up by the passage of a moon

May be because I assume center of Jupiter is perfect?

! Leave it a mystery for now

Looking at aperture sums in Excel.  All apertures track each other.
They all get brighter starting around 8UT.  That seems to be a linear
trend on top of whatever downturn has happening before.  Last point is low

second time equals first!  Seems to be my copying somehow

A case could be made that there is a bump in the total aperture,
presumably from Io.  There is less of that in the other data, but
still a plateau.

So I think I am ready to run this on everything.  I will need to make
a routine that reads all the files like movie does, but that is what
is up.

Thu Jul 26 15:33:44 2018 EDT  jpmorgen@snipe

ReduceCorObs.py reduce --tree --movie --recalculate

!!  Something seemed to happen April .  Hmm.  My data got rattier....

Horizons gives me the moon angle for Jupiter, so I don't need to
calculate that separately, though moon height would be nice (does have
m flag)

? Am I too cool in April?

Seems to be the pattern

atv, '/data/io/IoIO/reduced/2018-02-06/Na_IPT_R-0002_SII_on-bandr.fit
atv, '/data/io/IoIO/reduced/2018-02-06/Na_IPT_R-0003_Na_on-bandr.fit

Whoa!  Bias changed!  Seems to be about 1726 now, easily read from
[SII] image

Need to have a better way of determining this for the Na images.  Try
some aperture sums?  No, do the interpolation from SII images

Thu Jul 26 22:23:26 2018 EDT  jpmorgen@snipe

ReduceCorObs.py reduce --tree --movie --recalculate

Fri Jul 27 07:43:24 2018 EDT  jpmorgen@snipe

Well, that finished and it looks almost the same!

No, the problem is that I did not sort the output of asyncronous
jobs....

OK, rerunning.  

Fri Jul 27 11:37:06 2018 EDT  jpmorgen@snipe

Done with rerun

Looks like moon was not until Jan 27.  Got close Feb 6 -- 9, went away
Feb 13.

Back again Feb 23, close Mar 5 -- 9, gone Mar 15

out very close starting Feb 6

Fri Jul 27 13:08:25 2018 EDT  jpmorgen@snipe

Well, I can look at the [SII] distribution and find that away from the
IPT, there is no evidence of increase in light.

Worry about temperature sensitivity of off-axis response.  Plot total
and it really doesn't make much difference.

Interestingly, just the central part peaks later.

Wait a minute.  The way I have done the subtraction with medians, the
surface brightness in the center is much less bright than I
expect....  Ahh.  I am subtracting the surface brightnesses without
taking into consideration the area...

But the reason I was checking the middle area inside of 300 pixels was
to see if the effect went away, since I would expect the wavelength
shift to not be so close to the edge of the bandpass.  That didn't
seem to be the problem

--> Oops, I think I need to fix my background to include off-band
    images as well, since the exposure time and thus dark current will
    be different

Tue Jul 31 12:51:49 2018 EDT  jpmorgen@byted

--> Consider taking the stdev of the nighly aperture sums to see if it
    is a bad cloud night

Sat Aug 04 04:05:00 2018 MST  jpmorgen@byted

--> talked with Dean about coordinate systems and camera orientation.
    It seems like ASCOM has things backward from Astro-Physics and
    Dean's preference.  His preference is to have north up when the
    mount is on the west looking east.  I didn't necessarily think of
    it that way, I just pressed north on the AP ASCOM driver and
    assumed that was north.  But that is only north when the mount is
    on the west looking east

Thu Aug 16 17:37:56 2018 EDT  jpmorgen@snipe

+    off_im *= on_jup/off_jup * on_loss
+    scat_sub_im = on_im - off_im
+    # I like TACOS!

what an aperture sum procedure or method of an object that does the
aperture sum for an exclusion zone and writes the result somehow

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/Na_on-band_007.fits /data/io/IoIO/raw/2018-05-20/Na_off-band_007.fits
ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-05-20 
Move files off
Thu Aug 16 23:16:34 2018 EDT  jpmorgen@snipe
ReduceCorObs.py reduce --tree --movie --recalculate

INFO:astropy:/data/io/IoIO/raw/2018-06-25
WARNING: ND filter edges are not parallel.  Edges are off by 51.185743252081764 

Fri Aug 17 10:12:19 2018 EDT  jpmorgen@snipe

Finished at 2:48AM

I am seeing a lot of flashing events before 2018 May

AP_600 looks the same
On_0 looks the same as the volcanic outbest, just higher

Off_0 increases to the later dates just like I would expect!  It also
decreases from the early observations in 2017, which I don't quite understand

The On_0 shows the same decrease

The AP_600 shows a hint of it

--> Make a composite of nightly plots

Fri Aug 17 14:29:26 2018 EDT  jpmorgen@snipe

sodium layer is at 50 -- 65 miles altitude.  That is about the
distance from Tucson

March 2018 is peak

Opposition was May 8-9.

Expecting minimum distance of light travel to be the way to get light
into the telecsope, I would expect the peak to be after opposition

Looking at night individually and many nights in May are clumpy around
a median with some high values at beginning and end.

Late ooposition swoppy to end of night

May is about even

April there is more spread

March 15 is a swoop plus plateau that looks like it could be from
emission down the pipe in the middle of the night

Wed Aug 22 09:45:21 2018 EDT  jpmorgen@snipe

https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/JA086iA03p01463

Ozone and sodium linked, but not sure how

The ozone density shows a strong seasonal variation with well defined maxima at the equinoxes, a

https://ac.els-cdn.com/S136468261500005X/1-s2.0-S136468261500005X-main.pdf?_tid=ac6314ea-8c36-452a-8f73-d18e87eff390&acdnat=1534945773_9aec1f2f3e1dafb67eebc0b31d1825fc

Column density at WACCM-Na.  There is a flat plateau ~ Sept to late
Jan and then a precipitous drop from Feb to Jul

ALOMAR Na lidar (69.3°N, 16.0°E)

So that is northern hemisphere.  

So that is similar to what I see in general profile

Wed Aug 22 13:48:39 2018 EDT  jpmorgen@snipe

Reading Carl's email, he says that mesospheric Na emission is 100 -- 200R

That is right in the range that the full-field aperture sum shows, at
peak time.

Assuming this, I want to take a smaller aperture, maybe above and
below for background, and then ones out to the side that would be
dominated by the Jovian Na.

Thu Aug 23 11:35:18 2018 EDT  jpmorgen@snipe

Get places to do aperture sums.

On SII, highest is
1900 - 1100 = 800

Getting aperture sums to work

--> consider getting rid of aperure sum FITS keywords or reducing
    sensitivity to warning message

Thu Aug 23 12:27:44 2018 EDT  jpmorgen@snipe
ReduceCorObs.py reduce --tree --movie --recalculate

Thu Aug 23 16:17:31 2018 EDT  jpmorgen@snipe

Just finished

Thu Aug 23 18:59:56 2018 EDT  jpmorgen@snipe

Doing comparison of APp300 and APm1200.  The APm1200 is very low
compared to APp300, like down around 50 approx R.  

Fri Aug 24 11:09:21 2018 EDT  jpmorgen@snipe

Double-check what the flat fields are like

cd, '/data/io/IoIO/raw/2018-05-20
atv, 'Sky_Flat-0001_Na_off-band.fit

bias ~ 1618

edge, middle 
f = [14700, 17000] - 1618.
f[1]/f[0]
       1.1758142

That is not going to break the bank.

Wed Oct 17 16:48:07 2018 EDT  jpmorgen@snipe

See also ../../IoIO_reduction.notebk

pip3 install -U scikit-image
pip3 install -U moviepy

$ # If you have a github account:
$ git clone git@github.com:astropy/astroquery.git
$ # If you do not:
$ git clone https://github.com/astropy/astroquery.git
$ cd astroquery
$ python3 setup.py install

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-20/Na_on-band_007.fits /data/io/IoIO/raw/2018-05-20/Na_off-band_007.fits

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-05-20 

https://github.com/Zulko/moviepy/issues/401

ERROR:astropy:MoviePy Error: creation of None failed because of the following error:

convert-im6.q16: not authorized `@/tmp/tmp1bjiq8cc.txt' @ error/property.c/InterpretImageProperties/3663.
convert-im6.q16: no images defined `PNG32:/tmp/tmpa5uj0gw6.png' @ error/convert.c/ConvertImageCommand/3258.
.

Took out 
  <!--<policy domain="path" rights="none" pattern="@*"/> -->

in /etc/ImageMagick-6/policy.xml

ReduceCorObs.py reduce --tree --movie --recalculate

INFO:astropy:/data/io/IoIO/raw/2018-05-19

WARNING:py.warnings:/usr/lib/python3/dist-packages/scipy/signal/_arraytools.py:45: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result.
  b = a[a_slice]

Thu Oct 18 07:40:20 2018 EDT  jpmorgen@snipe

It looks like there is a problem when I do the ValueError -- column
elements are not written, so the row gets all messed up.  Last one
that seems to work OK is 50, which is basically indistinguishable from
the plain aperture sum

filt_list = ['cloudy', 'marginal', 'dew', 'bad']

data_root = '/data/io/IoIO'
ap_sum_fname = 'ap_sum.csv'
top = os.path.join(data_root, 'reduced')

Thu Oct 18 21:29:35 2018 EDT  jpmorgen@snipe

Not going well with read_ap.py new version late at night.  Just run
main code overnight and improve tomorrow.

--> useful!
https://matplotlib.org/gallery/recipes/common_date_problems.html

https://matplotlib.org/2.2.3/_modules/matplotlib/dates.html

Matplotlib represents dates using floating point numbers specifying the number
of days since 0001-01-01 UTC, plus 1.  For example, 0001-01-01, 06:00 is 1.25,

Fri Oct 19 08:52:20 2018 EDT  jpmorgen@snipe

Something weird going on between 50 and 60 Rj.  Ahh.  This might be
the turn-over point.  Certainly by 110, I have reached the edge of the
entire FOV for measurements at the peak of opposition:

For this opposition, 
Rj = [44.8, 34.2]/2. ;; arcsec

2948*0.78/Rj ; rotated image height * arcsec/pix / (arcsec/Rj)
       102.65357       134.47017

The weird thing is that the edge is greater than the middle for this extreme

60 is the cross-over, where the edges are 0 at the beginning of the
opposition and high after March and the inner is high initially and
low after March.

1200*0.78/Rj
       41.785713       54.736835

40 is starting to look normal

2948/2.
       1474.0000

2948/2. + 1200
       2674.0000

So this is just edge effects.  When I am out beyond 40, I am getting
0s from the original rotation and a little signal from the point.  But
the wierd thing is when I do AP_Rjp60 and get a small signal

So there are two ways for this to happen.  The sum of pixels gets
small for some reason or the number of non-zero pixels gets large.

AP_Rj_0 is happy, which is a good sign that the images are OK and this
is just a weird coding issue in Rj_strip_sum

I get why extremely high Rj values make the "m" apertures small --
they are just sampling the background and are contaminated

Dates between 2018-02-21 and 2018-03-05 are worth looking at

/data/io/IoIO/reduced/2018-02-22/Na_IPT_R-0001_Na_on-bandr.fit

looks like a fine specimen

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-02-22/Na_IPT_R-0001_Na_on-band.fit /data/io/IoIO/raw/2018-02-22/Na_IPT_R-0001_Na_off-band.fit

Ah ha!  I think I am seeing the problem.  It has to be put in an
ordered dictionary?  Check the worst one:

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-02-22/Na_IPT_R-0013_Na_on-band.fit /data/io/IoIO/raw/2018-02-22/Na_IPT_R-0013_Na_off-band.fit

yc = 2859/2. ; center
total(im[*, yc-1472/2:yc+1472/2])

Ah HA!  The confusion is diameter vs radius of FOV

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-02-22

This is giving the tuple sequence error

ReduceCorObs.py reduce --tree --movie --recalculate

Fri Oct 19 20:01:30 2018 EDT  jpmorgen@snipe

Telling a little bit of a different story.  The background beyond 80
Rj FOV strip is about a factor of 2 down from full-field and 80 Rj FOV
average surface brightness.  This is in late March.  Earlier than
that, the background is higher, later it is lower.  This could be some
seasonal effect, since I think it gets eroded in the spring

Tue Oct 23 12:59:06 2018 EDT  jpmorgen@snipe

Need to have a program that makes the supporting table

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/2018-02-22

Decide to not do negative boxes.  Don't do apertures, since they give
confusing results near Jupiter, presumably because of the satellites.

Look into figure production

from precisionguide import get_HDUList
HDUList = get_HDUList('/data/io/IoIO/reduced/2018-02-22/Na_IPT_R-0003_SII_on-bandr.fit')

Thu Nov 01 15:07:15 2018 EDT  jpmorgen@snipe

See IoIO_reduction.notebk

ReduceCorObs.py reduce --recalculate /data/io/IoIO/raw/2018-05-08/Na_on-band_004.fits /data/io/IoIO/raw/2018-05-20/Na_off-band_004.fits

Sat Nov 03 23:19:13 2018 EDT  jpmorgen@snipe

Add a few more apertures

ReduceCorObs.py reduce --tree --movie --recalculate

Wed Nov 14 10:33:14 2018 EST  jpmorgen@snipe

See ~/IoIO_reduction.notebk

Oops, don't have dates in Na movie

Fixed that.

Getting ready to upload everything to GitHub

git ls-tree --full-tree -r HEAD
100644 blob c24e9012aa23ef81af4c9e89763f9cf571f89b5e    .gitignore
100644 blob 22d1a3cd43165058a11ec3669292c010e80e8c1b    ASCOM_namespace.py
100644 blob 379118ab2cae44d9b63d810f41235c734b55cf25    IoIO.py
100644 blob 2865a96cf911096442605937f51cdad02ccae39b    Na_support_table.py
100755 blob 884a3b21d1a428c7dfa89578a710f2687eaf6133    ReduceCorObs.py
120000 blob c3bebd7b49061f20c713018216c36c7609b15260    define.py
XXXXXXXXX blob 8892ebe0cd3eb67d01cbd566d01ad6b269e37e47    get_jupiter_center.py
100644 blob a2aeb2b211217dc90a0f1e67e34406edf6124e4b    ioio.notebk
100755 blob 9e4507bc32dbe8870fa5ecbdf446ad1da06f95a1    ioio.py
XXXXXXXXXXX blob 8260742ca01ca714cbf7b9e88eb6306abd68e72c    maximdata.py
XXXXXXXXXXX blob aff12e368fd5c4699dc133a619960587fcf19505    move_telecsope.py
XXXXXXXXXXX blob f494a6224c3c1088d6e60509e89c4694250e7edc    offset_guide.py
100644 blob 1be5f9610ae32c0ff6dc12f640a482215db6323d    precisionguide.py
100755 blob a4c866595c1cce59ced4d6eb6559fefbb0eaf1b2    read_ap.py

Not sure I need all of this stuff

ioio.py: version of code used to control telescope during 2018 Jovian
opposition.  No new development expected since precisionguide.py and
IoIO.py combine to take on its functions

ReduceCorObs.py: code used to reduce IoIO observations.  Imports
precisionguide.py

read_ap.py: reads the CSV file created by ReduceCorObs.py which has
the individual image aperture surface brightness values and reduction
parameters

Na_support_table.py: generate a properly sorted CSV file containing
the individual image aperture surface brightness values and reduction
parameters

precisionguide.py: start of a general package which will solve the
problem of differential flexure between boresite-mounted guide scopes
and main scope.  Based on ioio.py, imported by ReduceCorObs.py, imports
ASCOM_namespace.py

ASCOM_namespace.py: I have not figured out how to get Python to link
into the same system that Visual Basic and related compilers use to
make the ASCOM namespace available to client programs.  So I just
define them myself here.

IoIO.py: new version of ioio.py.  Imports precisionguide.py.

ioio.notebk: software developement notebook

Wed Nov 14 14:57:39 2018 EST  jpmorgen@snipe

Wanting to push this to GitHub.  Been a while since I have done this.
It looks like I need to create the repository on GitHub first and then
push to it

Description is separate from README.md

Code used to record and reduce data with the Io Input/Output facility (IoIO)

Wed Nov 14 15:49:22 2018 EST  jpmorgen@snipe

Got it up to GitHub, but I need to work with the local stuff to make
GitHub the default master, or however you say that.

Tue Jan 08 09:49:28 2019 EST  jpmorgen@snipe

Decided to implement ADU2R_adjust in Na_support_table.py rather than
re-do the pipeline at this point.  Getting ready to put a snapshot up
<<<<<<< HEAD
on a permanent repository as suggested by the Data Editor.

COOL!  I can put the code on GitHub and then make a release in GitHub
that will automatically be pulled over into Zenodo.  Whenever I make a
new release in GitHub, a new release will be published in Zenodo too!

https://zenodo.org/account/settings/github/

https://git-scm.com/book/en/v2/Git-Basics-Tagging

OK, so release tagging is how versioning is done in Git, rather than
pure incremental as with RCS.  I can make tags locally, but I would
have to push them separately, unless Magit takes care of this for me
in a natural way.

Made a release with GitHub for Daniel.  That was easy enough, so
consider just sticking with that.

Daniel has a DOI!

Put it back into his README, as recommended and increment the tag.
Try this in Magit.  Magit push has push tags as well!

https://github.com/AASJournals/Tutorials/blob/master/Repositories/UsingRepositories.md

Not clear, but authorship goes into Zenodo

Did a tag upload with Magit and indeed, got another release for
Daniel's stuff.

But zenodo is not automatically grabbing it.

Linked ORCID in addition to GitHub

OK

https://git-scm.com/book/en/v2/Git-Basics-Tagging

misled me.  There are lightweight tags, annotated tags and GitHub Releases

https://stackoverflow.com/questions/18506508/whats-the-difference-between-tag-and-release

But GitHub still allows the difference and calls them releases on its
release tab, but not the latest release.  I guess it is like a draft
release until I tweak it in GitHub?

OK, tried that.  Now see what Zenodo does.  Bar at top told me there
was a newer version ready.  Ack.  It doesn't bring over the author and
other metadata info.  Pain.

So the important place for the Zenodo badge/latestdoi is in README.md,
which I will be adding very shortly as I improve the software.  But if
someone pulls it down....  So the best thing to do is commit twice.
At least I can

No, it looks like in the upload section, I can reserve a DOI.  But
that breaks the GitHub association.

Maybe I can use a draft release...
=======
on a permanent repository as suggested by the Data Editor
>>>>>>> 802ae64de9920ea30545f83e3306cab52ac681ca

Wed Jan 16 14:13:13 2019 EST  jpmorgen@snipe

Looking back at

/data/PSIScope/observing/AcquireImages.js

and thoughts about how to use that

--> consider an ACP-ScriptFail script
http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/addtologic.htm#scriptfail

So it looks like TargetStart() is what I want to do to do an offset
for the upcomming target.

ImageStart() might do it too, but it is used for all things like
pointing exposures, biases and darks.  I don't want to mess up
pointing exposures, since I need to know at some point where I am.

OK, so how do I mess with TargetStart()?

Trying to get UserActions registered by reading
http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/addtologic.htm#acqimg

got error: scrobs.dll laded by call to DllRegisterServerEx failed 0x800c0005

Oops, I think that might be because I don't have any UserActions
defined!

I need to take the template and do something with it.


OK, there is /cygdrive/c/Program Files (x86)/ACP Obs Control/UserActionsJS-template.wsc

JavaScript is better to work with

OK, so that UserAction is called in AcquireImages with
SUP.UserActions.TargetStart(Pl, Tc, Tn)

Where Pl = plan, Tc = current target, and Tn = next target

So I want to offset.  I don't think I even need the actual target
coordinates, since I can just read the telecope.  But maybe best to do
it with what ACP thinks is the target.  Whatever is easier, really....

OK, so there is Tc.RA which I want to add to and then reposition the telescope

    SUP.StartSlewJ2000(Tgt.Name, Tgt.RA, Tgt.Dec);                          // MUST SLEW ALWAYS
    if(SUP.HaveRotator) 
    {
        Console.PrintLine("  (rolling rotator over 180 deg...)");           // This can be really slow so do it first
        SUP.StartRotateToPA(Tgt.PA, Tgt.RA);                                // Rotator will flip here
    }
    WaitForSlews();                                                         // Wait for all of that

This is from line 3016+ of AcquireImages.js, which is after
TargetStart.  So it looks like really all I need to do is just change
the Tc.RA and ACP will do the rest.  The target RA then will be offset
from the true target, but the real answer comes from the astrometric
solution later on.

If I can get access to this:

Prefs.PointingUpdates.MaximumError / 60

that would be great!  [Util.Prefs...]

what are the units of RA? [hours]  SUP.EquDist2 might help.  See
        return (SUP.EquDist2(Tgt.RA, Tgt.Dec, Telescope.RightAscension, Telescope.Declination) <= 
                (Prefs.PointingUpdates.MaximumError / 60));

which implies it is probably hours unless the answer is in degrees
Probably I just need to try it with a simulator and PrintLine

-->  Next step is to see if I can get to Prefs....

OK, it is there.  Now I just need to figure out how to run it.....

1/1/1970
2440587.500000
2458500

17912.  Not equal to 019016.82075

2458500 - 19016.82075
2439483.17925

Friday, A.D. 1966 Dec 23

Sat Jan 19 10:10:02 2019 EST  jpmorgen@snipe

OK, got that working more or less with the developer.

Now on to more UserActions

--> Eventually, I may wish to make the TargetStart figure out which
    way to offset, or have a user-configurable offset

But of more importance is getting PrecisionGuide & IoIO to work!

So now I am seeing AcquireImage() in a new light.  I could
potentially make it like the MaxIm version of PrecisionGuide I was
thinking about.  The advantage of this is that I could make plans that
have image sets that do all of the filter changing I want & have
PrecisionGuide independently monitor the position of Jupiter and make
sure it is OK.  But that monitoring stuff was hard.  For the sake of
development, I should probably avoid the fancy data stream version and
just concentrate on R-band for now.  Also, I need to do guiding + I am
not sure if that will be interupted by going to another image... no,
that should remain the same, since images are different than targets.
Jupiter will be my target + no guiding is done anyway....  OK, things
are shaping up....

So I think the first thing I need to do is set up logic to call a
Python script

--> 

Sun Jan 20 16:44:23 2019 EST  jpmorgen@snipe

Looking at IPT_Na_R.

OK, I do all kinds of stuff with the telescope and camera, which
might cause problems given:

                To control the telescope and camera, you MUST use Util.ScriptTelescope 
                and Util.ScriptCamera. DO NOT CREATE INSTANCES OF ACP.TELESCOPE, 
                MAXIM.CCDCAMERA, OR ACP.CAMERA! This will prevent access locks from 
                working properly.

Bob recommends

https://www.sapien.com/software/primalscript

I am guessing it lets me figure out what is going on with the
underlying variable namespace.  There is a 45-day trial.  Otherwise,
it costs $400!

First lets use the simulators so I can get somewhere without crashing
the telescope.

Oh, but first I should check that the RA really was tweaked.  

OBJCTRA = '06 00 14.00'        / [hms J2000] Target right ascension
OBJCTDEC= '+00 00 00.0'        / [dms +N J2000] Target declination 

Indeed,
3.5/60*24/360*60*60
14.0

OK, so we are in business with standard objects, but what about the
coronagraph?  Am I going to be able to use precisionguide.py and IoIO.py

At the very least, I might be able to subclass the Maxim methods to
use ACP-speak when in ACP mode.

--> setting up simulator.  Might want to re-enable guide rates and
    RA/Dec Rates

Got a simulated plan to work

OK, Prefs. is not working in the UserActions.  But Util.Prefs does!

OK, next step is to see if I can invoke some sort of Python script
form the .js code.

I am not sure if that works.  I think the whole WSC has to be python,
which is not that big a deal

http://forums.dc3.com/showthread.php?10699-Imaging-Geosynchronous-Satellites-with-ACP-(rev-Jan-2018)

May have some hints

Looks like they shell out to Python code with command-line parameters,
write the results to files and read those files back into the .js.
That is not what I want.

Sun Jan 20 23:23:42 2019 EST  jpmorgen@snipe

Ah HA!  I can have IoIO.py be a WSC that is called from UserActions.
It can pop up like MaxIm does and then run as a separate process that
the UserActions talks to.  There would only be a few things to do and
possibly a few variables to keep track of in the global section of one
or the other WSC

OK, pythoncom
    # https://www.pythonstudio.us/introduction-2/implementing-com-objects-in-python.html
    # http://timgolden.me.uk/pywin32-docs/contents.html
    # import pythoncom

But the simpler thing to do is what Bob recommended (and I have
thought of), which is to just shell out and have IoIO.py do all the
work.  Now that I know I can kill IoIO.py with the weather safety
script, that helps a lot!

Eventually, the thing to do is make a Python COM server as per the
website above and have ACP pass the code one image request at a time.
If a non-coronagraph image request comes by, the code needs to be told
to shut down gracefully -- at least operations to MaxIm.  But still,
in that ideal endstate, I might want to have the program started up in
StartupObs and shut down by the weather safety or at least ShutdownObs
scripts.

In any case, the overhead of starting IoIO from the command line for
30 minutes of observations is not much.  Oh, there is the issue of the
meridian, but if I synchronize the exposure time and the time with
IoIO, all should be well.

Installing Anaconda with Python 3.7 on Gigabyte.  Chose not to install
with PATH, but I think this is a mistake.  Though it does force me to
explicitly enter the path

C:\ProgramData\Anaconda3\python.exe is where it is.  Looking online
and find that I am just better off uninstalling and reinstalling,
although there was a SETX option at
https://medium.com/@GalarnykMichael/install-python-on-windows-anaconda-c63c7c3d1444
that might have been faster

setx PYTHONPATH \\snipe\homes\py;\\snipe\homes\py\IoIO

Worked!  It looks like I am not able to get python running

Well, it seems like the prefered way to do this is with

python script_name arg1 arg2 etc

But now it is working the other way.

OK, so what I want is a simple command-line that does ...

Mon Jan 21 12:11:04 2019 EST  jpmorgen@snipe

Talking with Bob

Satellite thing has tag facility #Jupiter

imagestart could change guide tyo 600s to get guider

Util.ScriptCamera = MaxIM's CCDCamera
locking for multi-user protection in ACP
just leave Python alone

--> ACP weather = weather safety script to kill python script
--> Kill like Maxim


Tue Jan 22 09:35:54 2019 EST  jpmorgen@snipe

Hmm.  Looking back at AcquireImages.js and find that AcquireImage does
just one image at a time, like I want.  Ah, but I can have it actually
write lots of images.  And the flip logic precedes it

/cygdrive/c/Program Files (x86)/ACP Obs Control/UserActions.wsc

/data/io/IoIO/observing/ACP/UserActionsGeosyncSatellites/UserActionsGeosyncSatellites.wsc

Very important example, as is shows how to use the Util.ShellExec feature

Wed Jan 23 14:53:57 2019 EST  jpmorgen@snipe

OK, I am getting it to work a little bit with a hello_world.py test
case.

--> Not getting console output when I just print from the Python script

https://docs.python.org/3.3/using/windows.html

ftype Python.File=C:\Path\to\pythonw.exe "%1" %*

Thu Jan 24 09:16:42 2019 EST  jpmorgen@snipe

Python window does not appear in front of other windows, but it is
there so there is visible logging!

OK, now I need to get a command line for the process.  So ACP is
giving me a single image file.  I need to hack that filename apart and
make my desired filenames

C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190123\Test1-S012-R001-C001-R.fts

python \\snipe\jpmorgen\py\hello_world.py ACP_IPT_Na_R "C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190123\Test1-S012-R001-C001-R.fts"

OK, the double quotes take care of binding spaces into one string

OK, getting that to work better

\\snipe\jpmorgen\wsh\AcquireImage.js

cscript.exe \\snipe\jpmorgen\wsh\AcquireImage.js

Whew.  Got the basic command line passed.  Now I want to decide how I
am going to deal with the filenames.

OK, right now I am using my own uniq_fname function in
precisionguide.py.  That just takes the directory.  It also adds
.fits, which I prefer, but emacs can now deal with .fts

OK, so all I need is the path.  I think I got that.

Now I need to work on the logic for the timing.  "#interval" is the
plan notation for exposure time.

Looking at /data/PSIScope/observing/Plan.js which I grabbed out of
Plan.wsc

IMG.Interval is what I want, where IMG is an ImageSet

OK, that is working.  Now I want to run a test script that uses the
exptime and 


python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_IPT_Na_R 1800 "C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190123\Test1-S012-R001-C001-R.fts"

Thu Jan 31 03:59:16 2019 EST  jpmorgen@snipe

Ack.  timedelta objects are more complicated

Thu Jan 31 05:06:53 2019 EST  jpmorgen@snipe

WORKING!

Thu Feb 07 16:35:22 2019 EST  jpmorgen@snipe

Hmm.  Maybe not so quick.  While collecting Na, MaxIm disconnected
from the camera and now it is stuck for a long time just "Collecting Na"


python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_IPT_Na_R 60 "C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190123\Test1-S012-R001-C001-R.fts"

OK, improved info logging and try to see if having ACP on stops python
exit from disconnecting camera

GREAT!  So if ACP is connected, Python exit does not disconnect
camera!  That makes life much easier.

Guider is still going after script exit, which is what I think I want.


python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_IPT_Na_R 1800 "C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190207\Test1-S012-R001-C001-R.fts"

OK, seems to be working reasonably well.  Collecting the different
filters and stopping itself when time limit is reached.

What is the next step?  Calling it within ACP with reasonable tags

--> Need run-level ND_params

--> Oops, I need some pin point solutions....

--> consider using ioio.py for now and later go to production on IoIO

cd Desktop\IoIO\Scripts
ioio.py ND_params "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\data\2019-02-07"

run_level_default_ND_params \
    = [[  4.65269008e-03,   8.76050569e-03],
       [  1.27189987e+03,   1.37717911e+03]]

--> check filtger names in IoIO.py & associated for space to _
    transition, include this 

ioio.py center
ioio.py guide --filter 3
ioio.py center

Oops, I need a better center, with the proper CorObsData

Fri Feb 08 19:36:16 2019 EST  jpmorgen@snipe

Get ready for IoIO replacement on IoIO1U1

put in run_level_default_params and updated PinPointSolution* stuff.

I want an rsync process to be able to copy things over properly

There are a bunch of things in the Scripts directory.  I might want a
specific one for python.  Or just copy over the couple I need 

--> rsync
eval `ssh-agent` 
ssh-add
rsync -auv jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/home/jpmorgen/py/IoIO/IoIO.py "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/Scripts"
rsync -auv jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/home/jpmorgen/py/IoIO/precisionguide.py "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/Scripts"

Works!

Fri Feb 08 22:13:34 2019 EST  jpmorgen@snipe

disabling auto-center for faster testing [re-enabled]

"C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190209\Aldebaran-S001-R001-C001-R.fts"

Working!  When I abort run, however, the script does not abort

--> Got "Abort Failed" dialog box
--> Even when I crash with making the weather server die, the program keeps running

This would be reason to have server with individual exposures so
weather events are less of a risk.  But for now, this is workable

--> There may be some scripts that run on abort and weather which
    would kill a program
--> Consider making a simple shell script that would stay running so
    Python process would be easy to find and kill

Sat Feb 09 08:07:10 2019 EST  jpmorgen@snipe

--> Didn't turn off the guider when switched to a different object

--> Other programs were still running instead of killing themselves!

-->  Guider moves going in wrong direction to center Jupiter
--> worked for west of meridian, check for west again

--> wasn't on non-siderial tracking

So it looks like Bob messes with things possibly


--> Last flat filter is Na on-band, not [SII]

Sat Feb 09 21:07:25 2019 EST  jpmorgen@snipe

--> Wondering if my real problem with with MaxImData not surrendering
    its COM object properly when it exits 

Sun Feb 10 19:19:29 2019 EST  jpmorgen@snipe

--> Check pier_flip_sign logic.  I think I want an absolute not
    relative sense

Sun Feb 10 20:51:35 2019 EST  jpmorgen@snipe

Slewing to alpha ari, mag 2 which is on the west side of the meridian
right now (pierside East)

Focus using [SII]
01:56:11  Focus position = 30450  Avg HFD =  4.57  Avg FWHM =  3.73
01:56:11  Temperature: 6.8  Filter: [SII]_6731A_10A_FWHM (slot 2)

Good focus!

02h 08m 15s 23° 33' 11"

<ack, weather became unsafe with gust>
Doing it Ok on this side of the meridian, which I think I saw before.

While waiting for weather to improve, look at side logic.  So for the
Astro-Physics mount, north button actually moves the telescope north
from a non through-the-pole position when the scope is on the west
side pointed east.  The guider pinpoint likes to be WestofPier, not
EastofPier to have the

Now try Sirius
--> disabling autocenter

Hmm.  Seems to be OK!

So the problem may have been concurrent running Python processes,
which is really my lazy programming.

Try another Sirius to see if that is really the issue (though a fresh
start is no different than just starting the first time).  Indeed,
still works.

--> Hints on how to clean up objects

https://stackoverflow.com/questions/865115/how-do-i-correctly-clean-up-a-python-object

ACP-ScriptFail.js (or .vbs) runs when a script failes

Weather safety script at http://solo.dc3.com/ar/ACPRefGuide.html has
an example of creating a FocusMax object and Halting it.

--> put this in
--> Make a separate shell script for calling my stuff, or make
--> client/server out of my stuff.

Sub Main()
    Dim FMX

    On Error Resume Next  ' Call both of these "best efforts" (scope may not be connected, etc.)
    Set FMX = CreateObject("FocusMax.FocusControl")
    FMX.Halt
    Util.WaitForMilliseconds 1000
    Telescope.Park
End Sub
[says that ACP 8 and later stops FocusMax.  Hopefully latest FocusMax obeys]

This is all daytime stuff when I am more awake.

Jupiter rises at 10:16 UT = 5:16
Above 15 at 11:40 UT = 6:40

Mon Feb 11 08:01:21 2019 EST  jpmorgen@snipe

Too humid

http://timgolden.me.uk/pywin32-docs/html/com/win32com/HTML/QuickStartClientCom.html

--> win32com.clients.constants might have the ASCOM and MaxIm
constants I have been loooking for!

C:\ProgramData\Anaconda3\Lib\site-packages\win32com\client\makepy.py

Chose random library

C:\ProgramData\Anaconda3\Lib\site-packages\win32com\client\makepy.py
Generating to C:\Users\jpmorgen\AppData\Local\Temp\gen_py\3.7\CBD71DF4-5AED-11D2-BC74-0060979C3633x0x1x0.py
Building definitions from type library...
Generating...
Importing module

So I should consider doing this for MaxIM

And if I want to grab the code, I think it goes 

python C:\ProgramData\Anaconda3\Lib\site-packages\win32com\client\makepy.py -i
MaxIm Objects
 {B4955EC7-F7F2-11D2-AA9C-444553540000}, lcid=0, major=1, minor=0
 >>> # Use these commands in Python code to auto generate .py support
 >>> from win32com.client import gencache
 >>> gencache.EnsureModule('{B4955EC7-F7F2-11D2-AA9C-444553540000}', 0, 1, 0)

So the gencash prefix is the Guid

Ahh.  So that will generate the cache _at runtime_ so I can distribute
this with the code and then get my constants to work right.


https://groups.google.com/forum/#!topic/comp.lang.python/YUJOEGVJsRs

OK, of more pressing issue  is cleaning up my object

So as soon as the Python object gets set to None, the camera
disconnects.  Having ACP running seems to alleviate this.

Reading more about multiprocessing.  The p.join() seems to be good
form to allow the child process to finish, but it is not necessary to
make the process actually do anything.

So I need to change the design of the GuideBoxCommander system a
little bit.  Maybe it should be an object?  It could even be a whole
separate system of its own?

Keeping it in precisionguide for now, the object sounds good in that
when it is given a

Wait a minute!  I already have a terminate process, which isn't very
nice, but might be a good start.  I would use it with pg.GuideBoxMoving = False

So there may be a solution with with

https://stackoverflow.com/questions/865115/how-do-i-correctly-clean-up-a-python-object

Mon Feb 11 18:38:34 2019 EST  jpmorgen@snipe

Looks like it is working!

So how to I write a plan for Jupiter?

waituntil

--> changed filter names back to having spaces

Tue Feb 12 06:57:42 2019 EST  jpmorgen@snipe

--> Having trouble recognizing when guider is centered to 1/2 pixel

--> This is something I will need to check with the conditions are
    better

--> note ioio.py is being grabbed as IoIO.py!

--> There seems to be a problem with guider_settle

--> Work on guider_settle waiting longer.  Doesn't seem to be waiting 
    guider_settle_cycle times for first calculation

Tue Feb 12 08:35:31 2019 EST  jpmorgen@snipe

Let's try ACP flats with 2-way wheel off.  Also put back spaces in
filter names

--> AutoFlats are going to be a problem unless I do background differently

In AutoFlat.vbs:

        Set P = CreateObject("PinPoint.Plate")
        Call P.AttachFITS(workFile)
        BG = P.SimpleBackgroundMean                              ' Get fast mean background ADU

I would need to tweak that

--> And even when filters only going in one direction (at least on
    ASCOM setup), [SII] on-band is coming up as Na on-band!


python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_IPT_Na_R 1800 "C:\Users\jpmorgen\Documents\ACP Astronomy\Images\20190212\Test1-S012-R001-C001-R.fts"

Tue Feb 12 16:56:54 2019 EST  jpmorgen@snipe

might need to call the Close() method of the MaxIm stuff [no, I don't
think so]

--> CCDCamera.AbortExposure()

Wed Feb 13 18:42:39 2019 EST  jpmorgen@snipe

Moved to do list to later instantiation

Thu Feb 14 13:28:54 2019 EST  jpmorgen@snipe

Hmm.  Scheduler uses a different
/cygdrive/c/Program Files (x86)/ACP Scheduler/AcquireScheduler.vbs

It doesn't seem to have a new AcquireImage user action

Ah HA!  Here is how I can do some checking in user actions

InStr(LCase(IMG.Description), "#nosolve")

Fri Feb 15 12:23:49 2019 EST  jpmorgen@snipe

--> So I am looking at inserting some code just before SUP.TakePicture
in /cygdrive/c/Program Files (x86)/ACP Scheduler/AcquireScheduler.vbs
[maybe near line 1289.  Before would have the guider running even ]

which would do the checking in some sort of description and set up the
PrecisionGuide system.  Based on my experience with restarting the
guider, I definitely want to have the PrecisionGuide system run in the
background so it can smoothly guide between exposures.  So I
definitely need a COM server with a stored global variable, if
possible.

First start with global variable.  Actually, if I am just doing this
in Scheduler, I can just create a global variable there.  I am going
to do something like

P = CreateObject("precisionguide.PrecisionGuide")

http://timgolden.me.uk/pywin32-docs/html/com/win32com/HTML/QuickStartServerCom.html

\\snipe\jpmorgen\py\HelloCOMServer.py
\\snipe\jpmorgen\wsh\HelloCOMClient.js


\\snipe\jpmorgen\py\HelloCOMServer.py --debug

python C:\ProgramData\Anaconda3\Lib\site-packages\win32com\client\combrowse.py

python C:\ProgramData\Anaconda3\Lib\site-packages\win32com\server\win32traceutil.py

Not working but getting some ideas that running as administrator might work

Copy over to Desktop\IoIO\Scripts
cscript HelloCOMClient.js

Might need python 3.6.4
Anaconda2-5.1.0 might have what I want

I have Anaconda3-4.3.1 on IoIO1U1

WORKED!

So this is a bug in Python at the moment.

So it doesn't stay running just by invoking it, but that is because I
don't have an infinite/event loop that would enable that.

So now I need to think about that.  

--> uninstall latest Python and install older Python.  Looks like I
    need to stay with 3.6 for now.

It looks like  I migh tneed to learn about event loops.  They are
designed for asyncio, which I sort of have.  Right now, GuideBoxMover
is a completely independent task that could potentially be moved into
an event loop in the main code?

AbstractEventLoop.call_later(delay, callback, *args)

Would be a good one for waking up the GuideBoxMover

The other thing that needs to happen is centering, which is a one-time
task that really depends on the state of MaxIm

Sat Feb 16 08:23:57 2019 EST  jpmorgen@snipe

Uninstalled latest Python from 2018-12, which hasn't been updated and
installed Anaconda3-4.3.1 on gigabyte

\\snipe\jpmorgen\py\HelloCOMServer.py
cscript \\snipe\jpmorgen\wsh\HelloCOMClient.js

--> Autofocus refused because target within 5 deg of horizon.

--> add another target first!

Lambda oph
RA: 16h 31m 53s Dec: 01° 56' 38"
But I need to use an R-band object 

DEBUG: GUIDER SETTLED TO 0.5 GUIDER PIXELS [__main__]
DEBUG: Saved file: C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190217\Na_off-band_001.fits [precisionguide]

Oops, I thought I fixed that.  I guess I copied over a version that
doesn't have that [yet]

All this time, ACP thinks that it is collecting 1/1s, which I guess is
why it is hard for it to be interruptable

Oops, I had the wrong version of IoIO.py in there with no with.
Stopped just as I was about to start another process.  Fixed (I
hope)...

Oh, that was handy!  Resume plan started me back up where I left off!

Sun Feb 17 15:40:36 2019 EST  jpmorgen@snipe

--> So how do I want to handle shutting down the observatory in this
interim state?  Killing the script at nautical twilight is not that
bad an idea 

Ah Ha!  JUpiter is now going the wrong way.

Disconnect ACP, reconnect

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190218\Jupiter-S001-R001-C001-R.fts"

"attempt to start guiding failed..."

So Bob has really mucked with things somehow.

Indeed, when I restart with just MaxIm, it behaves the way I want.

--> consider re-instituting longer R exposure so I can get Jupiter

Mon Feb 18 12:14:54 2019 EST  jpmorgen@snipe

on gigabyte after mucking with ASCOM. -> win32com.client.constants. change

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190218\Jupiter-S001-R001-C001-R.fts"


python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190218\Jupiter-S001-R001-C001-R.fts"

Seems to be happy so far.

Tue Feb 19 14:45:23 2019 EST  jpmorgen@snipe

GEM: Looking west No Auto Pier Flip -5.139, -3.018, -0.25

GEM looking east, no Auto Pier Flip -5.333, -3.025, -0.231


GEM: Looking west YES Auto Pier Flip -5.586, -3.006, +0.345

GEM: Looking east YES Auto Pier Flip +5.586, -2.994, -0.208

Hmm.  Not what I think

Try guider angle 45 deg on setup camera

GEM: East Looking west YES Auto Pier Flip -5 -3 +44

GEM: West Looking east YES Auto Pier Flip +5 -3 +45

GEM: East Looking west NO Auto Pier Flip -5 -3 +45

GEM: West Looking east NO Auto Pier Flip -5 -3 +45

So the auto pier flip just flips the X axis (or whatever is indicated
in Guider Motor Control).  The flip in guider angle of 180 may have
been from something else, or it may be that the camera really does flip

But based on recent experiments on Feb 12:

east looking west: [AutoPierFlip on, MaxIm reference]

X Speed = -3.426 Y Speed 3.4498, angle -179

west looking east: [AutoPierFlip on, MaxIm flip operating]

X Speed 3.4284 Y Speed -3.384 angle = 1.097

The three cases I have tested, "Right now, the calibration is" from
2018, the one on Feb 21 2019 and the simulator are not consistent in
my brain yet.  However, re-reading the documentation, it is pretty
clear that the X Speed and Y Speed are pixels per second that result
from the X and Y motor motion, presumably assuming square pixels or
otherwise correcting for that.

http://acp.dc3.com/RotatedGuiding.pdf

There is a note that that ACP requires calibration with telescope
looking east, PierFlip off.  And there is also talk of turning 
 PierFlip/GuiderReverseX on when scope is looking east (on west)

This is back from 2007, so things may have changed....

No, it looks like with 8.2, Bob still wants to do things his way....

Bob recommends using CalibrateGuider.vbs

Bob says that MaxIm must be calibrated with scope looking east and
Pier Flip off.  But what does Auto Pier Flip do?  It looks like it
automatically flips X when looking east.  So in Bob's PDF, he admits
he did non-standard but won't change "because it would cause
confusion."

So the question is, can I turn Auto Pier flip back on after
calibration?  Well, maybe, since Bob talks of turning PierFlip on when
scope is looking east.

Tue Feb 19 21:07:23 2019 EST  jpmorgen@snipe

Indeed, I had an ah ha moment: I was going the wrong way the other
night because MaxIm was not attached to apply the pier flip!  I think
that is why Bob doesn't want to have MaxIm attached to the 'scope.

OK, the current logic in precisionguide.MaxIm_pier_flip_state has
Application.TelescopeConnected in the logic mix, so that should fix
the problem.  

        if (self.alignment_mode == win32com.client.constants.algGermanPolar
            and self.Application.TelescopeConnected
            and self.CCDCamera.GuiderAutoPierFlip
            and self.Telescope.SideOfPier == win32com.client.constants.pierWest):
            flip = -1

--> But what if MaxIm is not connected to the telescope?  I should test that.

So we are facing east, scope is on west side of pier.  Turn off Auto
Pier Flip

Main:

RA 07h 46m 24.3s,  Dec +18° 32' 00.1"
Pos Angle +02° 53.5', FL 1196.6 mm, 1.56"/Pixel

Guider:

RA 07h 46m 36.1s,  Dec +18° 30' 52.2"
Pos Angle +359° 06.1', FL 400.7 mm, 4.43"/Pixel

west looking east no auto pier flip:
X Speed -3.403 Y Speed -3.528 Angle = 1.24

Pretty much the same as before, but with X Speed negated, presumably
because the sense of X is not flipped by MaxIm.

So I start tracking without auto pier flip and it works OK.  I do auto
pier flip and it starts to run away in X.  Sigh.

Do a pier flip

With auto pier flip on, runs away.

With auto pier flip off, it runs away.  So there is no way to use
MaxIm guiding with ACP autoguide setup.

Let's double check that.

Disconnect MaxIm and use ACPs scripts. 

03:11:09  Focus position = 30261  Avg HFD =  5.60  Avg FWHM =  4.41
03:11:09  Temperature: 0.5  Filter: R (slot 1)

--> Ah HA moment revisited.  So MaxIm does its guiding based on
AutoPier flip.  If I don't have the telescope connected in MaxIm, it
doesn't know what the pier flip state should be, so I have to handle
that for it!

Calibration failed because scope was not looking east

So Bob calibrated the guider angle to 1.4 and slightly different
speeds, but still -3.4 and -3.5.

So I think I am going to need a separate profile.  Got that.

So now I have a MaxIm indicator of whether or not ACP is involved:
CCDCamera.GuiderAutoPierFlip.  I should also check for MaxIm telescope
connected state: Application.TelescopeConnected.  That would indicate
ACP is in control.

So if I have an ACP in control state, I need to assume I am guiding
with calibration on the west looking east and no pier flip.  I then
have to track the telescope pier state so that I can flip the guider
X.  that would probably be the CCDCamera.GuiderReverseX.

So all I need to do is set CCDCamera.GuiderReverseX = True when I am
on the east side looking west.  I should probably set it to False as
part of the cleanup of precisionguide.

This is going to take some thinking and testing, since the guide stuff
is in MaxImData.  I can also revisit my sign error.

For now, as long as I have MaxIm connected and am using the IoIO MaxIM
Guiding profile in MaxIm, all will be well.

--> Disabled ACP guiding

Ack, the profiles don't save Auto Pier Flip status!  But the Manual
Calibration is saved

Wed Feb 20 14:00:20 2019 EST  jpmorgen@snipe

Looking back at which GuiderPinPointSolution worked best: WestofPier
(looking east).  OK, I now know that is the setup for which
Astro-Physics mounts work as expected: from the equator, N points the
tube toward torward N.  That is the piece I missed.  To confuse
matters more, MaxIm AutoPierFlip operates in this configuration,
except when Bob wants to turn it off....

--> consider replacing MaxIm_pier_flip_state with MaxIm_motor_flip_state

--> how/where to keep track of CCDCamera.GuiderReverseX?  (or whatever
    Bob tweaks)

python \\snipe\jpmorgen\py\IoIO\IoIO.py ACP_status 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190218\Jupiter-S001-R001-C001-R.fts"

Works.

Do a guider cal.  Angle is 44.6, as expected.

GuiderReverseX was False while on west pointed east.  Also false when
pointing west.  Both XY speeds are negative.  GuiderAngle also 44

Even on other side of meridian getting

INFO: GuiderReverseX: False [__main__]
INFO: Xspeed, Yspeed: -4.443930149078369, -4.443930149078369 [__main__]
INFO: GuiderAngle: 44.60260009765625 [__main__]

So I am not sure what Bob is doing

TakePicture is in AcquireSupport.wsc!  So is AutoGuide!

And it doesn't do this logic for the simulator...

                ' Unrotated guider (angle calibrated and constant)...
                ' On west, effect is to reverse Dec motion, which reverses Y, 
                ' combined with the imager being rolled over 180 deg, which 
                ' reverses both X and Y. The net effect is just reverse X 
                ' (reverse Ys cancel out!)... unless the mount does a reverse
                ' Y on flip... in which case we need to re-reverse that too. 
                ' (more brain burning)
                '
                Camera.GuiderReverseX = Util.GEMWestOfPier      ' Reverse X if [looking] west
                If Util.Prefs.AutoGuiding.ReverseYonFlip Then
                    Camera.GuiderReverseY = Util.GEMWestOfPier
                End If
 

So Bob uses GuiderReverseX and does it on the reverse side of MaxIm.
AutoGuide is not called within AcquireSupport.  So my thinking on that
is correct.

So I have guider_start and guider_stop.  Those should probably check
for the pier flip stuff.

And I need some property that determines if I am in need of handling
them.

Do I really need to turn off pier flip?

Wed Feb 20 21:54:55 2019 EST  jpmorgen@snipe

On Rigel which is just to the west of meridian

IoIO.py ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\2019021\Jupiter-S001-R001-C001-R.fts"

Moved Jupiter OK, but guider went off to the right


IoIO.py ACP_status 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\2019021\Jupiter-S001-R001-C001-R.fts"

INFO: GuiderReverseX: True [__main__]
INFO: Xspeed, Yspeed: 3.3900599479675293, 3.3900599479675293 [__main__]
INFO: GuiderAngle: 1.3748899698257446 [__main__]

Oops, I had the MaxIm state on.  Try connecting telescope to see if it
works OK.  Nope, moving the wrong way.  Oops, that might be because I
have guiderReverseX on from before.

So do we want to clear that?  Well, for debugging do so and it works OK.

Pier flip to Sirius.  Moves OK, guides OK!

--> Ack!  Scope DEC is going to be messed up

Load ACP config.  Already Auto Pier Flip is not checked (my angst
about this). [XY]Speed looks OK.  Not connected to anything.

Moving to the right in RA, not to the left

Was down and to the right and wanted to move  [-34.66596838 -21.76758005]

Previously was to the right and wanted to move [-17.61828752   6.30562391]

These are pre-flip printouts

But I am not pier flipping now, so I think it should want to move +34.
So where is the missing pier flip?  Or actually, the guider
calibration was effectively reversed, so I need to apply that to my
motion, but not to the guider

Well, that assumption worked on the east side.  I suspect if I do a
pinpoint solution west of pier for the main, I will even things out...

04:11:55  Focus position = 30347  Avg HFD =  6.91  Avg FWHM =  5.36
04:11:56  Temperature: 0.4  Filter: R (slot 1)

Main West
RA 07h 43m 28.9s,  Dec +05° 11' 14.7"
Pos Angle +02° 44.4', FL 1198.1 mm, 1.56"/Pixel

Going back over to east looking west, Capella
--> check guiding DEC is near 46

But first get guider astrometry east looking west

RA 05h 16m 04.6s,  Dec +46° 02' 35.9"
Pos Angle +178° 58.3', FL 400.7 mm, 4.42"/Pixe

Now try IoIO....

Moved the wrong way!

So I don't need a consistent minus, I just need one when I am on the
west side looking east.  Oh wait, that means I just don't need a pier
flip at all!  

Ah HA!  CCDCamera.GuiderReverseX is not set yet when I check it for my
motion!

So we really need to check for this both when we are starting to guide
and when we are about to move.  So make a method out of it.  Maybe ACP_mode

replace guider_manage_flip with ACP_mode

Ack.  Still went in the wrong direction.

OK, this might be better, since it would give me a full minus for both sides.

I was arguing for the minus because Bob turns off the pier flip and
gets the RA calibration going in the other direction.  OK, this is
starting to gel.  What was working before was
GuiderPinPointSolutionWestofPier.fit.  That 

Hmm.  Now guidebox mover is backward....

So there is a fumdamental sign difference between when the guider is
calibrated on the east looking west (MaxIm) or West looking east (ACP)
and my routines, particularly scope_wcs feel these.

--> This means I need to work on scope_wcs!  Figure out how to do this
    with simulator when I am awake! 


Thu Feb 21 10:34:22 2019 EST  jpmorgen@snipe

Looking at scope_wcs.  I have no idea why the pier_flip_sign is
there.  It makes more sense to change CDELT, but 

            if 'RA' in header['CTYPE1']:
                header['CRVAL1'] = RA / 24*360 * pier_flip_sign
                header['CRVAL2'] = DEC * pier_flip_sign
            elif 'DEC' in header['CTYPE1']:
                header['CRVAL2'] = RA / 24*360 * pier_flip_sign
                header['CRVAL1'] = DEC * pier_flip_sign

Tricky here, since move_with_guide_box is called with dra_ddec, which
has alreday been through scope_wcs

OK, so I need to come up with some tests that work on gigabyte

On east looking west

Brightest star is on the lower right (1503, 1228)

python \\snipe\jpmorgen\py\IoIO\precisionguide.py center

INFO: Seconds to move guider in RA and DEC: [-20.10508303  -5.64066179] [__main__]

So that is in the same sense as the real scope, as if (0,0) is at the
top left.

Interesting.  After failed to center target exit, MaxIm froze.  But on
fresh restart after pier flip did not

Pier flip gives similar seconds to move guider in RA and DEC.  That
has always bugged me and I think it is incorrect.  RA and DEC are both
flipped and if I am in true coordinates, my true dra_ddec should
reflect that.  When I get to doing motion, that is when I figure out
what the scope wants.  In that case, GuiderReverseX or AutoPierFlip
takes care of RA, but I think I need to take care of DEC!

So right now, how does it work?  I have this weird minus sign on RA
and DEC if I have a flip.

West looking east
DEBUG: world coordinates of obj_center and desired_center: array([[-298.21254273,  -29.43216061],
[-298.30211075,  -29.45571522]]) [__main__]

East looking west

DEBUG: world coordinates of obj_center and desired_center: array([[ 284.95007883,   32.74325672],
       [ 284.8573623 ,   32.71968646]]) [__main__]

OK, so that is proof that I am totally out of whack here.  

West looking east dra
-298.21254273 - (-298.30211075)
0.08956802000000152

West looking east ddec
-29.43216061 - (-29.45571522)
0.023554609999997922

East looking west dra
284.95007883 - 284.8573623
0.09271653000001834

East looking west ddec
32.74325672 - 32.71968646
0.02357025999999962

But had I not done anything:

298.21254273 - (298.30211075)
-0.08956802000000152

29.43216061 - (29.45571522)
-0.023554609999997922

So this was a tricky way of flipping both coordinates without dealing
with the cdelts, even though I don't think I knew what I was doing!

East looking west looks same
West looking east now looks more sensible, but the  seconds to move
guider in RA and DEC are now negated!

DEBUG: Object center (X, Y; binned) = (1503, 1228) [__main__]
DEBUG: world coordinates of obj_center and desired_center: array([[ 321.28409865,   36.55662902],
       [ 321.38121654,   36.58018134]]) [__main__]
DEBUG: CENTERING TARGET WITH GUIDER SLEWS [__main__]
DEBUG: IN GUIDER_MOVE [__main__]
INFO: Seconds to move guider in RA and DEC: [ 23.24465173   5.63712109] [__main__]
DEBUG: GuiderReverseX set to False [__main__]
DEBUG: Guider DEC set to 37 [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]

OK, so now we need to really determine which way is up!

For that we have the guider speed and the knowledge of which side of
the pier they were calibrated on.

I already have self.calculated_guide_rates, but I do it with abs and
then don't use it anywhere.  What if I preserved sign and used it.

So I have Guider[XY]Speed in pixels/s of guider motor motion,
presumably assuming square pixels.  I calculate that into guide_rates,
which is in deg/s

I was really close to doing this correctly with guider_cal_pier_side

West looking east

WARNING: Calculated RA guide rate is off by more than 10% (scope reported, calculated): (0.004178074616551509, 0.0068473464135742294).  Have you specified the correct guider astrometery image?  Have you changed the guide rates changed since calibrating the guider?  Assuming reported telescope guide rates are correct. [__main__]
WARNING: Calculated DEC guide rate is off by more than 10% (scope reported, calculated): (0.004178074616551509, -0.0010688369820278432).  Have you specified the correct guider astrometery image?  Have you changed the guide rates changed since calibrating the guider?  Assuming reported telescope guide rates are correct. [__main__]

East looking west

WARNING: Calculated RA guide rate is off by more than 10% (scope reported, calculated): (0.004178074616551509, 0.0068473464135742294).  Have you specified the correct guider astrometery image?  Have you changed the guide rates changed since calibrating the guider?  Assuming reported telescope guide rates are correct. [__main__]
WARNING: Calculated DEC guide rate is off by more than 10% (scope reported, calculated): (0.004178074616551509, -0.0010688369820278432).  Have you specified the correct guider astrometery image?  Have you changed the guide rates changed since calibrating the guider?  Assuming reported telescope guide rates are correct. [__main__]

Note both XSpeed and YSpeed are negative, but the RA guide rate comes
out positive because +RA is to the east (left on the sky)

Moving forward, I have self.guider_cal_pier_side and
self.calculated_guide_rates as my new standards

East looking west

INFO: Seconds to move guider in RA and DEC: [ 24.12814855   5.63688234] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [ 14.72237549 -22.03452482] [__main__]

Difference in absolute values is difference of guider speed from mount
vs simulated value.  Difference in DEC sign suggests a flip

West looking east

INFO: Seconds to move guider in RA and DEC: [-24.0991814  -5.6419528] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-14.70470048  22.05434521] [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-14.70470048  22.05434521] [__main__]

Keep in mind I am already flipping the old RA and DEC movement due to
absolute dra_ddec calculations.  The final answer I am looking for is
minus and minus as input to a final pier flip.

Oops, the above was with AutoPierFlip on.  Also may make a difference if
I use the hub or not how the pier flip works!

ACP mode
East looking west
X Speed -4.443 Y Speed -3.014 Angle = 44

INFO: Seconds to move guider in RA and DEC: [-28.59928052  -5.64301926] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-17.45054519  22.058514  ] [__main__]
DEBUG: GuiderReverseX set to True [__main__]
DEBUG: Guider DEC set to 49 [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [ 17.45054519 -22.058514  ] [__main__]
DEBUG: GuiderReverseX set to True [__main__]
DEBUG: Guider DEC set to 49 [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]

West looking east (ACP's calibration)

INFO: Seconds to move guider in RA and DEC: [ 28.58563401   5.63582481] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [ 17.44221844 -22.03039094] [__main__]
DEBUG: GuiderReverseX set to False [__main__]
DEBUG: Guider DEC set to 49 [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [ 17.44221844 -22.03039094] [__main__]
DEBUG: GuiderReverseX set to False [__main__]
DEBUG: Guider DEC set to 49 [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]

So when the picture remains the same but when the mount flips, we
rightfully flip absolute dra_ddec.  The guider command remains the
same regardless of pier flip.  I am used to seeing a star in the same
position in the guider and being able to press the N/S buttons without
respect to flip to get the star back where it belongs.  This is what
we have here and it goes in the same sense that previous motion has
(minus moves up).  RA looks like it might be backward.  Normally by the time I
see "Seconds to move guider" it looks negative.  But we are in ACP
mode, so that might be the reason.

MaxIm mode
East looking west (MaxIm's calibration)
X Speed +3.443 Y Speed -3.014 Angle = 44 [+4.443 was too large]

INFO: Seconds to move guider in RA and DEC: [-28.59928052  -5.64301926] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-17.45054519  22.058514  ] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-17.45054519  22.058514  ] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]

West looking east

INFO: Seconds to move guider in RA and DEC: [ 28.58563401   5.63582481] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [ 17.44221844 -22.03039094] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-17.44221844  22.03039094] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]

So they are flipped.  What do we expect?

Maybe we need to change the 

Oops.  I have the guider angle to contend with in a way I may not be
expecting.  By using the mounts guider_rates, I was getting
perpendicular motion.  By using the guide angle, I am foreshortening
that.

So the guider rate of 4:3 is interesting, but I don't see it telling
me about pixel size.  They seem pretty square.

OK, so I need to rethink this.  XSpeed and YSpeed are mount motion in
pixel coordinates.  GuiderAngle is the orientation of the guide camera
with respect to the mount.  I can get GuiderAngle with better accuracy
from PinPoint solutions.  And the mount knows its guide rates.  This
is how I did it before.  What I have been lacking is knowledge of
which way north really is and on what side.  For that, we can just 

Ah Ha.  I need to know north/south in cal but also the pier side it
was on at that time.  Also use CROTA1

CROTA1 in Guider WestofPier = 8.16320904052E-001
CROTA1 in Guider EastofPier =  1.02909934506E+000

Oops, I really do need to look at the CDELT

East
CDELT1  	= 1.22916298234E-003 / [deg/pixel] X-axis plate scale                 
CROTA1  	= 1.02909934506E+000 / [deg] Roll angle wrt X-axis                    
CTYPE2  	= 'DEC--TAN'           / Y-axis coordinate type                         
CRVAL2  	= 4.60432944960E+001 / Y-axis coordinate value                        
CRPIX2  	= 2.90000000000E+002 / Y-axis reference pixel                         
CDELT2  	= 1.18662982061E-003 / [deg/pixel] Y-Axis Plate scale                 

West
CDELT1  	= -1.22944067206E-003 / [deg/pixel] X-axis plate scale                 
CROTA1  	= 8.16320904052E-001 / [deg] Roll angle wrt X-axis                    
CTYPE2  	= 'DEC--TAN'           / Y-axis coordinate type                         
CRVAL2  	= 1.81555203362E+001 / Y-axis coordinate value                        
CRPIX2  	= 2.90000000000E+002 / Y-axis reference pixel                         
CDELT2  	= -1.18722362974E-003 / [deg/pixel] Y-Axis Plate scale                 

OK, worked on some diagnositcs, but I am still wondering if I can grep
absolute north out of the guider calibration.  I don't know the camera
angle a priori.  I could do a thought experiment or maybe some
simulation experiments.  One possible reason that north ends up being
up-side-down on my mount is that the mount runs the DEC axis the other
way relative to other mounts.

Oh, wait a minute, their Y always goes down.  I guess you would expect
that if you had north up.  When you press north, the star goes down

Try a 180 calibration

GEM: East Looking west No Auto Pier Flip -5, -3, 180

GEM West looking east, no Auto Pier Flip -5, -3, 180

GEM: East Looking west YES Auto Pier Flip 5 -3 -180

GEM: West Looking east YES Auto Pier Flip -5 -3 -180

But I am not seeing the camera really rotate, hence the fact that the
angle stays at 180.  The auto pierflip is what flips the XSpeed sign.

But it is a good sign that both MaxIm and

Think about calibration of plane camera on GEM: E, N

East side looking west right and down

West side looking east, left and down

OK, so based on the buttons and the L, you can tell what the flips and
angles are and therefore believe the camera angle.   And it all boils
down to the E/W.  Hence the 180 camera angle case has the opposite
signs of Guider X Speed.

Ultimately, I want to make sure I am pressing the correct button when
I want to go north.  If I trust guider calibration camera angle, it is
telling me which direction is N on the CCD.  I can grep the same thing
out of the astrometry.  The key thing the guider calibration doesn't
give me is which side of the pier it was on.  That I can get from the
astrometry

So if I want to emulate IoIO, I need to have the guider calibration
agree

west looking east: [AutoPierFlip on, MaxIm flip operating], no camera rotation
X Speed 4 Y Speed -3 angle = -0.2

Whew!  Finally getting negative and negative, as per expected.  This
came out as a opposite pier, presumably because I was using a west of
pier looking east astrometry

Same side gives undesired +Y.  Also not getting same absolute  RA and
DEC.  Oh, that might be a problem!  Getting positive

Pinpoint Same side of guider calibration (Pier east, looking west)
Scope is Pier west looking east, pier flip state, auto pier flip is on

DEBUG: pinpoint_N_is_up = 1 [__main__]
INFO: Seconds to move guider in RA and DEC: [-22.50423895  -5.64150908] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-10.80269058  -6.79256445] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [ 10.80269058  -6.79256445] [__main__]
D

Flip to pier east looking west (no pier flip)

INFO: Seconds to move guider in RA and DEC: [-24.76281224  -5.64212361] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-11.88687159  -6.79330437] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-11.88687159  -6.79330437] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
D

Pinpoint Opposite side of guider calibration (Pier West looking east)
Scope is Pier west looking east, pier flip state, auto pier flip is on

DEBUG: pinpoint_N_is_up = -1 [__main__]
INFO: Seconds to move guider in RA and DEC: [ 23.28643556   5.63710945] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [ 15.28119533   6.77433184] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-15.28119533  -6.77433184] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]

pier east looking west (no pier flip)

INFO: Seconds to move guider in RA and DEC: [-24.76281224  -5.64212361] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-16.25003405  -6.78035755] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-16.25003405   6.78035755] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]

So this is all messed up.  In absolute terms, dra_ddec should flip
between pier flips

I think I understand the reason absolute rates are changing a little:
scope_wcs and the cdelts

Hey!  Are we going through this too many times?  Don't seem to be

Pinpoint Opposite side of guider calibration (Pier West looking east)
Scope is Pier west looking east, pier flip state, auto pier flip is on

Scope is Pier west looking east, pier flip state, auto pier flip is on

DEBUG: forcing pinpoint_N_is_up = 1 [__main__]
DEBUG: self.calculated_guide_rates: array([ 0.00636681,  0.00347669]) [__main__]
DEBUG: pier_flip_sign: -1 [__main__]
DEBUG: world coordinates of obj_center and desired_center: array([[ 154.52251258,   42.79189526],
       [ 154.62882584,   42.81544519]]) [__main__]
INFO: Seconds to move guider in RA and DEC: [ 26.54961238   5.63628529] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [ 17.42258112   6.77334141] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-17.42258112   6.77334141] [__main__]

pier east looking west (no pier flip)

DEBUG: forcing pinpoint_N_is_up = 1 [__main__]
DEBUG: self.calculated_guide_rates: array([ 0.00636681,  0.00347669]) [__main__]
DEBUG: pier_flip_sign: 1 [__main__]
DEBUG: world coordinates of obj_center and desired_center: array([[ 102.4501471 ,   41.08716901],
       [ 102.34668622,   41.0635958 ]]) [__main__]
INFO: Seconds to move guider in RA and DEC: [-24.76281224  -5.64212361] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-16.25003405  -6.78035755] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-16.25003405  -6.78035755] [__main__]

Going back to what I expect.  Negative, negative is what I expect,
since I have to bring the star up & that doesn't change with pier
flip.  And when I have pier flip X on, I command MaxIm and it flips is back

Am I not understanding the effect of tweaking CDELTs on multiple coordinates?

Looking at the pattern: OK = no pier flip, same side cal and opposite w/pier flip
And the sense of RA and DEC minus error is flipped between the others

Pinpoint Same side of guider calibration (Pier east, looking west)
Scope is Pier west looking east, pier flip state, auto pier flip is on

WARNING: forcing pinpoint_N_is_up = 1 [__main__]
WARNING: pier_flip_sign forced to: 1 [__main__]
INFO: Seconds to move guider in RA and DEC: [-21.87996696  -5.64131725] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-21.87996696  -5.64131725] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [ 21.87996696  -5.64131725] [__main__]

pier east looking west (no pier flip)

WARNING: forcing pinpoint_N_is_up = 1 [__main__]
WARNING: pier_flip_sign forced to: 1 [__main__]
INFO: Seconds to move guider in RA and DEC: [-22.4905105  -5.641505 ] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-22.4905105  -5.641505 ] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-22.4905105  -5.641505 ] [__main__]

Pinpoint Opposite side of guider calibration (Pier West looking east)
Scope is Pier west looking east, pier flip state, auto pier flip is on

WARNING: forcing pinpoint_N_is_up = 1 [__main__]
WARNING: pier_flip_sign forced to: 1 [__main__]
INFO: Seconds to move guider in RA and DEC: [-21.87996696  -5.64131725] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-21.87996696  -5.64131725] [__main__]
DEBUG: MaxIm_pier_flip_state = -1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [ 21.87996696  -5.64131725] [__main__]

pier east looking west (no pier flip)

WARNING: forcing pinpoint_N_is_up = 1 [__main__]
WARNING: pier_flip_sign forced to: 1 [__main__]
INFO: Seconds to move guider in RA and DEC: [-25.44992557  -5.64229422] [__main__]
INFO: Seconds to move guider in absolute RA and DEC: [-25.44992557  -5.64229422] [__main__]
DEBUG: MaxIm_pier_flip_state = 1 [__main__]
INFO: Seconds to command MaxIm to move guider in RA and DEC: [-25.44992557  -5.64229422] [__main__]

Well, how 'bout that!  It looks like if I get rid of all the flips, I
get the right answer!

Ah HA!  It is the main camera that needs the flip

Fri Feb 22 11:02:21 2019 EST  jpmorgen@snipe

So main East of pier looking west was what worked as expected.  That
happens to be the normal up state of the mount for what it is worth.
It is also the up state of the camera up, which agrees with the
guider.

Consider doing flip _before_ going in

Whew!  That seems to work.  The next brave frontier is to flip
everything

--> first check into revision control

OK, I see where the issue may be.  guider_move goes straight from
dra_ddec, not pixel coordinates, so it doesn't get re-flipped.  So if
we do a coordinate flip in scope_wcs, we need to do it back in
guider_move.  In that case, we need to have our own flip property that
is relative to our preferred calibration direction.

Before I get into that, check the move_with_guide_box.  That uses
scope_wcs to change back to guider pixel coordinates.  So if I am
doing flipping in scope_wcs, I would not need to do anything special
for that.

But how is AutoPierFlip handled there?  Not sure.  I am moving the
position of the guide box, so it is not clear why it was backward with
Bob's pier flip issues, other than that I was having my own!

OK, thinking more about cameras not being oriented in a cardinal
direction.

It is important that the astrometry for the main and guide cameras be
on the same side of the pier (now that I am not flipping anything).

But other than that, their relative angles can be anything.

So if we have gotten things so that the north button goes north in
guider, even if the main camera is up-side-down relative to that, the
astrometry will tell us

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center 1000 1000

Fri Feb 22 23:16:55 2019 EST  jpmorgen@snipe

Whew!  Got guider_move to work OK.  Next up is center with guide box.

Sat Feb 23 12:03:42 2019 EST  jpmorgen@snipe

Hope that will work since I flip twice.

How can I test guiding?

DEBUG: Object center (X, Y; binned) = (1503, 1228) [__main__]

python \\snipe\jpmorgen\py\IoIO\precisionguide.py center 1503 1228

Do COM server for a bit.  Util.Script is where

// Use Util.Script.xxx to access AcquireImages/AcquireScheduler globals, etc.

What does that really mean?

Sat Feb 23 22:13:19 2019 EST  jpmorgen@snipe

Doing some tests and finally getting things to work OK with my test
code set up properly.  

Recalibrated guider
Telescope connected, Pier Flip on, east looking west (not MaxIm flipped)
X Speed -5.217 Y Speed -2.994 Angle -0.357

Ahh!  Auto pier flip isn;t going to work because the camera actually
doesn't flip!

So I need to test this live

Oops, I overwrote ioio.py.safe with IoIO.py.  Well, I have copies of
everything

rsync IoIO and precisionguide over

"C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190224\Aldebaran-S001-R001-C001-R.fts"

Worked east side pointing west, standard MaxIm guiding

West side pointing east is going the wrong way.

--> Oops, had a double negative bug in code for ACP_mode.  Check this
    during day

Oops, humidity too high!  Star was really starting to cloud over.  86%
So maybe 75% is not that bad....

Wed Feb 27 13:02:58 2019 EST  jpmorgen@snipe

Testing Util.Script.test_global.  Seems to work in a single plan run,
but when I abort a plan, the global goes away, presumably because the
AcquireSupport is finished.  I was hoping the global could stick
around in ACP somehow, but that would probably invovle actually
programming the guts of ACP.

So to go with the current reality, in plain old ACP, I would need to
have everything in a plan that had access to a single run of
PrecisionGuide.  This is reasonable, since I would do that anyway.
Single target, lots of filters and exposures.  I could even have
different targets in the plan, like the 10 degree offsets I was
thinking of.

--> I could use Target End and look for no next to do a graceful
    shutdown of the object

Take a look at
/cygdrive/c/Program Files (x86)/ACP Scheduler/AcquireScheduler.vbs
line 836 for some code about OBS.Description

More looking at AcquireScheduler.vbs and find "'Announce start of run"
Looks like this is a target-oriented thing because of when
SUP.UserActions.TargetEnd is called.

--> Bob assumes offset tracking (non-sidereal tracking) can't be on
    when autoguiding is on, so I would have to turn the guider off in
    TargetEnd

So in Scheduler, it goes

User
Project
   . Plan [this is where priority is set,
     	  use Best Efforts so plan runs until constraint fails]
      . Observation [effectively an ACP Target, can do Repeat Count]
         . ImageSet [all of the exposures]

So a plan might have many observations, like Jupiter and 10 degree
offsets or just one, like a comet, or maybe comet center and offsets

Eventually I could have a comet project which would contain all the
comet plans.  This might be handy because I could copy plans within a
project and just edit the ephemeris.  But can I enter Jupiter?  Yes!

OK, recalling how Aspasia all night worked.  I had a plan with many
observations and the observations had "Time from previous" = 300 and
time spacing tol = 60.  But the plan dominated all the time.  There
was no way to interleave any other plan from any other project.  To
interleave, I had to make a project that had many plans.  Each of
those plans had observations with large repeat counts (because of
short exposures).

So for Jupiter, I want a project with at least one plan, presumably
called Jupiter.  In that Plan I need at least one Observation of
Jupiter.  In the Observation I need at least one Image Set.
Currently, my image set looks something like

[check center]
R
Na_off
Na_on
repeat of 5
    [check center]
    SII_on
    SII_off

When I expand the filter wheel I would add U and V and maybe UV and B

I would also like to add the +/- 10 deg points --> Maybe those should
be standards near Jupiter.  But those would have to be in separate
Observations, since they are pointed somewhere else.  But it makes
sense to have them in the same Plan so they get executed at the right
time, either right before or, if I move them to the very end, right
after the Na obesrvations.

Ah AH!  I could have the offsets go first, since at least one of them
is going to be above the 5 degree horizon autofocus limit.

OK, new plan might be

Offset W 10 deg These can be special Jupiter commands with offset in Description
Offset E 10 deg Run these as a separate Observation or Plan
Offset N 10 deg
Offset S 10 deg

Na_on			5
Na_off			1
Repeat 2 or 3		12 or 18
    SII_on
    SII_off
R
V
B
U			5
UV			10
short exposures
   SII_on
   Na_on
   SII_off
   Na_off		1
Repeat 2 or 3		12 or 18
    SII_on
    SII_off
			46 or 58


--> conisder a general offset UserActions command

Hmm.  The offsets would have to be long exposures + I would not want
them to take too much time away from the IPT.  I really just want to
do them once at local midnight, or if worse comes to worse, just once
when Jupiter is at a certain airmass.  Maybe I should do them once per
side of sky.  So I can take hour angle ranges to make that work plus
avoid mount flips!  They could be separate high priority plans that
would then interleave effectively with the drone of the normal observations

So how do I get the periodic centering to work?  Ideally I do a closed
loop on what comes in, but I worry about filter offsets

--> I can check in the reduction to see if those are real at this
    point.

I could have a simple timer that would check and recenter with guider moves

Thu Feb 28 06:22:03 2019 EST  jpmorgen@snipe

--> Now Io seems to be going north in move_with_guidebox

--> Looking at logic in move_with_guide_box and seeing that some
update may be necessary with new understanding of coordinate flips

This is a problem for telescope on oppostite side of astrometry (west
looking east)

At least it centers it on the ND filter, but just high

So it is easy to see the move is coming in negative Y in pixels when it
should be positive Y to move the box down

So I should be able to test this out with the simulator pretty easily


I use to_world in both center and move_with_guide_box.  In center, it
is using astrometry_from = None, which defaults to main.  That
establishes a dw_coords which works in guider_move, but requires a
full flip of both axes through astrometry_pier_flip_state logic,
because absolute astrometry is flipped relative to camera axes when
the camera is flipped across the pier, but for the guider buttons to
bring the relative position of the star back, only E/W is flipped, so
we flip it again just on E/W

Move_with_guide_box takes the same dra_ddec that guider_move does, so
at some level, with respect to the scene in the guider camera, it
needs to be negated on pier flip.  Where I think this shouldn't matter
is that I also do the flip of the current guide box position.  So that
comes out at a both-axes-negated 


guider_move actually pushes the buttons for relative motion that only
flips E/W, which is why I need to 

when we are on the guider, world coodinates are similarly flipped
relative to the center of the CCD, though I don't calculate that relative

Thu Feb 28 17:37:23 2019 EST  jpmorgen@snipe

Print some debugging statements with new logic

normal pointing state (east looking west)

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center 1503 1228

No difference, since this is the real center


python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center 1500 1226

So that seems to be resulting in the negative, negative that we want,
since we are specifying a desired center that is at smaller
coordinates.  Now pier flip

Here is where I have had trouble getting the guider to work.  Turn off
Auto Pier Flip and it seemed to be happier.  We are on the west
looking east, which is where ACP wants to be calibrated, so we don't
pier flip.  

Looks like we are getting minus minus on both sides of the pier.  So
somehow this new solution should work, though I don't understand why.

Yeah, I really expect there to be some sort of pier flip thing showing
up.  In the case of guider_move, we were pressing buttons that MaxIm
had reversed.

Thu Feb 28 20:38:09 2019 EST  jpmorgen@snipe

Back to the issue of making Scheduler work with PrecisionGuide.  So
each Observation is going to be a pointing at Jupiter.  It will start
PrecisionGuide and do an initial center.  I can have a timer in
PrecisionGuide to check for elapse time and maybe neighbor filters so
that centering happens when I want it.

--> Consider collecting a separate log file of center motions

Thu Feb 28 22:17:21 2019 EST  jpmorgen@snipe

Doing some testing at night of latest PrecisionGuide stuff.

On Betelguse which is east looking west


python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190228\Jupiter-S001-R001-C001-R.fts"

Worked

Try Procyon

Focus was really bad

03:36:32  31794, 09.88, 1025, 988, 298195, 5020,  1, 07.88
03:36:32  Focus position = 31794  Avg HFD =  7.93  Avg FWHM =  6.27

Try again to see if it uses move_with_guide_box

Still too well centered!  See if I can move guide box by hand +3 pixels
in X

Filter is twitchy!

Reporting need to move in minus X!

WORKED!

Mon Mar 04 05:47:49 2019 EST  jpmorgen@snipe

!! Need to select a calibration star that is farther west

Moving Jupiter with guide slews in the wrong direction

We are west looking east.  Should be natural ACP calibration, no flip
needed, but X is going the wrong way.

Looks like, as one might expect, if guider is calibrated the reverse
of the previous value, all guider slews have to be reversed

But that begs the question: why was it correct for MaxIm?

--> Figure this out and document it in MaxIm_pier_flip_state.
    Possibly rename this function to reflect a more absolute sense
    --> Take out ACP flip in calling code

--> Ooops, cooler may have been off

--> Consider doing full guider direction logic in __init__ since I
    think I know it at this point.  When testing, keep in mind
    commanded direction is backward from what I expect for west
    looking east

Wed Mar 06 09:02:29 2019 EST  jpmorgen@snipe

--> APCC is still kept running by something.  Probably the Python
    connection?

Wed Mar 06 13:00:57 2019 EST  jpmorgen@snipe

If I wanted to take care of APCC connection to Python, I could
potentially do MaxImData as a with, but that is not exactly what I
want.  __del__ might be better

--> generally clean up memory, links, etc.

https://stackoverflow.com/questions/40536821/python-enter-exit-vs-init-or-new-del

__del__ is called when all references are removed and might not get
called depending on the order in which things are deleted.  Worry
about this later

As far as the direction of RA motors go, that is something that
surprised me, though it shouldn't have.  West looking east like Bob
wants it results in the opposite sign.  So it looks like I get some
sort of absolute E/W too!

So N is clearly pushed, but then is it W or E?

East looking west has CDELT[12]

WAIT A MINUTE!  PA is position angle, which is the same thing as
camera angle, so CROTA[12] is not necessarily needed and my hack with 

https://fits.gsfc.nasa.gov/standard40/fits_standard40aa-le.pdf

PA is not an official WCS and CROTA is depreciated

CDi_j are the new way to do CROTA.  They are a linear transformation
matrix (with scale) to go from pixel axis j to intermediate coordinate
axis i.  It might be easier to just use their transformations

proj_plane_pixel_scales(wcs).  This is in astropy.wcs.utils, or just
do the full thing

GuiderPinPointSolutionEastofPier.fit

has positive CDELT values

Thu Mar 07 06:36:35 2019 EST  jpmorgen@snipe

Ack!  PA shows reminds me that Y is negative compared to what I think
of in MaxIm (0,0 at top left, not bottom left)

--> how does this affect all my thinking?

Thu Mar 07 07:23:43 2019 EST  jpmorgen@snipe

Calibration on pier flip goes right left, down up, resulting in
East pointing west (normal state, pier flip or not)
minus minus

West pointing East no pier flip
right left, down up (minus minus)

Pier flip
right left, down up (plus minus)

So I can guess the  +X = west for normal pointing state

So before I re-read the documentaton and get re-confused let me write
down where I think I am know.

I see the star move to the right, toward +X during calibration.  The
result is a -X speed.  Assuming calibration is telling us the
_response_ of the buttons, then +X must be E, _assuming_ a N up E left
camera orientation.  I certainly know that N is up, since I set the
camera angle to that.

Since MaxIm has Y starting at the top, N up means _decreasing_ Y, so
measuring the _response_, it makes sense that we get negative Y when N
is pressed.

OK, so the new info, which I think I tried unsuccessfully to grep out
of the documentation before is that +X is actually E.  And I have been
getting confused as to which direction is up because +Y is down.  I
was confused about whether [XY]speed was to move star back to where it
belonged, or the speed measured for motor push.  I now see it is the
latter.  As a result, I had enough minus signs to add up to a positive
plus I ignored another one.  Best to start over with good
documentation in populate_object

Thu Mar 07 16:25:53 2019 EST  jpmorgen@snipe

Saved reduction directory off to /data/io/IoIO/NO_BACKUP/reduced.previous_versions/Morgenthaler_et_al_201901_ApJL

ReduceCorObs.py reduce --tree --movie

--> for reduction, I need to figure out how to deal with autoflat

no [SII] images are found

Problem is [SII] is now called SII.  I could just intercept that at
get_filt_name and convert [SII] to SII, since I think it will work
just as well

--> need to change ND_params_dir, though I don't think I am using
    ND_params_tree any more

So get_filt_name is the abstraction layer that lets me feed a general
name and come back with the actual filter name.  So it would stand to
reason I would want to tolerate [SII] as an input as well as SII

OTOH, I use statements like
if '[SII]' in OnBandObsData.header['FILTER']:

which get me into trouble

ReduceCorObs.py reduce --directory /data/io/IoIO/raw/20190306

collection = ccdproc.ImageFileCollection('/data/io/IoIO/raw/20190306')
filt_names = collection.values('filter')#, unique=True)
filt_names = list(set(filt_names))
line_assoc = [la for la in line_associations if line in la['line']]

get_filt_name(collection, line='[SII]', band='ON')

Got it to run.  Average per file 0.68s.  This is after doing memory
interleaving in BIOS [but there were more calibration files, so I
think this is biased to a lower value]

ReduceCorObs.py movie /data/io/IoIO/reduced/20190306

WORKED!

ReduceCorObs.py reduce --tree --movie

Interestingly, it is going through all the old files that didn't work,
but not writing any since they don't work

Fri Mar 08 10:50:17 2019 EST  jpmorgen@snipe

GuiderAutoPierFlip is something I can use to check or turn on the
AutoPierFlip box

--> Hey, GuiderNewMeasurement is how I want to check for guider new
    measurement, not the way I am doing it!

Fri Mar 08 14:55:23 2019 EST  jpmorgen@snipe

Back to  pier flip stuff.  MaxIm standardizes to pierEast and flips
for pierWest.  So I expect a flip if calibration happens to fall on
pierWest.  But for pierEast, I am not sure.  For ACP, pierWest should
be non-flipped and I have to manage the flip myself on the for pierEast

So I want to have some sort of state variable that tells me what side
of pier I need to pier flip on.  self.pier_flip_on_side seems like a
good name for that.  MaxIm already does pier flip on 

Sat Mar 09 05:15:02 2019 EST  jpmorgen@snipe

-->  Getting move with guidebox fail on second move, maybe in guidebox mover
'2019-03-09 10:13:45,235', '__main__', 'DEBUG', 'move_with_guide_box: old, bad guider dpix (X, Y): [  -2.7597519 -159.5059903]'

Seems tp be working now, but this is the same bug I saw before

--> consider cleaning up get_HDUList, since that is the only thing
    holding open precisionguide across platforms

Mon Mar 11 20:23:23 2019 EDT  jpmorgen@snipe

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/20190306 

Tue Mar 12 16:57:39 2019 EDT  jpmorgen@snipe

Ack!  E and W and N and S could be attached to wherever the user
wants, so all my trials of pier flipping are somewhat in vain

Hmm.  Reading the MaxIm documentation and seeing that I am setting things up
to be pretty specific to ASCOM Direct.  Control via Telescope Control
requires MaxIm's Observatory Control to be connected to the telescope,
which is a no-no for ACP.  This suggests that when Bob turns on the
guider, he tweaks it himself. 

--> Long term, it looks like I am going to have to integrate with ACP
    guiding to support multiple setups

Wed Mar 13 13:55:52 2019 EDT  jpmorgen@snipe

Thinking about making check_guider_rates the right way.  Can I
incorporate the code I am using for determining directions?  Probably,
since I am just interested in absolute value

OK, instead of going 1 arcmin, I should go a prescribed amount of time
* guiderXSpeed 


On PSIScope random locations

CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   2.80195133471E+002 / X-axis coordinate value
CRPIX1  =   1.37500000000E+003 / X-axis reference pixel
CDELT1  =   3.79880748802E-004 / [deg/pixel] X-axis plate scale
CROTA1  =   3.00279928042E+000 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   2.10750572556E-002 / Y-axis coordinate value
CRPIX2  =   1.10000000000E+003 / Y-axis reference pixel
CDELT2  =  -3.79813696704E-004 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   3.00279928042E+000 / [deg] Roll angle wrt Y-axis

CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   3.25235161849E+002 / X-axis coordinate value
CRPIX1  =   1.37500000000E+003 / X-axis reference pixel
CDELT1  =   3.79860503864E-004 / [deg/pixel] X-axis plate scale
CROTA1  =   3.02318045891E+000 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   4.50063375789E-001 / Y-axis coordinate value
CRPIX2  =   1.10000000000E+003 / Y-axis reference pixel
CDELT2  =  -3.79619226848E-004 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   3.02318045891E+000 / [deg] Roll angle wrt Y-axis

CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   1.21337432907E+002 / X-axis coordinate value
CRPIX1  =   1.37500000000E+003 / X-axis reference pixel
CDELT1  =  -3.79718113486E-004 / [deg/pixel] X-axis plate scale
CROTA1  =  -1.04308112188E+001 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   2.94533460285E+001 / Y-axis coordinate value
CRPIX2  =   1.10000000000E+003 / Y-axis reference pixel
CDELT2  =   3.79684174965E-004 / [deg/pixel] Y-Axis Plate scale
CROTA2  =  -1.04308112188E+001 / [deg] Roll angle wrt Y-axis

So wi th CRVAL2 = DEC at two drastically different values, CDELT2 is
the same and is the same as CDELT1 modulo sign.

Wed Mar 13 22:13:28 2019 EDT  jpmorgen@snipe

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center

Getting a little confused by all the detailed guider stuff now.
Possibly because of a flip error somewhere.

In ACP mode, I am calibrating on pierWest and getting -3, -3, 0 for X
Speed, Y Speed and Angle

Presumably if we flip to pierEast and did a MaxIm calibration, we
would get +3, -3, 180

Simulator:
+4, -3, 180 pierWest (pier flip)

Want to get that on pierEast, but I get
-4, -3, 180 pierEast

So just try putting it in by hand.  That seemed to work!

OK, now go to move_with_guide_box

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center 1500 1226

--> somehow, when I am flipping guider astrometry, I am also flipping
    something I shouldn't, since sense of ACP vs MaxIm mode switches.
    In other words, motor reversals are detected that shouldn't be
    there.

Is it the CD[1..9]*_?

GuiderPinPointSolutionEastofPier.fit

CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   7.90190538984E+001 / X-axis coordinate value
CRPIX1  =   3.76000000000E+002 / X-axis reference pixel
CDELT1  =   1.22916298234E-003 / [deg/pixel] X-axis plate scale
CROTA1  =   1.02909934506E+000 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   4.60432944960E+001 / Y-axis coordinate value
CRPIX2  =   2.90000000000E+002 / Y-axis reference pixel
CDELT2  =   1.18662982061E-003 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   1.02909934506E+000 / [deg] Roll angle wrt Y-axis
CD1_1   =   1.22896472141E-003 / Change in RA---TAN along X-Axis
CD1_2   =  -2.13121162536E-005 / Change in RA---TAN along Y-Axis
CD2_1   =   2.20760206085E-005 / Change in DEC--TAN along X-Axis
CD2_2   =   1.18643842017E-003 / Change in DEC--TAN along Y-Axis

CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   1.98277220537E+002 / X-axis coordinate value
CRPIX1  =   3.76000000000E+002 / X-axis reference pixel
CDELT1  =  -1.22944067206E-003 / [deg/pixel] X-axis plate scale
CROTA1  =   8.16320904052E-001 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   1.81555203362E+001 / Y-axis coordinate value
CRPIX2  =   2.90000000000E+002 / Y-axis reference pixel
CDELT2  =  -1.18722362974E-003 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   8.16320904052E-001 / [deg] Roll angle wrt Y-axis
CD1_1   =  -1.22931589154E-003 / Change in RA---TAN along X-Axis
CD1_2   =   1.69143816006E-005 / Change in RA---TAN along Y-Axis
CD2_1   =  -1.75158480353E-005 / Change in DEC--TAN along X-Axis
CD2_2   =  -1.18710313398E-003 / Change in DEC--TAN along Y-Axis

Other than very small numbers for CD1_2 and CD2_1, everything I expect
to be negated is

<sigh> I can even print out the astrometry header before and after I
pier flip it and things are negated.

Ah Ha!  I am using aang from a previous orientation

FIXED!  OK.  That is ACP mode, with -3.39 -3.5, 0

Try flipping to MaxIm mode by changing to +3.  Oops, that is where I
was. <sigh>

Wait a minute ACP mode for real is -3.39 -3.5, 1.3748.  And ACP for
real is calibrated on the WEST side of the pier (with no MaxIm pier
flip).

So the N angle is not working the way I expect.

Fixed that.  Problem was negative Y in MaxIm

Now I am getting GUuiderReverseX being set unexpectedly,
admittedly I am tweaking the guider without resetting MaxIm.  No, it
is actaully working correctly.  I am flipping on the correct side of
the pier!

Still it would be great to test, but the weather is crummy.

Hmm.  I think I am missing a pier flip when I calibrate on pierWest
for MaxIm


python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1800 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190314\Jupiter-S001-R001-C001-R.fts"

Thu Mar 14 01:43:31 2019 EDT  jpmorgen@snipe

!! Shock of all shocks!  It worked, at least on pierWest.  Worked on
   pierEast!


Thu Mar 14 07:13:37 2019 EDT  jpmorgen@snipe

Well, my script worked, but for some reason, ACP is not shelling out
properly.  This has happened before after a Windows upgrade and i got
it to work by just re-running it.  But now a re-run just does the same thing

Hmm..  The first problem was a wait in limits which then did a slew
that was below the configured observatory horizons.  That sounds like
a Bob problem 

The next problem was that UserActions recognized a tag, but didn't
execute the code, like it didn't recognize the tag value.

It may be time to update ACP on the observatory computer....

Looks like move_with_guidebox is working OK!

Thu Mar 14 07:39:36 2019 EDT  jpmorgen@snipe

Maybe that Disable auto-center is my problem for the target below
horizon, though that shouldn't matter.  Uncheck that anyway, since I
want more accurate centers and I am done testing for now

--> it might also be a refraction thing in the model.  Either Bob does
    this or APCC, not both

Think about rebooting before upgrading

Fri Mar 15 05:51:44 2019 EDT  jpmorgen@snipe

--> failure to close APCC seems to be my script still connected

I think I would like to change MaxImData to MaxImControl and abbrviate
it as MC

Next up is thinking about integrating with Scheduler.

if not pg:
    load pg however that is done, using the proper ObsData and module call
    
pg.center_loop or maybe some other center thing that has a time limit.
My paranoia here is the on and off-band for a given line should be on
the same side of a center_loop call.

Ultimately, I am thinking that subclassing all of precisionguide to
ioio might be the right thing to do.  That way I could tweak things
for the filters rather than having an ugly interleave.  This would
also solve some of the ugly interleave problems I have been having
with precision guide and its command line parameters

Right now I have create_ObsData and the ObsDataClass property of
precision guide, which is a pretty ugly hack.  If I have
precisionguide deal with the simplest ObsData and a subsequent subclass
of precisionguide could be something like cor_guide.  cor_guide could
have the CorObsData overwrite ObsData in the definition such that the
name CorObsData goes away.  I would like to have RedCorObsData be for
reduction, so ultimately it would be nice to have all three names and
then some.

Go back to create_ObsData.  That is a hack in the sense that it deals
with a variety of arguments - either passed explicitly, stored in the
object at init time or no args.  This is reasonable, so not that hacky

It is self.ObsDataClass that is a little more hacky.  The dynamic part
is the hack.  Really if I have a different way to get the center, I am
finding that I should build the whole precision guide system around
that.  In other words, build a subclass of precisionguide instead of
insert an important object into precisionguide

As far as names go for the ObsData, it looks like I can name them
different things, but then I am back to the hacky method of referring
to them.  But based on the number of upvotes of
https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string,
I am not the only one thinking in these terms.  So I could have
different versions of precisionguide and to insert different names for
the ObsData I would still need to have the sort of hacky way to get
the vlaue of the ObsDataClass inserted into the PrecisionGuide class.

Wait a minute, I don't think it would be hacky at all.  I can have
ObsData and its subclasses as separate modules.  I can import the one
I want and then when it comes time to define it in my code

class ObsData(ObsDataIWant):
    pass

Then I have ObsDataBaseClass which has the minimum stuff in it and
then different ObsData with more descriptive names about what they do,
like CorObsData, BrightestPointObsData, BrightestStarObsData,
PinPointObsData.  The latter of these would take the desired RA and
DEC of the desired center, run PinPoint on the image and return the
pixel of the desired center.  So those could all be inherited on their
own line.  The precisionguide line would have a
PrecisionGuideBaseClass in the precisionguide base module.  Other
modules could be named cor_guide, pinpoint_guide, etc. and would be
create children of PrecisionGuideBaseClass.

The only possible disadvantage of all of this is that the WCS stuff
would need to be different.  But that is probably not a bad thing
because the arguments would need to be different too.

Sat Mar 16 06:19:23 2019 EDT  jpmorgen@snipe

--> I need to catch all crashes and make sure the error is reported to
the astropy log

Sun Mar 17 08:34:27 2019 EDT  jpmorgen@snipe

Hmm.  APCC didn't exit even though my scripts didn't run

Mon Mar 18 14:52:41 2019 EDT  jpmorgen@snipe

Go back to trying to make scheduler work for IoIO.  In
/cygdrive/c/Program Files (x86)/ACP Scheduler/AcquireScheduler.vbs
near line 1289 is where I was thinking of doing it before.  But I see
that for some reason, Bob does the AutoFlipIf _after_ guiding has been
set up.  He turns guiding back on in that code, but the problem with
this is I don't get to tweak it.  So I need to call my code after
AutoFlipIf on line 1345.  The one on line 1596 is after the image is
recorded and is a safety in case new updated coordinates are on the
other side of a flip.

/cygdrive/c/Program Files (x86)/ACP Obs
Control/Scripts/AcquireImages.js has the ability to return OK, which
allows things to continue as if nothing happened, even though I may
have lined up the guider the way I want.  THere is some code that
mentions guiding right below UserAction.AcquireImage, but that would
not be executed if I am not guiding with ACP's guiding, or if I am
guiding with it and the guider is running OK, it would be fine.

Hmm.  Next set of code seems to be a hurtle as well....  but if I have
orbital tracking rates, it would seem to be skipped.  But what even if
I am not orbital tracking, it sets up curAG, which a boolean that is
True if ACP should autoguide.  Then it checks to see if SUP.Guiding.

So the question is, how does SUP.Guiding work?  Do I have to use
SUP.AutoGuide to get it to work?

Because I may be able to pass SUP as an object to my Python script, it
may not matter, but it would be nice if I didn't have to deal with
it.  I can certainly write some test code to check.

To review, I have determined that it may be possible to be gentler
with the ACP non-scheduler AcquireImages.js if I do the guiding stuff
and just return OK.  ACP would then take the picture.  I might have to
use ACP's guiding stuff for at least part of the logic, but that
might not be the end of the world since I would get cool stuff like
the web-based guiding image and graph

Hey, I can answer this question by looking at AcquireSupport.wsc,
which I can display in vbscript-mode....  Looks like Bob just uses
MaxIm Camera stuff!  and GuiderNewMeasurement, like I should!

So this is potentially really cool!  It means I might be able to have
the drop-in UserAction.AcquireImage that, when doing the picture
taking, gets all the guiding display stuff.

The only thing is, I need to have it in AcquireScheduler.vbs.  Doing
it right is a think for Bob.  For me, I think I can just call out to
my same (updated) user action script and make sure that returning OK
will work.

Feature request: AcquireImage User Action in AcquireScheduler

Hi Bob,

First of all, thanks for phone chat about this issue when you were
feverishly quashing the last few bugs in preparation for the 8.2
release.

Since that time, I have done a little more research into the issue and
find that I may be able to get more mileage out of the "AcquireImage"
User Action than I had previously thought possible: It looks like if I
use AcquireImage to turn on and tweak the guider myself to precisely
position my target where it needs to be in the focal plane, and then
return True, ACP (1) does all the work of taking the pictures I want
and (2) does not turn off or otherwise tweak the guider until I need
to move away from my target, even if the target is being tracked
non-sidereally.  It was thinking your code turned the non-sidereal later issue and the expectation that if I
did anything in my


The problem I am facing now is that AcquireScheduler does not
implement the "AcquireImage" User Action and I would really like to
use Scheduler so I can get the most out of the system.

Is implementing the "AcquireImage" User Action in Scheduler something
you can do?  Based on my read of the code, it would go after the
AutoFlipIf on line 1345 of AcquireScheduler.vbs.

Thanks for considering it.

Why this might have general interest is that the system I use to solve
my high precision pointing problems can be expanded to do non-sidereal
_guiding_ and correct for differential flexure between a bore-site
mounted (external) guide scope and the main scope (whether or not you
are guiding non-sidereally).  It works by making a closed-loop guiding
system by inspecting main camera images and using the relative
astrometry solutions of the main and guide camera systems to instruct
the guider to make the appropriate adjustments.  Large adjustments are
made before the guider is started by pressing the guider slew buttons
(MaxIm's CCDCamera.GuiderMove).  Small adjustments are made after the
guider is started by moving the guide star position.

So here is what I do:

(1) Point the telescope at Jupiter

(1a) Position Jupiter in the main camera image to extremely high
precision on a focal plane that contains something that looks a little
like a spectrograph slit but is really a coronagraph (some background
info and a movie are at http://www.psi.edu/news/iosodium and
https://www.psi.edu/sites/default/files/ftp/Na_SII_best_0.mp4)

(2) Auto-focus every hour, making sure to avoid the central
obstruction (FocusMax Script Mapping makes programming a jog to the
side possible)

(3) Record calibration images of standard stars through various
filters -- some of them long enough to require guiding -- making sure
to avoid central obstruction (ACP TargetStart User Action makes
programming a coordinate offset easy)

(4) A couple times per night, point 10 degrees away from Jupiter E, W,
N and S to record background images (another job for TargetStart &
some hour angle constrain to avoid the meridian for my GEM)

(5) Point the telescope at whatever else is interesting to me (e.g.,
comets, asteriods, extrasolar planets) when Jupiter is down.

(6) Do all of this with Scheduler so I can maximize time on the sky,
sleep at night and analyze data during the day


Well, all that is nice, but I think I should implement it myself to
see if it works the way I think.  Then I can ask for the feature for
a future release.

OK, so what stands in the way of this and what I have been
procrastinating is pulling apart all my code to implement cor_guide
and friends.  Ultimately, this will clean up the reduction and
analysis stuff, so now is a good time to do it.


python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 90 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190410\Jupiter-S001-R001-C001-R.fts"


Mon Apr 01 14:44:26 2019 MST  jpmorgen@byted

--> I need to connect to the focuser in my ACP scripts!

Sun Apr 07 20:44:18 2019 EDT  jpmorgen@snipe

TODO:

. Check see if I can use WAITINLIMITS for an offset

. Offset Jupiter initially then bring it in with script -- avoid
problems with Jupiter in FOV

. Incorportate weather into precisionguide so that it quits too

. remember where the ADU2R change really came from (not change in
on-band guiding accuracy if memory serves!)  Oh, maybe ADU2R _and_
OFFSCALE changed

. When I use stellar calibration, make sure to take into account
Jupiter distance!

. spot bad files by off-band 25 Rj aperture being much above 0

. --> finish testing satellite calibration exposure times

. --> weather safety abort

. Work on flats center of gravity idea

. Consider finishing context management with ObsData

. Figure out why APCC is not exiting even though it has just one
client left --> it is guidebox_mover.  Do a better job with the whole
context block system

. Check good centers before I do ephemeris requests to avoid excessive
HORIZONS calls.  Bummer I don't write that, but made that decision
before I had confidence in the center finding stuff.  COnsider
buffering headers in reduction scheme

. Figure out how to deal with date directories and ACP when combining
movies.  http://solo.dc3.com/comctr/filecust.htm shows ACP only
outputs YYYYMMDD, MaxIm does YYYY-MM-DD.  Probably need a file with
the date, or just a routine that sorts the date directories, since
they are all output that way (thus far).  Make that able to do
backward and forwrad and date range

. uninstall latest Python and install older Python just downloaded

. Python COM server

. Find global variable location in ACP

. Background-subtract [SII] off-band with Na off-band to see if we can
live with one off-band filter

. investigate multiprocessing, threading or coroutines as a way to get
precisionguide to do more than one thing at once

    . Let ACP make call even when guidebox system is running (not too
    hard?)

    . Have ACP send signal to stop and/or quit

    . expose and then wait for exposure to end or an abort signal to
    come through

    . display info on status

. Fix guider calibration astrometry parity issues

. Make a separate PSIScope user (or whatever) for non-Io observations

. Implement run_level_default_ND_params as a function of time

--> figure out where focus is failing [check that I have fixed this]

. fix motor reversal on different connection states (currently MaxIm
  has to be disconnected from telescope in AutoFlip state)

--> consider optical design change to see if that is why filter looks bad

. have guide filter wheel go back to clear when precisionguide
finishes?

. Catch errors so can __exit__ gracefully in all cases, including
timeouts

. Consider how much of ACP I am doing

. Improve filter wait times

X fix failure to find guide star by selecting lower filter number.
Was timing issue, I think

/ Install latest ACP 
  . Report sky flat bug

Fri Apr 12 15:00:58 2019 EDT  jpmorgen@snipe

Start to reduce latest batch.  Do I have the latest run-level flats?
I don't think so

ReduceCorObs.py ND_params /data/io/IoIO/raw/20190407/AutoFlat
[[1.40749551e-02 2.36320869e-02]
 [1.24240593e+03 1.33789081e+03]]

ReduceCorObs.py reduce --movie --directory /data/io/IoIO/raw/20190411

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/20190411

--> implement binning

Sat Apr 13 04:53:08 2019 EDT  jpmorgen@snipe

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 990 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190413\Jupiter-S001-R001-C001-R.fts"

--> consider that too manny stars might be hard for current center
    finding alogrithm

--> Debug binning.  The problem is actually in checking
        while not self.CCDCamera.ImageReady:

Sat Apr 13 12:26:51 2019 EDT  jpmorgen@snipe

ReduceCorObs.py reduce --tree --movie

WARNING:py.warnings:/usr/lib/python3/dist-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result.
  return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval

https://github.com/scipy/scipy/issues/9086

Says it is fixed with scipy 1.2.0:



This is probably from my use of signal.find_peaks_cwt in IoIO.py


WARNING: Bad movie in /data/io/IoIO/reduced/20190411 [__main__]
WARNING:astropy:Bad movie in /data/io/IoIO/reduced/20190411
WARNING: Bad movie in /data/io/IoIO/reduced/20190413 [__main__]

Sat Apr 13 17:23:47 2019 EDT  jpmorgen@snipe

What is wrong with the movies?

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/20190407

Ahh, focus is really horrible in on-band

Sigh.  3/23/2019 is about the last usable one.  Everything since then
is unusable

ReduceCorObs.py movie --recalculate /data/io/IoIO/reduced/20190411

ReduceCorObs.py movie --recalculate --tree

oops, I meant

ReduceCorObs.py movie --concatenate

But I am finding the error I saw before.  The problem is if there are
no good images in the directory.  I am not handling that exception well.

Sun Apr 14 07:03:42 2019 EDT  jpmorgen@snipe

I think I may be making process on the guider failure.  The complaint
is that the star is less than 16 pixels from the edge of the FOV.  But
the guider does not actually take a picture.  It is using the previous
picture.  So it is probably a timing issue in waiting for the guider
to acquire its first image.  Fix that

Sun Apr 14 16:35:23 2019 EDT  jpmorgen@snipe

OK, so the problem I am having with bad focus might be fixed by using
a fixed number for the offscale

[SII] OFFSCALE is really bad, worse than Na

But during May and June 2018, it looks like it ran consistenyly around
1.11 with a spread of about 0.05.

Hmm.  I am seeing Na differently now.  [SII] should have had the same
OFFSCALE 20% spread if it was guiding.  It has a lot more variability
per night, but it is systematically more consistent.

So the other thing that was changing in 2018 April-May was that I was
starting to do temperature compensation.  I would focus on SII_on.
SII_off was -30

108.6 - (-242.4) # Na_on
351.0
108.6 - (-220.6) # Na_off
329.2

So that is a pretty significant defocus.  Not sure if the slightly
larger defocus of Na_on would make a difference.  It actually goes the
wrong way, since I argued that Na_on was fuzzier before April.  What
can we argue from defocus in general?

So I need to see if I can salvage any of the data from this year.  I
could do this by setting a constant offscale and then having a
measured offscale as a quality indicator

Tested new CCDCamera.GuiderRunning code:

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center 1500 1226

Want to get to the bottom of reversal problem

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center

ReduceCorObs.py reduce --movie --directory /data/io/IoIO/raw/20190415

having a hard time finding offending directory

ReduceCorObs.py reduce --movie --tree --num_processes 1


                             f-band_004.fits [__main__]
ERROR:astropy:could not broadcast input array from shape (0) into shape (212) skipping /data/io/IoIO/raw/20190414/SII_on-band_004.fits /data/io/IoIO/raw/20190414/SII_off-band_004.fits


self.back_obj

ReduceCorObs.py reduce --recalculate --movie --num_processes 1 --directory /data/io/IoIO/raw/20190411

Thu Apr 18 11:48:24 2019 EDT  jpmorgen@snipe

ReduceCorObs.py reduce /data/io/IoIO/raw/20190411/Na_on-band_001.fits /data/io/IoIO/raw/20190411/Na_off-band_001.fits

Fixed error of not adding center


--> I might need to set the run-level defaults by date as well

ReduceCorObs.py reduce --tree --movie

  File "/home/jpmorgen/py/IoIO/IoIO.py", line 610, in ND_params
    = im[ypt_top+rowpt, left:right]
IndexError: index 1540 is out of bounds for axis 0 with size 1540

ReduceCorObs.py reduce --recalculate --movie --num_processes 1 --directory /data/io/IoIO/raw/20190415

Probably the 14th after all

ReduceCorObs.py reduce --recalculate --movie --num_processes 1 --directory /data/io/IoIO/raw/20190414

ERROR: can only concatenate str (not "NoneType") to str skipping movie for /data/io/IoIO/raw/20190414 [__main__]

--> Another error!

Wondering if I have the SII_on and SII_off reversed

ReduceCorObs.py reduce --recalculate --movie --num_processes 1 --directory /data/io/IoIO/raw/20190413

ERROR: can only concatenate str (not "NoneType") to str skipping movie for /data/io/IoIO/raw/20190413 [__main__]

OK, fix that one first...

Got zeroed out movie OK

But now I need to 

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/20190414

try 15th and 16th.

There is definitely something funny going on.  The 16th should have a
torus but has a negative torus

On-band Na is definitely more blobby with scattered light.  But I
think that was tried both ways this year and it doesn't seem to make a
difference.

I think the problem I am having is OFFBAND.

But lets see first if I can find the torus in an SII_on image!

I do see the torus in an on-band image

One thing I am noticing is that the quality of the image on the ND
filter is not that great right now.  It may be that I have not focused
properly.  It may be that I need to focus on the left side of the
image instead of the right

atv, '/data/io/IoIO/reduced/20190416/SII_on-band_010r.fits

But I thought I did that....  I seem to recall spending an extra
effort getting that to 1 pixel sharpness.

In any case, it looks like the center is getting messed up and that is
possibly messing up OFFSCALE.  I had wanted to work on that anyway.

I do see a torus in '/data/io/IoIO/reduced/20190416/SII_on-band_010r.fits

it is just that the rest of the image is pretty crummy

Hmm.  Does moving the camera back necessitate changing the ND filter
size?  I shouldn't because that is determined by the telecsope focal
plane.

It really does look much more out of focus right now than what I left it.

It was already out of focus on 20190405

--> check any joints for loosening

This is about the same out of focus for park 4 and Jupiter

So what do I want to do for the [SII] analysis?

. Better Jupiter center (this will help some of this year's bad data)

. satellite X Y positions

. Aperture tool that _measures_ optocenter of ansas


python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 10 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190419\Jupiter-S001-R001-C001-R.fts"

Fri Apr 19 09:29:28 2019 EDT  jpmorgen@snipe

--> Ah Ha!  There is a problem!  The initial guider start doesn't have
    the pier flip in the right direction

--> Adjust guider rates by pixel size ratio?

'2019-04-19 07:49:03,305', 'precisionguide', 'DEBUG', 'MaxIm is not managing pier flip...'
'2019-04-19 07:49:03,311', 'precisionguide', 'DEBUG', '... flip detected...'
'2019-04-19 07:49:03,313', 'precisionguide', 'DEBUG', 'CCDCamera.GuiderReverseXY = (True, False)'
'2019-04-19 07:49:03,317', 'precisionguide', 'DEBUG', 'MaxIm is not connected to the telescope, so inspecting GuiderReverseXY...'
'2019-04-19 07:49:03,319', 'precisionguide', 'DEBUG', '... GuiderReverseX is set'
'2019-04-19 07:49:03,322', 'precisionguide', 'DEBUG', 'Motor reversal state = array([-1,  1])'

--> large move
'2019-04-19 08:00:45,026', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-2.59518613  1.88088789]'
'2019-04-19 08:00:45,027', 'precisionguide', 'DEBUG', 'norm_dp: 3.20511003317'

--> only collected 2 SIIs early on

Ah Ha!  Centering with Guider slews if I am within 5 pixels, the flip
logic is not triggered

I think I need a:

self.set_guider_motor_reverse_and_DEC()

somewhere.  I did but forgot to have the ()!

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/20190419

OK, torus is still blanked out.  Maybe it is too bright?

--> check NP angle

atv, '/data/io/IoIO/reduced/20190419/SII_on-band_005r.fits

So the problem is that chop needs to change for some reason
--> Looks like the OFFSCALE is too low this year

Indeed, it is 1 for this day

Fri Apr 19 17:15:59 2019 EDT  jpmorgen@snipe

--> I think this whole thing will get better when I get better centers
    for Jupiter

Well, it really does work better if I use the 5x5 on the cente rof
Jupiter.  For some reason, SII background is just a lot brighter

atv, '/data/io/IoIO/reduced/20190419/SII_on-band_005r.fits
atv, '/data/io/IoIO/reduced/2018-05-18/SII_on-band_010r.fits

There is a little bit of a positive bias to the off-band subtracted
image this year

And the noise in the data are much larger this year
 +/- 200 max last year

+/- 2000 this year.  It is almost as if I am missing a factor of 10
somewhere.

Bias levels are different, but the T = -15 in May, I can do to -20 now

I suppose it could be ral variations from stars shifted a bit?

Sun Apr 21 05:14:40 2019 EDT  jpmorgen@snipe

Traceback (most recent call last):
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\precisionguide.py", line 3302, in <module>
    args.func(args)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\precisionguide.py", line 3142, in GuideBoxMover
    rates_list = json.loads(com.read())
  File "C:\ProgramData\Anaconda3\lib\json\__init__.py", line 354, in loads
INFO: Guide box rate: 2019-04-21T09:11:27.360(UTC) [0.0, 0.0] [precisionguide]
    return _default_decoder.decode(s)
  File "C:\ProgramData\Anaconda3\lib\json\decoder.py", line 339, in decode
INFO: Collecting V, U, and R [IoIO]
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "C:\ProgramData\Anaconda3\lib\json\decoder.py", line 357, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
D

Mon Apr 22 05:29:00 2019 EDT  jpmorgen@snipe

Failed possibly because of clouds or Jupiter being nearby
--> need those catches!

DEBUG: Let MaxIm manage pier flip state: it is connected to the telescope and Auto Pier Flip is on. [precisionguide]
Traceback (most recent call last):
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py", line 1124, in <module>
    args.func(args)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py", line 924, in ACP_IPT_Na_R
    P.MC.guider_start(filter=3)
  File "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\precisionguide.py", line 1779, in guider_start
    raise EnvironmentError('Attempt to start guiding failed.  Guider configured correctly?')
OSError: Attempt to start guiding failed.  Guider configured correctly?


Looks like guider image failed -- there was nothing there -- image was
all zeros.  Possible MaxIm startup issue with filter wheel?

--> Possible timing issue again?  Need to have a catch that kicks like
    I did -- I took a regular image with the guide camera

45 minutes right now


--> add catch to all of ACP_stuff & possibly to Guide start

turn off access through separate thread [done]

Tue Apr 23 15:03:05 2019 EDT  jpmorgen@snipe

Looks like I use the same logic with GuiderAutoSelectStar,
GuiderExpose and all that that Bob does in
/cygdrive/c/Program Files (x86)/ACP Obs Control/AcquireSupport.wsc
So I think that means the error I have been having has to do with
either the separate threading, which I have turned off in both cameras
(not sure I needed it in guider) or the filter wheel timing issues,
which I have hopefully fixed by setting the wait time to 30s

Before I completely re-arange my code to the latest pythonic
structure, I want to work a little on ReduceCorObs.py ephemerides.
sat_X and sat_Y are the things I want for each satellite.  I need this
for each image.

Currently, I ask for the Jupiter NPole_ang in reduce_dir and in
reduce_pair.

It is more efficient to query a list of epochs, so I should keep that
in the reduce_dir code.  But I should probably pull the code out to
its own subroutine

So reduce_pair really needs an ephemeris object input, maybe a
dictionary, that I can generate with

Wed Apr 24 12:18:41 2019 EDT  jpmorgen@snipe

Refreshing my memory on reduciton scheme.  ReduceDir is what does the work

Within that, reduce_dir(self) has the code that makes the
on_off_pairs.  But I don't check to see if the pairs have Jupiter in them

It looks like jup = Horizons(id=...) returns an object that doesn't do
anything until you call jup.ephemerides().

I am rounding to the nearest JD for Jupiter.  With the new full query
by astrometry, I think I will need to re-do all the queries to
HORIZONS, but just once.

https://en.wikipedia.org/wiki/Horizontal_coordinate_system
Note that the above considerations are strictly speaking true for the geometric horizon only. That is, the horizon as it would appear for an observer at sea level on a perfectly smooth Earth without an atmosphere. In practice, the apparent horizon has a slight negative altitude due to the curvature of Earth, the value of which gets more negative as the observer ascends higher above sea level. In addition, atmospheric refraction causes celestial objects very close to the horizon to appear about half a degree higher than they would if there were no atmosphere.

Wed Apr 24 15:55:47 2019 EDT  jpmorgen@snipe

So with the HORIZONS stuff, I need to get Jupiter and each of the four
satellites for each exposure.

sometimes
OBJECT  = 'Jupiter '
OBJECT  = 'IPT     '
OBJECT  = 'Na      '
OBJECT  = 'Na_IPT  '
OBJECT  = 'Na_IPT_R'
OBJECT  = '        '

All MaxIm telescope connected images have
OBJCTRA = '13 02 34' /          Nominal Right Ascension of center of image      OBJCTDEC= '-04 56 13' /         Nominal Declination of center of image          OBJCTALT= ' 53.0080' /          Nominal altitude of center of image             OBJCTAZ = '177.8102' /          Nominal azimuth of center of image              OBJCTHA = ' -0.0882' /          Nominal hour angle of center of image           

Bob puts these things in plus if there is an astrometric solution, RA and DEC

OBJECT  = '        ' is the most painful, but the ones that have no
OBJCTRA are certainly recorded by ACP_IPT_Na_R
The ones with OBJCTRA can be compared to a quick calculation of
Jupiter's RA and DEC

Wed Apr 24 19:53:00 2019 EDT  jpmorgen@snipe

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/20190424

--> This is pausing.  Not sure why.  

Thu Apr 25 04:15:53 2019 EDT  jpmorgen@snipe

--> Best solution is for UpdateEphemeris to take a time argument

Jupiter alt is first column
18 '2019-04-25 07:25:31,147', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.79855284  0.61107432]'
19 '2019-04-25 07:36:01,724', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.38791843  1.55364797]'
22 '2019-04-25 07:55:19,933', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.81187688  0.46951262]'
27 '2019-04-25 08:30:04,327', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-1.13502302  0.89928309]'
29 '2019-04-25 08:48:51,524', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.2680752  -1.26936867]'
30 '2019-04-25 09:00:32,584', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.89061986 -0.56043549]'
30'2019-04-25 09:01:24,382', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.71259768 -0.74756338]'
32 '2019-04-25 09:20:09,554', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.55830345 -0.74880316]'
35 '2019-04-25 10:18:58,803', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.19377229 -1.22796793]'
35 '2019-04-25 10:29:49,852', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.00295894 -0.98630829]'
35 '2019-04-25 11:07:12,948', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.45760597 -1.17472971]'
34 '2019-04-25 11:26:32,367', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.84620009 -1.16530135]'
33 '2019-04-25 11:54:37,188', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.94122021 -0.73663555]'

Guider is 4.43"/Pixel, so our movements are typically a max of

1.2 * 4.43 # arcsec
5.316

in ~20 minutes.  Or a max of 

1.5 * 4.43 / (20*60) # arcsec/sec
0.0055375

1.5 * 4.43 / (20/60) # arcsec/hour
19.935

back to guider pix to compare to previous years

1.5 / (20*60) # pix/sec
0.00125
0.0125 # pix/10 sec

So that is within the realm of where I was doing corrections in the
past, but just barely

Make it a little on the slow side

1 / (20*60) # pix/sec
0.0008333333333333334
0.008333333333333334

call it 0.010.

Thu Apr 25 14:42:20 2019 EDT  jpmorgen@snipe

Whew!  Got get_dirs up and running.  Now on to something like
"is_jupiter" 

This would be used by ReduceDir.reduce_dir().  I would feed it a list
of all the files in the directory and determine which ones are Jupiter
--> update the OBJECT keyword to reflect Jupiter
This is now going to have some U, V and R files as well, which I can
do bias subtraction on, but which I am not prepared to do anything
else.  Note these will have poor centers, though cross-correlating may
fix this.

ReduceDir.reduce_dir() has a collection and summary_table which might
make if_jupiter easier.

--> Ah Ha!  If I restrict myself to 2018, I don't need to worry about
    if_jupiter quite yet.

19 '2019-04-26 07:31:07,336', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.78569616  1.86634647]'
25 '2019-04-26 08:15:58,268', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.65140744  0.92150863]'
29 '2019-04-26 08:43:43,105', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.07834445 -1.11017025]'
31 '2019-04-26 09:04:46,671', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.2794705  -1.92090952]'
34 '2019-04-26 09:54:16,767', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.62451494 -1.03641919]'
35 '2019-04-26 10:13:11,279', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.11087296 -1.46333113]'
35 '2019-04-26 10:52:16,673', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.24743107 -1.05657617]'
35 '2019-04-26 11:14:55,700', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 1.37367415 -0.17719617]'
35 '2019-04-26 11:15:32,955', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.53203669 -0.74965815]'
34 '2019-04-26 11:25:21,130', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.91471169 -0.10925151]'


After             dec_pix_rate = -0.010/10 * plate_ratio


'2019-04-29 07:07:46,527', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.61705685  1.43587035]'
'2019-04-29 07:09:38,533', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01235891 -0.11714305]'
'2019-04-29 07:11:30,667', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01232776 -0.11684821]'
'2019-04-29 07:13:22,230', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01227257 -0.11632496]'
'2019-04-29 07:15:14,702', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01236353 -0.11718757]'
....
'2019-04-29 07:18:27,766', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.31636239  1.84877267]'
...
'2019-04-29 07:25:18,727', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01228087 -0.11640935]'
...
'2019-04-29 07:28:44,810', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.04703182  1.36665628]'
...
'2019-04-29 07:38:46,829', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.80128193  0.69369392]'
...
'2019-04-29 07:49:24,832', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01229487 -0.11655342]'
...
'2019-04-29 08:04:12,149', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.08876755  1.04181059]'
...
'2019-04-29 08:15:41,544', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01227348 -0.11635073]'
...
'2019-04-29 08:49:55,169', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.29992981 -0.13244343]'
...
'2019-04-29 09:32:06,178', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01228697 -0.11648837]'
...
'2019-04-29 09:43:39,052', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.73293954 -1.13151686]'
...
'2019-04-29 09:51:39,200', '__main__', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.01226435 -0.11628187]'
...
'2019-04-29 10:05:49,738', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-1.4182493  -0.73902071]'
'2019-04-29 10:16:49,331', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-0.91255781 -0.28934517]'
'2019-04-29 10:17:34,902', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [ 0.85670599  0.88713037]'

Do we need to flip the sign?  Or just make it slower?  Was getting -1.
Now getting +1.  So it was going down and we had to pull it up.
-0.010/10 pulled it up too fast by a factor of 2

Fri Apr 26 07:51:45 2019 EDT  jpmorgen@snipe

Hmm.  Even after 5 minute wait still has 5 clients connected to AP V2
driver. :-(

Bias looks pretty good even though there is dawn in the air

But during biases went down to 4 clients!  And shut down gracefully!

Fri Apr 26 10:04:19 2019 EDT  jpmorgen@snipe

Thinking I could avoid is_jupiter, but that would mess up the graceful
astroquery stuff

So if I do is_jupiter on a header, I get a boolean answer.  If I do
is_jupiter on a collection, I get a list answer

Fri Apr 26 13:08:48 2019 EDT  jpmorgen@snipe

Looks like I can have a list representing times

Fri Apr 26 15:01:33 2019 EDT  jpmorgen@snipe

Whew!  Finished is_jupiter.

Looking at ReduceDir.reduce_dir and thinking the best place to put
that is just after the background stuff.  Hmm.  Or maybe before.  At
the moment, I am ignoring all calibration objects like stars, but it
would be handy to prepare for that in this.

So how does this collection.summary thing work?  It looks like it
makes a line where each line is sort of like a FITS header

Ack.  Don't have interoperability between FITS headers and
ccdproc.ImageFileCollection

Hmm.  This is causing problems.  Masking works at the column level,
but I am having trouble at the row level.  And I am wondering if I
want to make an iterator out of this rather than do all the work at
once, which is slow....

Nevertheless, I think I have to make it work on one at a time.  The
iterator is an object that just does that at the command of the

So rows have no masks but the table as a whole does.  Ah Ha!  I needed
to use if objctra is np.ma.masked.

OK, that seems to be happy.  How am I going to use it?  I want to
create a list of valid Jupiter observation TMIDs to send to HORIZONS

Fri Apr 26 22:51:21 2019 EDT  jpmorgen@snipe

So maybe I should do all my work with the summary_table.  I could
change the OBJECT names from the various ones I used to Jupiter and
fill in the blanks for the ones that I am sure are Jupiter.  Then I
can call the HORIZONS stuff selecting for OBJECT=Jupiter and using an
off-the calculation of TMID.

Sun Apr 28 19:28:28 2019 EDT  jpmorgen@snipe

Look on todays date for info in IoIO.notebk for precise IoIO_1
coordinates.

How do I convey these to astroquery?  I can enter it naturally enough
as 

statue_of_liberty = {'lon': -74.0466891,
                     'lat': 40.6892534,
                     'elevation': 0.093}

Mon Apr 29 12:47:03 2019 EDT  jpmorgen@snipe

Playing with WAITINLIMITS for a minute.  Posted a reply with some
pseudo code.

OK, ReduceDir is currently an object that does my directory-level
reduction.  reduce_pair is callable from the command line, but really
needs to be passed a bunch of stuff, like the Background object and
ephemeris stuff.

Since the Background needs the whole directory, I might as well
have reduce_pair call ephemeris stuff for the whole directory too.
That will ensure we only have have one cached call per directory!

OK, so reduce_pair needs to accept the ImageFileCollection, which has
as property the SummaryTable.  I was thinking of putting ephemeris
stuff into the SummaryTable as extra columns.  I was also thinking of
storing the whole ImageFileCollection (or whatever) in my own object
that has property for keeping track of which header keys I want to
update or create (and their comment strings) in files as I write
them.  Hmm.  This sounds like I might want to subclass ImageFileCollection!

Maybe not, since "The generator methods use simple filtering syntax
and can automate storage of any FITS files modified in the loop using
the generator."  SO the loop does the work, not ImageFileCollection.
But I can have an object that has as property the ImageFileCollection
and keeps track of things I want to modify when the time comes.

It is almost like the ReduceDir needs to be inside-out.  Ah.  Just
make ReduceDir store the stuff and then have separate methods to run
on a pair or on the whole directory.  And really, I don't want a pair,
but just one on-band image and let it find the closest off-band image,
or at least to have that option.  I also want to have the option to
use other off-band filters

OK, so how am I going to make this transition?  I should PEP-ify my
module names, so ReduceCorObs.py should not be camel case.

"Modules should have short, all-lowercase names. Underscores can be
used in the module name if it improves readability. Python packages
should also have short, all-lowercase names, although the use of
underscores is discouraged."

So precisionguide is good.  cor_precisionguide is OK.  obsdata and
cor_obsdata are I guess what I should aim for.  pinpoint_obsdata along
those lines.

Ah Ha.  reduce_cor_data is a little broad, since I am eventually going
to want to do photometry.  I am going to get the ephemeris cached to
disk.  I could start to do background subtraction and flatfielding
by writing those to disk somewhere.  Possibly having them in the same
file as the final image, though that gets a little over-bearing.  I am
not interested in doing detailed bias subtraction or flatfielding
right now.  Instead of reduce_cor_obs, I could have it be reduce_nas?
No.  Do I want it to not have reduce?  r?

Well, rdata would be short for reduce data.  Or even reduce.  Or
better yet ioio_reduce or r_ioio.  Or cor_reduce.  I like that one.
OK, I don't feel like I can re-arrange everything to be PEP Pythonic,
but I can at least move forward with cor_reduce by copying stuff over
from RedCorObs 

Tue Apr 30 09:37:49 2019 EDT  jpmorgen@snipe

Thinking of having a ccdchar for storing the characteristic
readnoise and gain parameters I need, rather than having them stored
in precisionguide

Tue Apr 30 13:50:22 2019 EDT  jpmorgen@snipe

Copied over a couple of directories to byted

it wants ffmpeg

Whew!  byted is really slow compared to snipe!

But got it to work, including editing the
/etc/ImageMagick-6/policy.xml for moviepy

Tue Apr 30 15:41:56 2019 EDT  jpmorgen@snipe

So deciding to move forward on work here, though getting any real
results in th etime I have before MOP seems unlikely.

Liked the idea of making a some sort of program that returns CCD
characteristics like the gain and readnoise of a system based on other
header attributes.  Currently I have that as global variables in
IoIO.py.  I could call the module ccdchar.py.  It would return a
dictionary of the info I would like to add to the header, but not add
it (or maybe it would).  The idea is that the return value could be
kept track of in a parallel object to an ImageFileCollection.summary
which would then write the stuff when the final file is being written.

Either that, or I write the files gradually as I go.  but it is so
easy to collect and manage info with Python that doing it via
excessive disk writes seems like a bad idea.  Wait a minute, I think
an astropy Table object lets me store objects too.....

Ah, I want column metadata.  Not sure how to do that.

But I can add columns with time and SkyCoord!

http://docs.astropy.org/en/stable/table/

So what I want to do is collect into the Table and then when it comes
time to write the FITS files, write out certain table elements as FITS
keywords.  That was going to be in ReduceDir, but it is really a
general thing.  I don't see how the Table class is going to get me
there, though.

Ah.  The Meta keyword of the table has the FITS keywords.  But that is
not used in collection.summary, since it is a table of keywords!

s.show_in_browser(jsviewer=True)

Totally cool!

But it doesn't have the column metadata.  So if I add, I either add a
column with it (probably best bet) or have some sort of object keep
track of it (also OK, but might as well use the Table if I can).  So I
still haven't seen how I can have metadata on each column other than
name and units

And the mixin columns don't really have the ability to be separate
objects like calculations, at least that I can understand.  They eed
name, dtype, unit, format and description.  Hey, what is description?!

Ah Ha!  There is a column description which should really be set to
the FITS description

s['bitpix'].info.description = '8 unsigned int, 16 & 32 int, -32 & -64 real'

So I can store the description there.  Then I just need a list of
columns that I want to update in the FITS file 

There is also the option to put a key in a particular place

hdr.set('newkey', 666, before='TARGET')  # comment is optional

This can insert a new card or move an existing one.  That would take
specific code.

Tue Apr 30 21:55:58 2019 EDT  jpmorgen@snipe

have a list of objects.  Each object has calculate and header_write
methods (maybe more).  The methods take a Table and a header (maybe
more).  If they need more than the Table and header, I could
potentially pass the self of the reduction object, whatever I am going
to call that.  That just becomes an object with property, which I
would call something like __calling_self.

Wed May 01 11:00:49 2019 EDT  jpmorgen@snipe

OK.  Now to the hist_of_im issue.  Basically, it is just np.histogram
except with centers instead of edges

https://www.mathworks.com/matlabcentral/answers/422000-matlab-histogram-connecting-bin-centers-to-make-a-curve

Recommends doing a convolve of the edges on 0.5, 0.5 to get to the centers

Being inspired with context management.  Finding bug in back_level.
But I still haven't figured out the best place to put the gain and
readnoise.  readnoise stuff.  I had those in ioio.py -> IoIO.py.  But
I want to re-arrange that to cor_obsdata, cor_precisionguide and
cor_reduce.  Fundamentally, cor_obsdata was the earliest I used gain
and readnoise, so that is probably where I want to set it.

--> Ahh!  What the flats really need is the center of gravity of the
    histogram. histogram * value / total of all bins
    If you have 1 ADU bins, i, 1/Sigma_i N_i * Sigma_i N_i*i

Can I simplify that?  N_i*i = need to find all pixels of that
intensity.  But that is also i+i+i.... N_i times

No, this is working out to be the mean.  What I am looking for is the
weighted mean

In any case, I am feeling like the best place to put the functions for
readnoise and gain is in cor_reduce, since I might change the way
those are done in cor_obsdata & I can always move them then

Thu May 02 03:44:49 2019 MST  jpmorgen@byted

Really want the gain function, wherever I put it, to return gain and
optionally a FITS card with all the metadata in it.  Well, to be truly
general, I don't necessarily want a FITS card.  I just want the
documentation.  So that would be a dictionary return value, which is
what I was thinking of anyway.  But I am handing it the hdr, so might
as well put it there

Thu May 02 07:49:08 2019 MST  jpmorgen@byted

Hey!  I might want Gain and Readnoise to be objects with methods value
calculate (or derive, batch, etc.), Table and hdr.  These could be in
the cor_ccdchar file

Hmm...  Now I am playing with things and it looks like I am
subclassing Card.  But I am also having the Table option....  At some
level I just need to write code.

Sat May 04 07:30:05 2019 MST  jpmorgen@byted

So things are coming together.  ccdproc is the general package for
tools that help with ccd data processing.  I see a reduceccd package
on GitHub that someone has put up (Ruben Garcia-Benito (RGB)) 2 years
ago.  Doesn't seem to make too much sense to me based on the
documentation, but the basic way of going about it seems similar.
There is even older stuff from 2010 which looks like the start of
CCDproc.  So it looks like I am pretty much on my own for a pipeline,
which is OK.

I was going to call it ccdred and corred

Tue May 07 12:25:03 2019 MST  jpmorgen@byted

OK,  working on cor_red.  Should I make CorRed one object that handles
all levels of reduction?  Or should I have a separate one for the
directory?  I was thinking that I would have the single file handled
sort of at the same level as the directory, since I want to have the
ephemeris there.  Do I also want to handle the whole directory
structure and movie and all of that?  Don't know until I try.

I could do everything with property decorators so things only
calculate when they need to 

Thu May 09 14:49:54 2019 EDT  jpmorgen@snipe

Wonder if it would be better to have colred and rowred or something
like that to indicate that columns or rows are going to be added.

At the very least, I want col_oplist and row_oplist

OK, so I want something that puts the rawdir and reddir into the
summary Table but doesn't necessarily put them into the header --
though it is not the end of the world if it does.

I guess if it is something simple that operates on a column of the
table and doesn't need a header write, I can just operate on the
column!

OK, now when I want to add a row that has a corresponding column, like
reddir, I also need to do that in two chunks, adding the column to the
Table first.  Hence the two types of operations.  What should I call
them?

Package that uses ccdproc
ccdred or ccd_red
colred	  col_red
rowred	  row_red

Actually, ccdred could be the module and ColRed and RowRed would be
the classes for operating on rows and columns

Wait a minute, a rowred ads a row but if I have it add a column at
that point to just that row before adding the whole column to the
table, it barfs.  So I need rowred to have a method that adds to the
col_oplist any columns that need to be appended to the table.  All
this was to try to get into one place the code that is necessary to
maintain the summary table and the FITS header.  It is being a little
painful to do so, but lets see if we can do this last part....

So rowred needs to have a method that is just like col_red, which I
currently call table.  But maybe I should call it column whole_column,
or new_column.  Or I could have an addtable object that does
everything.

In the end, I really need to have the table have all the columns (at
least blank) first and then I can add rows

ccdproc is designed to go through individual files in the list and do
things with them.  I am pushing that.

So if I stick with everything as going into a single oplist, I could
call all of the (full) column methods first and then the row methods.
I guess there may be two types of row methods:

(1) Add a row that starts as a duplicate of another row
(2) Modify columns in a particular (set of) row(s)

http://docs.astropy.org/en/stable/table/modify_table.html
notes that I need to use table[column][row] if I want to use things
like np.where to index the row.

Whew!  OK, so maybe I need a more generic object that can be ready to
do rows and columns

ccdred
ccdproc_multicolumn
ccdproc_table
ccdproc_table_proc

Ack.  Now I am getting a little worn out on all this generalization.
If I really continue down this route, ccdred is probably going to need
to assume that it is interfacing with an astropy Table at the very
least possibly ccdproc.ImageFileCollection.  I was trying to keep it
totally general with dictionary stuff.

So if I use summary as property, when I instantiate the first CCDred
object, there is a long pause while the directory is read and the
summary table is generated.  If I use the ccdproc.ImageFileCollection
as the property, I can instantiate a whole bunch of objects and there
is no pause until there is a .calculate or .column or .row method that
uses the summary table.  In cor_red I was keeping track of the image
file collection as property there and then passing the summary table
to the object.  I am not sure it is good form to separate the object
that is being worked on and the worker.

Another issue is that the ccdred is getting pretty involved and will,
of necessity, include calls to astropy Table and ccdpro stuff.  But I
guess that is through methods of the objects themselves.  I don't
think I'll need to do any imports of those things

Fri May 10 12:37:54 2019 EDT  jpmorgen@snipe

OK, I have a basic ccdred.py now 

I can add features like before, COMMENT, and HISTORY at some later
date if I want to.  No, those were easy to add.

Getting stuck with parameters for value and it being @property.  For
the simple case of just storing things, it works OK.  If I need to
calculate, I was thinking that would all be done at once and
everything necessary for that would be in the object.  But *args,
**kwargs for all calculate methods seems safe.  If the object cares
about a summary table, that will be tweaked and things will be
available through the collection.summary object.  Value becomes
degenerate.  That is possibly why this whole thing is a bad idea,
unless value becomes the whole column.....  Well, since I have
@property, that is not too hard....

ReduceCorObs.py reduce --tree --movie --start 2019-05-01

Put on/off scale back to the way I had it in 2018 and just live with
it for now.

ReduceCorObs.py reduce --tree --movie --start 2019-01-01 --recalculate


ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/20190508

Looks like Na_on_loss is more exaggerated this year
--> Think of a way to spot that in real time, since it looks pretty
easy to spot by eye.

SII_on_loss = 0.95
#Na_on_loss = 0.8
Na_on_loss = 0.6

0.6 looks good.


ReduceCorObs.py reduce --tree --start 2019-01-01 --recalculate --movie 

Mon May 13 16:30:13 2019 EDT  jpmorgen@snipe

OK, things are starting to gell a little.  The lower Na_on_loss made
things look a little better.  Starting 20190407, there is a higher
section that steadily goes down to 20190426

On the [SII] side of thigns, there is a clear division between
<20190329 and after.  It is a total mess now, possibly because
SII_on_loss needs to change. Possibly because the filter wheel doesn't
move into the same place repeatably?

Mon May 13 22:19:21 2019 EDT  jpmorgen@snipe

Add torus aperture sums

ReduceCorObs.py reduce --recalculate --movie --directory /data/io/IoIO/raw/20190508

Move reduced tree to /data/io/IoIO/NO_BACKUP/reduced.previous_versions/2019_before_IPT_aperture/

ReduceCorObs.py reduce --tree --movie

Tue May 14 07:57:07 2019 EDT  jpmorgen@snipe

ran from 22:39 or so until 04:56, or about 6 hours.

No harm done to Na or regular [SII] aperture sums

OK, AP_IPT_east_3_7_3 decreases over time and west increases.  They
cross at mid April.  This could very well be an alignment issue.

Indeed, _4_7_3 looks totally different, with a slight bump in mid
may.  Same for _4_7_2

But clearly the fact that I am getting negative values for the torus
in these apertures suggests that there is something else going on:
background subtraction.  Or maybe the satellites

Thu May 16 20:05:45 2019 EDT  jpmorgen@snipe

--> there seems to be a fixed pattern noise in the reduced file that
    is on all scales, the easiest to see is ~100 pixel pincushion

Fri May 17 08:13:11 2019 EDT jpmorgen@snipe

Try to do calculation without rotating to see if that helps with what
I think is an aliasing issue....

ReduceCorObs.py reduce --recalculate --movie --directory
/data/io/IoIO/raw/20190508

Rotation was 0.3 degrees!  Pin cushion definitely goes away

In 2018, preak to oeak is genrally 200+, with occational spikes to 400

In 2019, there is still larger hash, with spikes up to +2000, -1000,
and hash more like +/-500

--> not subtracting enough.  Fixing that up with SII_on_loss 1.2 was
    too much subtraction

There is a high pixel-to-pixel variation even in the ND filter, which
is slightly over 100 pixels.  Off ND filter is consistently not more
than +/-200 

--> not getting flip since I have turns off small-angle rotation

this is some sort of on-off subtraction, since raw images in 2019 have
only +/-20 ADU

There is something weird going on since inside the ND filter in the
raw is +/-20 ADU


        off_im[OffBandObsData.ND_coords] = 0
        offscale = on_jup/off_jup
        off_im = off_im * offscale * on_loss
        scat_sub_im = on_im - off_im

Oops, ADU2RAY is in there too.  Could it be because on_jup is extra high?

moving by 1, 80 pixels

Still +/- 1000
2019
ADU2R   =  0.02168766244115172 / conversion factor from ADU to R

2018
ADU2R   =    0.119791856171764 / conversion factor from ADU to R 

Ha!  That is a huge difference!  And explains the factor of 5 in the
noise peak-to-peak.  It is not that the noise is any different!

So what is the real Jupiter brightness?

Well, on_jup must be recorded as much dimmer in 2019

OK, what is ONBSUB doing?

Ah Ha!  It looks like the ONBSUB values is increasing each year.  in
2017, it was ~1480, in 2019 it was decreasing from 1780 to 1670
(mostly 1670) and in 2019 it is a steady 1880 or so.

DONBSUB is a little better behaved.  For the Na, it is trending to -40
for Na.  Somewhat concerning: I see the negative envelope of the
enhancement, but that could actually be real, since the edges got brighter
and DONBSUB is calculated: bias_dark - OnBandObsData.back_level

As expected DONBSUB for [SII] is very small.  Interestingly clumped at
+2 and -2.

Back to Na DONBSUB for 2019.  It was very nicely 0 until I tweaked the
instrument.  Then it went to -50, which is consistent with the low
value I had in 2018 and then it suddenly went up to ~-30 or so, which
looks like the inverse of the aperture stuff.  But still, there are
pretty small numbers.

OK, now looks at the value for Jupiter in the raw files

cd, '/data/io/IoIO/raw/2018-05-18
atv, 'SII_on-band_008.fits

Jupiter
8700 max, bias 1630

cd, '/data/io/IoIO/raw/20190508
atv, 'SII_on-band_008.fits

Jupiter
3160 max!  bias 1880

Where have all the photons gone?

Could this be a sign that I zapped my CCD with the sun?

CCD temperature in both 2018 and 2019 = -15,
EXPTIME 300

2018
OBJCTALT= ' 32.5554' /          Nominal altitude of center of image             
Ap Mag -2.50

2019
Ack, no telescope....
DATE-OBS= '2019-05-08T08:14:48' /YYYY-MM-DDThh:mm:ss observation start, UT      
Alt = 30
Ap Mag -2.50

Call Starizona about this [Scott suggested f-stop...]

also check to see if stars are the same calibration [...did and they are]

So for Na ADU2R followed the expected distance envelope in 2017 and 2018,
with a high at ~0.38.  It was wacky in 2019 up to late March, probably
because of weather.  There are some very low points in late March
probably because of bad focus.  Since April it has been steady at 0.1.

Physically, the filter wheel got thicker and an adapter was put in
that spaced the start of the filter wheel even farther back.  What
didn't change was the ND filter at the focus of the telescope, since
the focuser aranges for that.

I have to therefore change the focus of the camera, which shortened
the total focal length by 10-15mm.  Not sure I understand that.  Oh, I
have gotten shorter focal lengths with the old system.  That seems to
be a temperature sensitive thing on the main scope.  OK.  So I am
moving the camera farther away from the focal plane by up to 0.5",
which is really not much compared to the total length of the instrument.

For [SII] ADU2R has a rattier curve and lots of 0s.  But is about
0.125.  Now it is about 0.02!  on_jup is the thing that is changing

For Na, it changed by a factor of 3.8 for [SII] it changed by 6.25.
What are the off-band doing?

cd, '/data/io/IoIO/raw/2018-05-18
atv, 'SII_off-band_008.fits

Jupiter
7700 max, bias 1630

cd, '/data/io/IoIO/raw/20190508
atv, 'SII_off-band_008.fits

Jupiter
3280 max!  bias 1880

>>> 7700 - 1630
6070
>>> 3280 - 1880
1400
       4.3357143

cd, '/data/io/IoIO/raw/2018-05-18
atv, 'Na_off-band_008.fits
20000
cd, '/data/io/IoIO/raw/20190508
atv, 'Na_off-band_003.fits
5700

(20000. - 1630) / (5700 - 1880.)
       4.8089004
       
F-stop?

So I must have a Nikon 60mm f/2.8 Micro-NIKKOR AF-D

http://download.nikonimglib.com/archive2/6Vex200Zt1ox02k1UZm06GC9j487/AFMicro60_2.8D_(27_DL)02.pdf

So if I am down

6070/1400
4.335714285714285

f = np.asarray([2.8, 4, 5.6, 8, 11, 16, 22, 32])

f/2.8
array([ 1.        ,  1.42857143,  2.        ,  2.85714286,  3.92857143,
        5.71428571,  7.85714286, 11.42857143])

So if I had to say, it got stopped down to f/11.

That is a pretty serious loss, as I have seen.  It might also mess up
my exposures on the satellites.  To the later point, if I need another
factor of 6 shorter exposure time, R-band would need to be 0.003,
which is doable.  0.002 not, but 0.003 yes.

Transfer notes to IoIO.notebk.

Ah Ha.

There is a funny twist in the ND filter or something now that didn't
used to be there.  It may be a ghost.  See IoIO.notebook for
measurement that says that ghost is a factor of 20%, which I can live
with.

think my intensity problem might be with finding center of Jupiter

Ack, I don't think so, because when I take a profile of Jupiter, I see
it is much less bright!  [Astrometry tool in MaxIm gives the same maxima]

spot-check on a few more days, also check that bias is working right
[did and see that ADU2R is consistent with spot-checking]

Gain and linearity check was after change & indicated CCD was OK

Sat May 18 10:30:39 2019 EDT  jpmorgen@snipe

[20190326 is the first day of HD 110411 and it was a little cloudy as
per Jupiter observations]
20190301 HD 006530 SII_on 0.7s 43000
20190318 HD 132052-S001-R001-C002-SII_on 0.7	Sat
20190326 HD 110411-S001-R001-C001-SII_on 0.7 26000 
20190326 HD 110411-S001-R001-C002-SII_on 0.7 27000
20190326 HD 110411-S001-R001-C003-SII_on 0.7 27700
20190326 other filters
Na_on	54000
Na_off 	263000
R	151000
SII_on	27000
SII_off	131000

-- change instrument--
20190404 HD 110411-S001-R001-C001-SII_on 0.7 34000
20190404 HD 110411-S001-R001-C002-SII_on 0.7 34000
20190413 HD 110411-S001-R001-C002-SII_on 0.7 35000
20190413 other filters
Na_on	69000
Na_off	322000
R	200000
SII_on	35000
SII_off	165000

FWHM is generally larger on 20190413, but there are some values of 3,
suggesting seeing might be bad -- these are all short exposures


Sat May 18 21:27:47 2019 EDT  jpmorgen@snipe

Try with a bigger patch of Jupiter.  Keep in mind that I don't need to
bother to change ADU2R for R, since I am working in pixels for R, but
it would affect relative ADU if pixel scale changes [but pixel scale
only changes negligibly]

python3 -W ignore ReduceCorObs.py reduce --tree --start 2019-01-01 --recalculate --movie 

python3 -W ignore ReduceCorObs.py reduce --num_processes 1 --tree --start 2019-01-01 --recalculate --movie 

I wonder if having the filter farther from the focus might be
decreasing the bandpass?  But that doesn't explain why the HD was the
same brightness, 

check that flats are flat -- yes, still very flat, so it is not
Jupiter falling into some weird whole on the CCD.  Although not
perfect, the ND filter was reasonably flat + things look about the
same when I move Jupiter up and down on it.

--> is Jupiter falling into some sort of Fraunhofer feature? 
Even on 20190426, which I label as a beautiful night, Jupiter is the
same wimpy 3000 max!

The flux just off the ND filter seems to be comparable, which is why I
suspected the ND filter, but ND filter tests show that it is still
ND3, more or less.

What if it is a camera focus problem?  The ADU2R was even lower, when
I had a very bad focus.  It is better now, but not as good as it was
last year.  Jupiter is focusing above or below the ND filter.  In
either case, the rays are spread out more than I want.  But each ray
gets attenuated the same amount

Sun May 19 08:02:01 2019 EDT  jpmorgen@snipe

--> test to see if a very bright star in [SII] or Na is same on ND
    filter?

That doesn't seem likely, since R-band includes these lines.

Sun May 19 14:29:24 2019 EDT  jpmorgen@snipe

OK finally have a good focus on 2019-04-11, but the instrument is
clearly out of focus with the ND filter.  The max is still just 3300.

--> So it doesn't seem to depend on the instrument focus.  Even very
bad telescope focuses have maxes around 3000 pixels.

Verify that in 2019-03-06 & others, the [SII] max looks just like in 2018.

So the fundamental change came not with minor instrument focus, but
with a more major movement of the camera back from the focal plane of
<=0.5"

We are at 1.58"/Pixel instead of 1.56"/Pixel from 2018 (bin 2x).  So
that is not the change.

20x20 box for Jupiter surface brightness didn't change the [SII] or Na
ADU2R behavior.  

Mon May 20 09:19:30 2019 EDT  jpmorgen@snipe

Let's review change.  Moved filters back by <0.5" and everything back
from there back by ~0.5"

f/ = 11 = f/d ; d = diameter of aperture, f = focal length

11 = l/2r ; r = radius at distance l from focal plane; l = 0.5"

r = l/(2*11)
r = 0.5/22
0.022727272727272728

As expected, the small change in filter wheel thickness results in
only a small change in where a patch of light is subtended.

But for Jupiter, this ends up being a large change in filter area.
And it is different for the [SII] and Na filter because of how they
are mounted in the wheel.  Looking at the wheel on the SX website, I
think the [SII] is generally closer than the Na.  Actually not
necessarily.  If they are recessed (which they are) and the filters are
mounted deep in the rings (which they are), the [SII] could be farther
along the optical axis.

But wait a minute.  The wheel is weird.  The original USB mounts the
filters on the same side as the magnetic pegs.  The Maxi does it the
same way as well, but runs the light the other way, since it puts the
prism for the off-axis guider on the other side of the wheel.  So
which way did Scott mount things?  I recall working with the filters
on the opposite side of the numbers and having the taller ones scrape
in the hole when it was trying to move all the way around.  I have
vague recollection that was the hole from the telescope, as it had the
ND filter on it, which propped the whole wheel up.  The rest of the
instrument came off easily with the 7 thumb screes around the wheel,
so I didn't need to deal with taking that off.

So in that configuration, the Maxi is upside-down with respect to the
prism, but it keeps the filters as close as possible to the ND
filter.

From: Scott Tucker <stucker88@charter.net>
Date: Wed, 6 Feb 2019 11:59:43 -0700
> The easiest and least expensive way to make the adapter plates for the
> filter wheel to the coronagraph is to make thin plates that will bolt
> between the existing lens/ND holders.  That way we don't have to
> remake those parts which are the most complicated to machine. And we
> avoid having to remount the lens and remake the ND filter strip.  It
> will add 1/4" to the overall length and should require a slight
> refocusing of the Nikon lens to bring the ND strip into focus.

Based on my recollection of verbal conversation with Scott, the
adapters themselves are each 1/8".  So we have added 0.125" to the
distance between the ND filter and the Na filters.  The [SII] filters
might be slightly further back because of the deep adapters.

--> they are tipped because of the large stress on the large filter wheel
    from the drive wheel.  I think that makes the central wavelength
    redder

Maxi wheel Thickness between input and output adaptors: 41.6mm (1.63
inches)

Standard USB wheel drawing looks like 29-4*2 = 21 mm basic casing
thickness

(41.6 - 21) / 25.4 # filter wheel thickness difference in inches
0.8110236220472442

Full accounting of stack

ND filter at focus of telescope (no change)
0.125" adapter (new)
Filter position in new wheel very close to scope-side face BUT
 filters may be slightly tilted relative to normal incidence
0.811" fatter filter wheel (new)
0.125" adapter (new)
Field lens
Camera

Total motion of 

2*0.125 + 0.811
1.061


r = l/(2*11) # from above, now l = 1"
r = 1/(2*11)
0.045454545454545456

That is not very much, so it seems unlikely that the field lens
position change made much difference.

Mon May 20 13:43:05 2019 EDT  jpmorgen@snipe

look at Jupiter in the other filters....  Oops, I can't do that
since I didn't have any!  But R maybe

R-band
2019-03-20 2000 (looks like OK focus)
2019-03-23 2100 bad focus
2019-03-26 2000 (looks cloudy & bad focus)
2019-04-06 2100

OK, so it looks like R-band has no change.

[SII] on-band	~6
[SII] off-band	~4
Na on-band	~4
Na off-band	~5

How big an angle are we talking about them being tilted?  The filter
wheel housing diameter is 10.8", so the wheel itself is no more than
10".  1.25 filter holders are about 7.7mm long.  Say 1/2 of that fell
into the hole, though that is generous.  Call it 3mm

np.rad2deg(np.arctan((3/25.4)/5))
1.3531919537796906

f/11 beam angle is

np.rad2deg(np.arctan(1/11))
5.194428907734806

So this is a non-trivial component of that, but still within that angle.

Jupiter up-down on ND filter didn't affect it.

Mon May 20 20:54:48 2019 EDT  jpmorgen@snipe

Hmm.  Thinking about the fact that the ND filter looked more twisted
and bowed than I remembered it.  If it is bowed inward, this could
spread rays out and give them a bigger than f/11 angle.  But I can't
see that changing thigns with distance on the filter, since angle is angle

Tue May 21 08:31:56 2019 EDT  jpmorgen@snipe

Jeff Baumgardner is encouraging me to look for a center effect.  I
don't see that in the new filter wheel, but could it be there in the
old?  Also, as I move Jupiter up and down with the new wheel, I do see
evidence of reflections.  Could it be these just lined up in the old

do absolute calibrations of stars, since I don't have a good night
for HD 110411.  No, have R for intercomparison.

Look into 20190515 to see if I can figure out where all the
retroreflections are coming from.  Check for these in smaller filter
wheel data

SII_on-band_021.fits: Below center, shadow of ND filter above, near center

SII_on-band_018.fits: Above center, shaddow of ND filter on another
set of ND filter fuzz.

In neither case is there evidence of shaddowing below Jupiter

\\SNIPE\data\io\IoIO\raw\2018-05-18\SII_on-band_012.fits hard to tell,
but I'd say we are seeing the same thing.  Fuzz looks sharper below
than above, --> but the effect is not nearly as exaggerated

Ahh, that is probably because the reflection from which it derives --
off the front surface of the narrow-band filters -- occurs further
back in the new arrangement.  The fact that it is centered in a
similar place relative to Jupiter is suggestive that the angle hasn't
changed much -- probably the focus tube angle

Lets look at the torus itself with atv....

cd, '/data/io/IoIO/raw/20190508
atv, 'SII_on-band_010.fits

Tours is ratty and 150 above background nearby

cd, '/data/io/IoIO/raw/2018-05-18
atv, 'SII_on-band_010.fits

Torus is also a bit ratty and 150 above background nearby

So the spot check of torus seems OK.

--> there was some sort of specular reflection looking thing on the ND
    filter toward the edge.  It could be that dominated in the old
    configuration?  It would only be an issue on the narrow-band
    filters

--> I could potentially take a bright flat with the narrow-band filters

The idea is that the ND filter might not have good AR coating (Jeff
reported nasty reflections).  The ND filter is at the focus of the
telescope.  The camera lens is effectively at the telescope pupil.
There could be a reflection between the two?  But I don't see bad
ghosts between telescope pupil and ND filter, so I don't think there
would be much in the other direction.  The difference is that the
narrow-band filters are in there.  They have AR coating that should be
good, but say they are extra shiny, or maybe extra not shiny!

Jeff's thinking about a bright spot in the center is where I am going
with this now.  I see the evidence of pretty significant shadowing of
the ND filter in off-axis light that has bounced off the narrow-band
filter.  That means that reflection is non-trivial.  For a Fabry-Perot
filter I would expect that.  So if the ND filter has specular
reflection off its surfaces, that light bounces right back.  It is
less intense as related by the 1/r^2 effect.

So if this correct, I might find that Jupiter is a more exaggerated
central peak pre-switch..

cd, '/data/io/IoIO/raw/20190508
atv, 'SII_on-band_010.fits

(3200-1884)/2+1884

FWHM
67-23 =  44

cd, '/data/io/IoIO/raw/2018-05-18
atv, 'SII_on-band_010.fits

(8650 - 1651)/2+1651
5150

68 - 25
43

So FWHM is the same.  They look the same.  Last year is just scaled by
4 -- 6 depending on the filter

So the transmissivity of the filters is measured at near 100% in-band

OD is not coming out well in measurements, but seems to be better than
1E-4 and probably better than that.

My hypothesis is falling apart since Jupiter's shape is no different
in the two cases and I don't see where the extra photons can come
from, though there is a possibility they are off-band.

OK, go with the off-band hypothesis.  Since Jupiter is very close to
the center of the FOV, that keeps all the rays together as they go
through the ND filter and hit the narrow-band filter.  On-band light
goes through with near 100% transmissivity because of the tuning of
the coatings, matching the index of refraction in air gradually to the
subtrate, where it mystically turns into a mirror for outbound photons
& does the Fabry-Perot effect.  The reflection for on-band light in
the narrow-band filters is relatively small.  Reflection in off-band
light has to be very high, since otherwise where would that light go?
Plus, I see it.  The ND filter may not have good AR properties.  So
all the light bouncing back from the narrow-band filter is prone to
reflection.  OK, maybe not all.  Normal glass is 4%.  Having trouble
finding a value for Wratten gelatine

Filters were specified: Out of Band Blocking: T<0.001% 350-1000 nm.

So I have ~1nm primary bandpass and am getting a x6 boost from
off-band?

OD Blocking
     OD bandwidth
1E-5*700
0.007

Even if I am getting 100% reflection from the front of the narrow-band
filter, 100% off the bottom of the ND filter, I am still only getting
0.7% transmission through the narrow-band filter.  That is not a
factor of 4 -- 6.

Still a little skeptical of this calculation, but it does seem that my
boost/attenuation has to be from on-band light.

Go back to the simplest thing it could be: some sort of change in the
optical properties of the ND filter such that in yellow/red light, it
got aged, say by a zap from the sun.  But I would presumably see that
in the R-band filter.  5890 is just below that, 6731 is right in the
middle of that.  Those show comparable effect, but R doesn't.

OK, back to reflection between the ND filter and the narrow-band (-->
could also be between narrow-band and lens).  But start with upper
reflection.  I ruled that out with the single reflection giving 0.007%
transmission.  How many to give our factor of 6? (assuming shape
difference is negligible).  The 0.04 reflection of ND filter kills
this idea.

What if we are working on the edges of the ND filter transmissivity?
There is a point at which it is 50%, so 50% goes through and 50%
bounces.  The 50% bounce.

How wide are the transitions?

Wed May 22 01:46:21 2019 EDT  jpmorgen@snipe

--> check SII and Na calibrating exposures.  Looks like they could be
    a little brighter

Na_off_cal is really dim even when no clouds, like I really want 0.5

Hmm.  All exposure times on the narrow-band filters would need to be
greater than 0.7 to have decent S/N.

figure out best way to do exposure time.  Possibly just doing 0.7
and 0.71 on one or all of the filters.  SInce this is at the
beginning of the observations, I can take some time for it.

--> finish testing satellite calibration exposure times 

Wed May 22 14:07:08 2019 EDT  jpmorgen@snipe

Looking with atv and seeing there is pretty considerable structure in
the ND filter response relative to the noise.  In particular, there is
a large peak just above the middle.  This is on 

cd, '/data/io/IoIO/raw/2019-05-18_ND_filter/
atv, 'ND_filter_ghost08.fit

bias = 1870, so subtract that

im = readfits('ND_filter_ghost08.fit') - 1870

ND filter at high Y is ~350.  It continues up to a peak near the
center of ~625.  So over the 
625./350
1.7857142857142858

Across goes from min of 500 at center quickly to 600
600/500
1.2

cd, '/data/io/IoIO/raw/2018-04-04/'
atv, 'Sky_Flat-0005_Na_off-band.fit'

Wow.  As I reacalled, that looks totally different, with the ND filter
looking very uniform.

This suggests that the ND filter has either been damaged, or the
position of the field lens makes its structure more visible.

Although the image of Jupiter doesn't look distorted, if this wierd
structure in the ND filter somehow causes light to go at different
angles (?) or refract (?).  Or it could be ghosting from somewhere
else.  Jupiter doesn't change much when I move it around

im = readfits('Sky_Flat-0005_Na_off-band.fit') - 1740 very nice,
uniform peak in middle at about 160, down to ~120 toward low Y.  But
the noise is much more, comparable to the variation

160/120
1.3333333333333333

and there is a hint of the extra peak in the middle.  So we might just
not be seeing enough signal.

atv, 'Sky_Flat-0002_SII_on-band_bright.fit
im = readfits('Sky_Flat-0002_SII_on-band_bright.fit')
im -= 1740

very nice 150 -- 250 and back again arch

So it looks like the ND filter was either damaged in the transfer,
which is consistent with my noticing more exaggerated twists, or the
ghosts are more prevalent with the spacing change 

It is suspicous that the ghosts are along the ND filter, which would
be consistent with some sort of twisting damage

I can test for ghosts... no, if the ghost is related to the ND filter
just being there and relfecting off of a lower or upper surface, it is
being expresed on the ND filter.  I don't have another surface at that
level to check, but look anyway....  Looks really flat just off the ND
filter.

So this could potentially be a reflection of the diffraction of the ND
filter off of the curve of the plano-convex lens.

It could be sun damage.

If we take the response at face value as transmission and not ghost,
it is a little less toward the left.

Wed May 22 18:27:19 2019 EDT  jpmorgen@snipe

Could this be front-surface reflection up the tube and back?  Hmm.
Never saw evidence of this when ND filter was clocked at 15 degrees.
That could be because the tilt was enough to put it off the FOV.  Here
we might be seeing the end of the ND filter in the middle.  Does that
go in the right direction?  Yes.  The instrument tilts back and light
from the bottom shows up on the top.  The slight waviness could be the
slight twist, which is only a fraction of a degree.

The problem with that hypothesis is that I don't see the effect in the
2018 data in the regular flatfield.  I would expect a bright patch up
and to the right.  I see none.

Go back to May 15 and measure Jupiter in the different positions more
carefully.  In fact, I can use read_ap to do that....

OK, read_ap suggests Na ADU2R was 0.07 at the beginning of the night,
then up to 0.09 at , then 0.12 for the last three.  But that is not a
whole lot different than the previous nights, suggesting an airmass effect

For [SII], something was very bad on the 16th, but that might have
been clouds.  Looks like ADU2R is affected by airmass mostly.

PSIScope biases
5C   1658
0C   1650
-5C  1640
-15C 1632
-20C 1630

So there is no change in bias level with temperature of the CCD.
Probably the difference is the temperature of the amplifier, which is
ambient.  Looks like it might go down with higher temperatures.
Overall up-trend suggests wear in amplifier.  I would expect that
would go to hotter, but there might be yet another thing going on.

Thu May 23 08:33:31 2019 EDT  jpmorgen@snipe

Time to calibrate Jupiter

HD 110411
Wavelength (Å)
	Flux (photons/cm² /Å /s)
5875	9.50
5900	9.43

6725	7.47
6750	7.43

\\SNIPE\data\io\IoIO\raw\20190411
Bad ND focus but night looks clear, decent focus on SII_on-band_004
Hey, bad focus shows shadows in ND filter below Jupiter.  Suggesting
that is a focus effect of the camera lens, not ghosts

Jupiter typical 3376 max - ND nearby 1880
(3376 - 1880) / (300 + 1.5) # ADU/pix/s
4.961857379767827

HD 110411 intensity 33000 in 0.7s

33000/0.7 # ADU/s
47142.857142857145

Physical units of Jupiter flux are in surface brightness

1R = ${10^6 \over 4\pi}$\,photons~s$^{-1}$\,cm$^{-1}$\,sr$^{-1}$

(oops, error in paper!  Should be cm$^{-2}$)
Add a 1/Å if this is spectroscopic

Physical units of star flux are 

photons~s$^{-1}$\,cm$^{-2}$
Again, add a 1/Å if this is spectroscopic

So basically they are the same except the sr.  So does it work to just
multiply by sr/pix to blow the flux in one pix up to full-blown flux?

http://deep-red.sr.unh.edu/starflux/starcalib/starcalib.htm

suggests the answer to that is not quite or maybe I am on the right
track.  No sense re-deriving their nice work.  Their equation 5 and 6
is what we need.

7.47 * 9.95 # photons/cm² /Å /s * Å

Calculate theta = pixel size in radians

0.79 / (3600*360/(2*np.pi)) # (arcsec/pix) / ((arcsec/deg/(deg/circle))/(radians/circle))
3.830028080765334e-06

So effective star surface brightness in R is
4*np.pi * 7.47 * 9.95 / 3.83E-6**2 * 1E-6 # photons/cm² /Å /s * Å  R/(photons/cm²/s)
63673100.60523741

So their equation 6:

imageRayleighs = imageDN * (t1/t2) * (I/S)

t1 = 0.7 # exposure time of cal 
t2 = 300 + 1.5 # exposure time of image I want in R
I = 63673100.60523741 # standard star apparent surface brightness
S = 33000 # standard star measured brightess 20190411, 34000 20190410
imageDN = (3376 - 1880) # bias-subtracted ADU of Jupiter 

imageRayleighs
6701.690633077503

Oops, I need an additional 1000 because of the ND filter.  So we are
close to 6 MR.  That is a familiar number....  And this is for a
crummy measurement in 2019.

OK, that is major news.  It means that something made the flux between
the ND filter and the narrow-band filters much brighter when they were
closer to each other.

Thu May 23 20:47:42 2019 EDT  jpmorgen@snipe

Pause this and figure out how to kill python process.  Can do that,
but have problems even before then.  Really need to use ACP's image
taking stuff...

OK, back to amplification of signal between ND filter and narrow-band
filters.  Just realized that I don't need to get extra photons, but
rather loose some of the ones that are already there, being
attenutated by 1000.  This might get into the details of the physics
of how the ND filter works and what would happen if a near
monochromatic signal is bounced back up toward it.  Or maybe any
signal of the same wavelength that happens to be coming down.

Because Jupiter doesn't change shape, the original down-going rays
must be the ones that are stimulated to avoid the
scattering/attenuating process in the ND filter by the upcoming rays.

Fri May 24 10:33:38 2019 EDT  jpmorgen@snipe

Hey, wait a minute!  Although I didn't take calibration of the
Galilean satellites through non narrow-band filters last year, I did
take lots of exposures of Jupiter reasonably exposued through R!  But
really all I probably need is a one-time transfer calibration

Back to figuring out what might be going on

OD Blocking
     OD bandwidth
1E-5*700
0.007

Now if I have a stimulated emission that makes the ND filter
completely transparent

1E-5*700*1000
7.0

Hmm.  What do you know!

Fri May 24 15:38:29 2019 EDT  jpmorgen@snipe

No, that is not quite right.  Out of band blocking is 1E-5
integrated.  It is an ND5 filter.  So on-band, we have 10A that are
1E-3.  Off-band, we have, say 7000A, that are 1E-5

10*1E-3 = 1E-2 # equivalent width
7000*1E-5 = 7E-2 # equivalent width

Still a familiar number!

Tue May 28 10:30:20 2019 EDT  jpmorgen@snipe

Jeff thinks it is resonant cavity

Bertrand Bonfond is asking about Na cloud because they had May 26 very
bright auroral footprint.  Looking at aperture results, we could have
had a sharp, bright outburst just when I changed the instrument.  This
seems unlikely, but the tail does make sense and I was having trouble
with focus before that.

How does ADU2R calibration change affect the final answer?  ADU2R went
down by factor of 4 for Na.  It is divided into pixel flux, so that
ends up boosting flux by 4.

This makes some sense in terms of seeing another outburst which I
missed pre instrument change.  Try to see individual nights with
movies and it is hard to note 

Tue May 28 11:11:26 2019 EDT  jpmorgen@snipe

OK, programmed the change in calibration into read_ap.  Inner
apertures get disproportionately dimmer, since they include Jupiter.

Working with just the 25 Rj aperture.  There are some critical points
that might define the onset of the outburst that are at -200R.  These
are in the period 20190304--20190322

cd, '/data/io/IoIO/raw/20190321/
atv, 'Na_on_15_003.fits
atv, 'Na_on_15_010.fits
atv, 'SII_on_15_010.fits

Focus looks pretty doughty

But these are true calibration sources!

OK, if focus is poor, surface brightness at focal plane is going to be
artificially low.  And our amplification systems for underneath the ND
filter will also be low.  Sure enough, Na ADU2R is 0.23 instead of
0.28, except when it is pretty much 0, presumably due to very bad
focus.  Take those out

OFFSCALE has an intermediate value of 1.3 on 20190407-09.  OFFSCALE is
really low on those days that ADU2R <0.04 in 2019.  So that is junk
that is caught by the ADU2R filter.  Other than that, OFFSCALE is sort
of tri-modal.  low in 2017 to mid-late April 2018, high in the rest of
2018, (say 20180418+)  Then back to low in early 2019, intermediate on 
20190407-09, then high after that

Taking out those bad points really helps things!

So 1/3.5 looks like a good match, but I measured something closer to
4.  Doesn't really seem to affect things and the points still go below
0 near the current time.

Look at other trends.  There is a hint of a down-trend from 201704-6.
Definitely see downtrend 201804-6.  Now big downtrend 201904-6

Look at off-band.  Looking at 11-day running median of nightly median
of 25 Rj aperture, was high at beginning of 2019, then lower after
wheel change.  But lower envelope post wheel change looks like a
decent match to previous year's lower envelope.  Lower envelope is
pretty consistent with bias level & upper is only 50 R, so we are
probably not too far away from 

On-band raw is at least 100, but the drop might have an effect.

So in 2018 and 2019, raw on-band and off-band followed the same basic
trend.  High at first then a sharp drop.  In both cases, they are much
smaller than the on-band.  In the aperture sums, these are scaled by
ADU2R, so affected by any systematics in that quantity.  OFFSCALE is
just the ratio of the images

--> start to think about a iPython/Spyder notebook for this to keep
    track of all of these plots.

In any case, if the off-band goes down, off-band subtraction should go up.

ReduceCorObs.py reduce --tree --movie --start 2019-04-01

Oops forgot the python3 -W 

Thu Jun 06 13:40:34 2019 EDT  jpmorgen@snipe

python3 -W ignore ReduceCorObs.py reduce --tree --movie --start 2019-05-29

Sun Jun 09 15:40:42 2019 EDT  jpmorgen@snipe

Looking at doing offset +/- 10 degrees.  This would be a WAITZENDIST
or equivalent object with a TargetStart user action of something like
offset n e

Target.Tags.Offset

Mon Jun 10 07:48:00 2019 EDT  jpmorgen@snipe

Maybe the easier way is 

TAG DECoffset=600
TAG RAoffset=600

And then I intercept it with
Target.Tags.RAoffset
Target.Tags.DECoffset

Sat Jun 15 01:29:23 2019 EDT  jpmorgen@snipe

Trying to see when IoIO.py stopped talking to guidebox moving system
in MaxIm

python3 -W ignore ReduceCorObs.py reduce --tree --movie --start 2019-06-07

--> Need to test this with the latest version of MaxIm more carefully

Here is when the problem started.  So I have had bad data through the
height of opposition

'2019-05-21 09:27:20,331', 'precisionguide', 'ERROR', 'Failed to center target to 5 pixels after 3 tries'

Interestingly, this is a week _before_ I installed the new MaxIm.
Though there are just lots there.  Seems more consistant after 2019-05-28

--> Is this after I changed my settle logic?

Wait a minute, it looks like it is Setting to a value and that gets
set back rather than moved forward!

'2019-05-30 08:54:07,876', 'precisionguide', 'DEBUG', 'move_with_guide_box: total guider dpix (X, Y): [-3.39641997  0.02939587]'
'2019-05-30 08:54:07,877', 'precisionguide', 'DEBUG', 'norm_dp: 3.39654717748'
'2019-05-30 08:54:07,878', 'precisionguide', 'DEBUG', 'Number of steps: 6'
'2019-05-30 08:54:07,880', 'precisionguide', 'DEBUG', 'Delta per step (X, Y): [-0.56606999  0.00489931]'
'2019-05-30 08:54:07,884', 'precisionguide', 'DEBUG', 'Setting to: [ 342.00390681  268.00846987]'
'2019-05-30 08:54:18,846', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.31722304181632055, 0.43297858489057556)'
'2019-05-30 08:54:18,847', 'precisionguide', 'DEBUG', 'GUIDER SETTLED TO 0.5 GUIDER PIXELS'
'2019-05-30 08:54:18,851', 'precisionguide', 'DEBUG', 'Setting to: [ 341.43002376  267.99641542]'
'2019-05-30 08:54:32,542', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.23236243567748174, 0.2960933516362686)'
'2019-05-30 08:54:32,545', 'precisionguide', 'DEBUG', 'GUIDER SETTLED TO 0.5 GUIDER PIXELS'
'2019-05-30 08:54:32,558', 'precisionguide', 'DEBUG', 'Setting to: [ 342.00390681  268.00846987]'
'2019-05-30 08:54:46,276', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.23094810103125013, 0.27700698222427078)'
'2019-05-30 08:54:46,277', 'precisionguide', 'DEBUG', 'GUIDER SETTLED TO 0.5 GUIDER PIXELS'
'2019-05-30 08:54:46,279', 'precisionguide', 'DEBUG', 'Setting to: [ 341.43002376  267.99641542]'
'2019-05-30 08:55:00,080', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.28032411799176443, 0.34570170714765858)'
'2019-05-30 08:55:00,081', 'precisionguide', 'DEBUG', 'GUIDER SETTLED TO 0.5 GUIDER PIXELS'
'2019-05-30 08:55:00,088', 'precisionguide', 'DEBUG', 'Setting to: [ 342.00390681  268.00846987]'
'2019-05-30 08:55:13,884', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.23200027976447513, 0.30992809207033467)'
'2019-05-30 08:55:13,886', 'precisionguide', 'DEBUG', 'GUIDER SETTLED TO 0.5 GUIDER PIXELS'
'2019-05-30 08:55:13,891', 'precisionguide', 'DEBUG', 'Setting to: [ 341.43002376  267.99641542]'
'2019-05-30 08:55:27,625', 'precisionguide', 'DEBUG', 'guider AV, RMS = (0.22743476262584633, 0.28390310674008146)'

So I am using
        log.debug('move_with_guide_box: total guider dpix (X, Y): ' + str(dp_coords[::-1]))
        log.debug('norm_dp: ' + str(norm_dp))
        log.debug('Number of steps: ' + str(num_steps))
        if num_steps > self.max_guide_num_steps:
            # We can't do this, so just bomb with a False return
            # and let the caller (usually center) handle it
            log.error('Maximum number of steps (' + str(self.max_guide_num_steps) + ') exceeded: ' + str(num_steps))
            return False
        log.debug('Delta per step (X, Y): ' + str(step_dp[::-1]))
        for istep in range(num_steps):
            # Just in case someone else is commanding the guide
            # box to move, use its instantaneous position as the
            # starting point of our move !!! TRANSPOSE !!!
            cp_coords = np.asarray((self.CCDCamera.GuiderYStarPosition,
                                    self.CCDCamera.GuiderXStarPosition))
            tp_coords = cp_coords + step_dp
            log.debug('Setting to: ' + str(tp_coords[::-1]))
            # !!! TRANSPOSE !!!
            self.CCDCamera.GuiderMoveStar(tp_coords[1], tp_coords[0])
            if self.horizon_limit():
                log.error('Horizon limit reached')
                return False
            self.guider_settle()

--> when did I turn off the guidebox mover?

Last entry in log:

'2019-05-09 11:53:38,624', '__main__', 'DEBUG', 'GuideBoxMover is moving the guidebox by [-0.03328314 -0.50103594] arcsec'

The next failure was

'2019-05-21 09:27:20,331', 'precisionguide', 'ERROR', 'Failed to center target to 5 pixels after 3 tries'

So turning off GuidBboxMover is not the proximal cause of the problem.

Points to MaxIm

Can I get around this just by staring up old MaxIm?

Try that tonight.  Send off a MaxIm forum post

Thu Jun 20 20:39:01 2019 EDT  jpmorgen@snipe

Still waiting for MaxIm response

Work on logic for offset 

Target is an object that may have property .Tags
http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/planfmt.html
#TAG mytag=value with spaces

When I check for it, do I use null or undefined?  Null comes from an
assigned value.  Undefined comes from not being defined yet.

Bob seems to define Target.Tags === null by default and then tags are
inserted into the structure.  So when I check for 

(Target.Tags.IoIO === undefined)

that is the right thing to do, since there may be Tags, but IoIO has
not been assigned.

So in TargetStart, I want Target.Tags === null all tags other than

Target.Tags.RAoffset
Target.Tags.DECoffset
Target.Tags.IoIO

to default to the current eastward offset

Maybe the easiest way to do that is by checking for the tags that need
processing first, having them return true, and then

Fri Jun 21 08:47:24 2019 EDT  jpmorgen@snipe

Target.DEC is not working for me.  That is because it is Target.Dec

OK, that works, but how am I going to indicate that the target is
Jupiter but the coordinates are really for an offset?  I could try to
add a FITS card to the file in ImageEnd or perhaps better
ImageComplete in UserActions.  Or I could recognize what is going on
in the reduction script, since the OBJECT would be Jupiter but I would
be 10 degrees away.  The later disrupts my logic for making sure
objects labeled as Jupiter are really close to Jupiter.

Looking at AcquireSupport.wsc and see

Set plate = CreateObject("PinPoint.Plate")

plate.AttachFITS File
plate.WriteFITSDouble "FOCALLEN", fl * 1000.0, 1
plate.UpdateFITS

Where presumably File is the filename

or maybe
plate.writeFITS(imagePath);    
plate.DetachFITS();                                     // Done with image file

Sun Jun 23 14:01:29 2019 EDT  jpmorgen@snipe

Ack.  Offset is not working for ephemeris-calculated bodies.  Seems to
be because Bob calls 

Target.UpdateEphem()

in lots of places

line 874
line 912 UserActions.TargetStart
Log said it looked OK there

Next UpdateEphem is 1295 in the pointing update request logic

It is almost like I would need to trick ACP into have Jupiter be the
target until the initial TargetStart but then turn off its Jupiterness

/cygdrive/c/Program Files (x86)/ACP Obs Control/Plan.wsc
Line 2982 and line 2507 suggests that if I set the target type to 1
(however that is done), it might stick as a J2000 object with a
tracking rate

TargetStart: Original RA =  5.179223398738063
TargetStart: added = -600 arcmin RA
TargetStart: New RA: 4.512556732071396
TargetStart: Original DEC =  22.50553228918602
TargetStart: added = -600 arcmin DEC
TargetStart: New DEC: 12.505532289186021
TargetStart: turning off subsequent ephemeris calculations so offset calculated correctly

Wait a bit

TargetStart: Original RA =  5.179402913005819
TargetStart: added = -600 arcmin RA
TargetStart: New RA: 4.512736246339152
TargetStart: Original DEC =  22.505826538531312
TargetStart: added = -600 arcmin DEC
TargetStart: New DEC: 12.505826538531312
TargetStart: turning off subsequent ephemeris calculations so offset calculated correctly

OK, so ephemeris is changing between runs

OBJECT  = 'Venus   '           / Target object name
RA      = '04 30 45.20'        / [hms J2000] Target right ascension
OBJCTRA = '04 30 45.20'        / [hms J2000] Target right ascension
DEC     = '+12 30 19.9'        / [dms +N J2000] Target declination
OBJCTDEC= '+12 30 19.9'        / [dms +N J2000] Target declination

OBJECT  = 'Venus   '           / Target object name
RA      = '04 30 45.85'        / [hms J2000] Target right ascension
OBJCTRA = '04 30 45.85'        / [hms J2000] Target right ascension
DEC     = '+12 30 21.0'        / [dms +N J2000] Target declination
OBJCTDEC= '+12 30 21.0'        / [dms +N J2000] Target declination

Works!

Wed Jun 26 21:11:56 2019 EDT  jpmorgen@snipe

Hey!  I might be able to use WAITINLIMITS for Jupiter offsets instead
of WAITZENDIST!  The target setup does the Tc.UpdateEphem() and then
calls the UserActions.TargetStart, which tweaks the coordinates
Target.RA and Target.Dec

python3 -W ignore ReduceCorObs.py reduce --tree --movie --start 2019-06-14

Wed Jul 03 14:32:59 2019 EDT  jpmorgen@snipe

ReduceCorObs.py movie --concatenate

Still has a problem.  Debug later

Fri Jul 05 10:19:06 2019 EDT  jpmorgen@snipe

Ah Ha!  It looks like I need to update
ERROR: MoviePy error: failed to read the first frame of video file /data/io/IoIO/reduced/20190618/Na_SII.mp4. That might mean that the file is corrupted. That may also mean that you are using a deprecated version of FFMPEG. On Ubuntu/Debian for instance the version in the repos is deprecated. Please update to a recent version from the website. Bad Na_SII movie in /data/io/IoIO/reduced/20190618 [__main__]

No.  I am up-to-date.  The real problem seems to be when I tweaked
some parameters in the movie for 2019.  

python3 -W ignore ReduceCorObs.py reduce --tree --movie --start 2019-07-04

If that works, so a 

ReduceCorObs.py movie --recalculate --tree

That didn't work.  The break seems to happen at 

ERROR: MoviePy error: failed to read the first frame of video file /data/io/IoIO/reduced/20190321/Na_movie.mp4. That might mean that the file is corrupted. That may also mean that you are using a deprecated version of FFMPEG. On Ubuntu/Debian for instance the version in the repos is deprecated. Please update to a recent version from the website. Bad Na movie in /data/io/IoIO/reduced/20190321 [__main__]

DEBUG: 128 good [Na_SII] movies found [__main__]

Maybe I can only have 2**7 movies concatenated at a time?

Tried to stop at 128 + that still got 20190321

"C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" center --ObsClassName CorObsData
Doesn' work any more


python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1200 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190717\Jupiter-S001-R001-C001-R.fts"

When target was centered, just started guider.  Perterbid

Flip is on. [precisionguide]
ERROR: Received the following error.  Attempting to return gracefully: (-2147352567, 'Exception occurred.', (65535, 'MaxIm DL 6', 'Cannot Start Guider', None, 0, 0), None) [IoIO]

Well, that is not encouraging, but I did see the center moving.  I
think the above error is from Jupiter being in the clouds and too dim
to select as a guide star.  Sets it to 0,0

Sat Jul 20 01:43:24 2019 EDT  jpmorgen@snipe

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1200 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20190720\Jupiter-S001-R001-C001-R.fts"


Confirmed on other side of meridian.  Increasing Y, Y error goes up,
but Jupiter noticeably moves up, not down 

Sat Jul 20 20:36:21 2019 EDT  jpmorgen@snipe

Daniel's ~/py/IoIO/foster2clarityII.py

python "\\snipe\jpmorgen\py\IoIO\foster2clarityII.py"


AstroAlert.Weather
ACP.BoltwoodFile

Sun Jul 21 21:32:17 2019 EDT  jpmorgen@snipe

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\foster2clarityII.py"

Thu Jul 25 21:07:41 2019 EDT  jpmorgen@snipe

Heard back from MaxIm people and they insist that the MaxIm 6.13 way
of doing things was an error and they really meant to do it the way it
is currently, which seems like it is moving the guide point to X and Y
that are not correct

"\\snipe\data\io\IoIO\observing\MaxIm DL\test_GuiderMoveStar.vbs"

Hmm.  It does look like it is doing the right thing

Weird.  Trying to run the second time didn't work.  Maybe I have a
non-square guider...  Fixed initial positioin 

Script says guide star position
503, 418

+10, +5
Move guide star position to
513 423

but final 493, 413
and window still indicates 503, 418

Guide star does flash to the left suddenly and slightly up

Wait, I have the old version, not beta

OK, the old version and the beta behave in the opposite way.

Final GuideStarXYPosition (515, 423), but GUI reporting 505, 418

Fri Jul 26 07:54:12 2019 EDT  jpmorgen@snipe

use old MaxIm

Guide star 503, 418
Move to 513, 423
GUI reports 506, 418
Final GuidestarXYPostiion 516, 423

But now new version is not consistent!

Mon Jul 29 18:11:41 2019 EDT  jpmorgen@snipe

With Beta version

Guide star postiion (504, 418)

Thu Aug 01 21:03:38 2019 EDT  jpmorgen@snipe

Latest patch from Owen.  I confirm that the guide box now moves in the
correct direction, down and to the right, leaving the star up and to
the left before it is brought in.  And the script reads and reports
the expected XY values.  However, the GUI does not.

The first time I ran it, the GUI values were stuck on 503, 418.  The
second time, they were 513, 423 until I quit, in which case they went
back to 503, 418

Thu Aug 15 18:39:41 2019 EDT  jpmorgen@snipe

--> made a change in precisionguide that fixes issue with MaxIm
    resetting where the guide star is when the guider is stopped.  I
    don't need it in my current activity, but it is nice to keep track
    of the issue.  --> have not uploaded this, since I am first trying
    the beta version of MaxIm to make sure offset guiding works

--> copied new precisionguide over.  Make sure it doesn't mess things up
Compiled OK but new guider_stop not yet called

-->
http://forums.dc3.com/showthread.php?12432-W10-Update-1903-and-8-2-Critical-Issues&p=77254#post77254
If you want to do some hacking, you can add a line to register your UserActions. Edit it into C:\Program FIles (x86) ACP Obs Control\RegisterWSC.bat. Part of the self-repair is to run that shell script.

Mon Aug 19 00:19:27 2019 EDT  jpmorgen@snipe

Ack!  MaxIm crashed because guide star too dim because of clouds.  But
didn't seem to be because of the new logic in script

Mon Aug 19 12:09:13 2019 EDT  jpmorgen@snipe

python3 -W ignore ReduceCorObs.py reduce --tree --movie --start 2019-07-06

Sat Nov 02 20:53:14 2019 EDT  jpmorgen@snipe

--> disable autoshutdown = True is what I need to keep camera from
    shutting down!  Daniel is a genius

Sun Nov 03 20:43:18 2019 EST  jpmorgen@snipe

python "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\IoIO.py" ACP_IPT_Na_R 1200 "C:\Users\Public\Documents\ACP Web Data\Doc Root\images\jpmorgen\20191103\Jupiter-S001-R001-C001-R.fts"


Still not doing it.  Try to make guider work harder when first taking images

Sun Nov 03 20:54:39 2019 EST  jpmorgen@snipe

Near guider trackintg 89

sum_on_ND_filter =  952794.761179

        P.MC.move_with_guider_slews(np.asarray([10,2])/3600)

Got it to move 4 steps

Only seemed to be a problem on the first short exposure.

1s exposures are not doing it
10s exposures are not doing it, but I am on a Vega, not Jupiter.

Mon Nov 04 20:20:43 2019 EST  jpmorgen@snipe

10s on Jupiter not doing it

20s on Jupiter didn't seem to do it

Try adding a center_loop after

Mon Nov 04 20:33:33 2019 EST  jpmorgen@snipe

Might get a good Io next to Jupiter!

Tue Nov 05 10:47:37 2019 EST  jpmorgen@snipe

So

Date	Mag	Dia
Aug 20	-2.3	40
Nov 5	-1.9	33

(M1-M2) = -2.5*np.log(f1/f2)

10**((-2.3 + 1.9)/-2.5)
1.4454397707459274

rsync -auvn  "/cygdrive/c/Users/PLANETARY SCIENCE/Documents/MaxIm DL 6/GuiderTrackingImages" "jpmorgen@cpe-184-153-133-119.maine.res.rr.com:/data/io/IoIO/observing/MaxIm DL/"

Fri Dec 13 22:01:25 2019 EST  jpmorgen@snipe

Looking a little more carefully at AcquireImages.js and finding that
it will probably work OK.  Not positive above how it will handle
autoguiding initiated in precisionguide, but if it looks to MaxIm, it
should be no problem

Mon Feb 24 19:08:54 2020 EST  jpmorgen@byted

Check on latest ccdproc version.

In any case, I think I want to do things in stages rather than all at
once. 

Sat Feb 29 16:04:52 2020 EST  jpmorgen@byted

Look into checking in last IoIO.py version before updating filter
positions for correct placement since 4/1/2019.

IoIO.py looks reasonable
precisionguide.py looks reasonable
read_ap.py is OK
Daniel's foster2clarityII stuff is OK

Commit message might be:
2019 V, U filters were really H2O+, RC (affects 4/1/2010--3/1/2020)

Then I correct the filters as of this year and recommit:
2020 Filters and slot numbers confirmed to line up

It is a separate question to figure out what to do about reduction
. Copy all raw data from 2019 into separate directory and re-copy
fixed to working raw
. Copy only affected files

I think I might prefer the later.  It also gets me some practice with
the incremental way of doing things.

see if I can change mod date

https://docs.python.org/3/library/os.html -> os.utime

It looks like the answer to that is yes.  So I can presumably just fix
the filters and put a note in the HISTORY

Look back a year ago to
Fri Mar 15 05:51:44 2019 EDT  jpmorgen@snipe
for notes on wanting to split precisionguide up so I can get better
access to objects for reduction purposes.

So consider PrecisionGuide -> PrecisionGuideBaseClass

And then I would inherit that into things like CorGuide,
BrightestStarGuide, and PinpointGuide.  Each of those objects would
need their own property to manage the specifics and they would be in
modules (all lower case) that would have argparse stuff unique to
their arguments.  Separately, I would have modules containing the
ObsData: CorObsData, BrightestStarData and PinpointData whcih could
then import into reduction modules.

--> I might be able to do this in stages, where I just pull out
    CorObsData as a module for now.

Fri Mar 20 20:06:24 2020 EDT  jpmorgen@snipe

Reading documentation in UserActions and finding that Bob wants all
telescope and camera control done with Util.ScriptTelescope and
Util.ScriptCamera for access locks to work.  Ah, but I am the only one
using this, so that was not an issue.  But that might also help
weather interlocks.  Either that or I do my own weather interlock

Mon Mar 23 09:37:38 2020 EDT  jpmorgen@snipe

Working on pier flip problems now that guider is rotated by 90
degrees.  See IoIO.notebk for log of problem.

Looking at last year's astrometry and this year's astrometry

/data/io/IoIO/raw/2019-04_Astrometry/Guider_Astrometry_East_of_Pier.fit
CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   1.28656273130E+002 / X-axis coordinate value
CRPIX1  =   3.76000000000E+002 / X-axis reference pixel
CDELT1  =   1.22992990806E-003 / [deg/pixel] X-axis plate scale
CROTA1  =   2.75762353835E+000 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   1.83965522615E+001 / Y-axis coordinate value
CRPIX2  =   2.90000000000E+002 / Y-axis reference pixel
CDELT2  =   1.18778516650E-003 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   2.75762353835E+000 / [deg] Roll angle wrt Y-axis
CD1_1   =   1.22850564169E-003 / Change in RA---TAN along X-Axis
CD1_2   =  -5.71455686251E-005 / Change in RA---TAN along Y-Axis
CD2_1   =   5.91731955806E-005 / Change in DEC--TAN along X-Axis
CD2_2   =   1.18640970400E-003 / Change in DEC--TAN along Y-Axis                 

/data/io/IoIO/raw/2020-03_Astrometry/Guider_Astrometry_East_of_Pier.fit
CTYPE1  = 'RA---TAN'           / X-axis coordinate type
CRVAL1  =   7.86597706831E+001 / X-axis coordinate value
CRPIX1  =   3.76000000000E+002 / X-axis reference pixel
CDELT1  =   1.22962673968E-003 / [deg/pixel] X-axis plate scale
CROTA1  =   8.75238205289E+001 / [deg] Roll angle wrt X-axis
CTYPE2  = 'DEC--TAN'           / Y-axis coordinate type
CRVAL2  =   4.78872912158E+001 / Y-axis coordinate value
CRPIX2  =   2.90000000000E+002 / Y-axis reference pixel
CDELT2  =   1.18634500061E-003 / [deg/pixel] Y-Axis Plate scale
CROTA2  =   8.75238205289E+001 / [deg] Roll angle wrt Y-axis
CD1_1   =   5.31248338048E-005 / Change in RA---TAN along X-Axis
CD1_2   =  -1.18523727452E-003 / Change in RA---TAN along Y-Axis
CD2_1   =   1.22847860012E-003 / Change in DEC--TAN along X-Axis
CD2_2   =   5.12548881369E-005 / Change in DEC--TAN along Y-Axis

|CD1_1   =   1.22850564169E-003 / Change in RA---TAN along X-Axis (east right)
-CD2_1   =   1.22847860012E-003 / Change in DEC--TAN along X-Axis (north)
|CD2_2   =   1.18640970400E-003 / Change in DEC--TAN along Y-Axis (north)
-CD1_2   =  -1.18523727452E-003 / Change in RA---TAN along Y-Axis (east down

On West of Pier, the CDELTs are negative in both axes this year and
last year.  That makes sense from pier flipping

Using MaxIm 0 on top reference on East_of_Pier (MaxIm normal)
Last year east right, N down 
This year, east up, N right

So indeed, the readout of the camera is the same and it has just been rotated ~+90 deg.


import numpy as np
cd2019 = np.asarray(((1.22850564169E-003, -5.71455686251E-005), (5.91731955806E-005, 1.18640970400E-003)))
cd2020 = np.asarray(((5.31248338048E-005, -1.18523727452E-003), (1.22847860012E-003, 5.12548881369E-005)))

N = np.asarray((0,1))
np.dot(cd2019, N)

np.degrees(np.arccos(cd2019[0,0]))
-np.degrees(np.arcsin(cd2019[0,1]))
np.degrees(np.arcsin(cd2019[1,0]))
-np.degrees(np.arccos(cd2019[1,1]))

89.92961179391786
>>> 0.003274199901875491
>>> 0.0033903743690491023
>>> -89.93202371524056

So the CDs aren't really the same level of accuracy as CROTA that Bob puts in

Am I useing the flipped astrometry for the E calculation?

Mon Mar 23 22:32:05 2020 EDT  jpmorgen@snipe

Working with Venus, got thigns to work in ACP mode with MaxIm connected or not
Procyon works at least with MaxIm connected.

Ah, the problem seems to be that when I actually try guiding, the
guider goes in the wrong direction

So I would need to turn off auto pier flip

Hey, got Procyon to work on both sides of the pier when MaxIm is
connected and wanting to AutoPierFlip.  I turn that off and all is happy

See if I can't do weather object real quick

ACP.BoltwoodFile

Just not working.  AstroMC.Weather is.  Test 

Wind speed 8, 16, 999. Change to 0, 1.  That did it!

Whew.  Weird connections, but it actually works.

Try clouds.  AstroMC did an Analyzing thing that finally shut down after a while.

-5 0 30

not getting assertion error to print as I expect.  That is because I
need a second argument ('stuff to print')

Wed Mar 25 12:51:10 2020 EDT  jpmorgen@snipe

Need to make a part of IoIO.py that moves Jupiter over to the side and
takes observations for eclipse ingress/egress.  Pre-opposition is
ingress, so this is the control time

In two days there is an ingress at 18 deg elevation.  Only 10 minutes
after rise above observatory wall!

I would want to pass some arguments at some point to tell me where the
center of the ND filter is plus some

    with pg.PrecisionGuide("CorObsData", "IoIO", ) as P:

--> I would need to tweak the desired_center @property, possibly
    adding another property: offset

For this first one consider just waking up early and doing it by hand
with Jupiter out of the ND filter

Sun Mar 29 18:40:07 2020 EDT  jpmorgen@snipe

Working on MaxIm

python \\snipe\jpmorgen\py\IoIO\precisionguide.py test_center

Sun Mar 29 22:20:52 2020 EDT  jpmorgen@snipe

Try changing filter looking at Venus

cd "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\"
IoIO.py center --ObsClassName CorObsData

It is doing it but not just when I change filters.

And it may be the target position not being fractional

03:10:21*1	MaxIm DL Version 6.21 started on IOIO1U1

Experiment tailed off trying to recenter afterwards

Ack.  Track log is not persistent

--> https://www.devdungeon.com/content/python-catch-sigint-ctrl-c

Wed Apr 01 15:12:14 2020 EDT  jpmorgen@snipe

Grumpy about MaxIm response

"\\snipe\data\io\IoIO\observing\MaxIm DL\test_GuiderMoveStar.vbs"

503, 418
513, 423
...

cscript "\\snipe\data\io\IoIO\observing\MaxIm DL\test_GuiderMoveStarBug.vbs"

XORGSUBF	= 497 /Subframe X position in binned pixels            
YORGSUBF	= 407 /Subframe Y position in binned pixels            

19:57:44*2	Debug message logging is on

Note that in simulator

Mon Apr 06 16:15:28 2020 EDT  jpmorgen@snipe

Trying to get weather working through ACP

OK, so ACP.weather is not registered.  No the error seems to be that
Bob's ACP stuff is 32 bit and my python is 64 bit.

cscript "\\snipe\data\io\IoIO\observing\ACP\test_weather.vbs"

doesn't work

try as C:\Windows\SYSWOW64\cmd.exe as per /cygdrive/c/Program Files (x86)/Common Files/ASCOM/MPCCOMET/Readme.txt

Works better as far as finding the object, but still permission denied
when trying to read attributes.  I get the distinct feeling that this
can only work from within Bob's ecosystem.

Ahh.  Comparing this to MPCCOMET.wsc and seeign that there is an
object id="Util" in Bobs with a progid="ACP.Util", whereas with
MPCCOMET, it is Shell and WScript.Shell

! Got it to work!  Instantiated ACP.Util!

Tue Apr 07 16:34:05 2020 EDT  jpmorgen@snipe

Looking back at ccdred/CCDred, which was going to form the basis of my
new reduction scheme.

Now I am looking at the CCDproc iterators a little more and find that
if I do it there way, I might have more readable code.

So they have iterators with code.  I am thinking of having objects
with methods that are triggered when the file is processed.  These are
not incompatible.  Or are they?  I was thinking of absconding with the
ImageFileCollection to tweak it to store information.  Their model is
to keep the integrity of the original ImageFileCollection and then
loop through it using autosaving iterators to do operations.  But I
guess I was going to process information like ephemerides basde on
what I built up in the headers

So really ccdred is not ccdred but ImageFileCollectionHacker

OK, I recall now I had the issue with how to get a comment in the FITS
header.  This is easy with their iterator and code as you open each
file.  I was sort of thinking that I would have an object, a ccdred,
that would store everything needed for calculation.  But that gets a
little too ridged.

Consider starting with something simple to get back in the saddle
again.  Have some biases and flats

Wed Apr 08 12:12:25 2020 EDT  jpmorgen@snipe

So the problem with handling the entire imagefilecollection as one
group of keywords that gets modified and then written back to the
files is that ccdproc allow only partial lists of keywords to be read
into the summary table.  As I do the work, I hear the disk being read
only one, which suggests that the disk and OS are doing the caching so
that I don't need to in my code.  In other words, I can write
inefficient code that creates and recreates the summary and I don't
lose that much time. 

OK, I have ccdproc 1.3.0-5 installed via aptitide.  They are
developing 2.1.1, which has some documentation I am not seeing
features for.  Some of them looks pretty useful.  Experiment with
using latest version for my bias_dark experiments.

Plus, they have a refresh method that does what I want

OK, looking at their combiner object

Tue Apr 14 18:34:05 2020 EDT  jpmorgen@snipe

Got some stuff to run.  See IoIO.notebk for physical interpretation.
Dealing with software here.  If I add to the csv file, I will be
duplicating entries when I re-run.  This is different than when I
reduced all files in their own date directories and rewrote the file
in each directory.  I then ran a separate process to combine

Wed Apr 15 15:43:52 2020 EDT  jpmorgen@snipe

OK, so give up on the CSV file and deal with things using astropy an
table culled form the data in the summary directory.

Working on readnoise.  Where do I want that documented?

Cool!  I am seeing that the std goes way down in the combined bias,
relative to the individual stds.  Still wondering if I should be
keeping track of bad values of std.

So when there is a big bias ramp, std should go up relative to rdnoise.

Wed Apr 15 22:19:19 2020 EDT  jpmorgen@snipe

Wow!  I am consuming 46% of snipe's memory with

bias_combine('/data/io/IoIO/raw/20191014')

That seems to bobble around to 27% during the cycle of
combiner.sigma_clipping

Ah, that is when I had 153 files because I misunderstood the directive
for repeats!

So when I go from 10 to 5 files, the STD goes from 5.7 up to 7.6.
With 154 files, I got down to 3.7 at -5C At -15 C that many files got
to 2.3!

So for a final work-up I could potentially do the many bias.  I have a
balance.  For 150 files, it took 50% = 32G
150*100E6/1E9
15.0

And the ccdproc people say it is not memory efficient, so that is
where I am taking the 30G.  So it scales

2200*2750/1E6*(8*2 + 1)
102.85

That is roughly the size of the file assuming 2 double-precision
extensions plus a mask.  I double that because Combiner copies the ccds.

OK, the max number of biases I can run is 233 if I stick to 75% of
the memory.  The problem is I don't know how many files are in the
individual directories until I get there.  But if I say I am going to
max out memory I do the 233.  If I want to go faster, I have to divide
that by the factor I want to go faster.

Fri Apr 17 10:53:41 2020 EDT  jpmorgen@snipe

I wonder if the bias is more correlated to the external temperature
than the CCD temperature.  High external temperature seems to lead to
lower bias values.

So the fundamental problem is that there is no overscan on these CCDs,
although in the small filters, I have a handy area for that.  But for
that area, I only have dark current + bias.

Fri Apr 17 20:52:19 2020 EDT  jpmorgen@snipe

I have been hearing one source say that the overscan is a simple
addition on the bias and the bias is the pattern.  So I should see if
my biases with mean subtracted end up being similar to each other.  If
so, or even if the pattern is temperature sensitive but the offset
level is external temperature sensitive, I should be able to work
backward with darks and the bias pattern to solve for the overscan
level.  This depends critically on having a steady temperature while I
record the darks.  I also might want to record more darks at some
point, though they are supposed to scale OK with exposure time.  But I
have a range of exposure times over which to test that even if the
longer ones aren't perfect for stacking.

So for the darks I want to find the biases that are closest in time
that are the same temperature.  And probably have a minimum separation
in time as well.  When I subtract the stacked biases, I should get at
the true dark current right at that time.  Bias ramping should go
away, since that dark current during the readout.

So dark is going to be scaled accurately from exposure time.  The bias
pattern comes next based on temperature (again, osmethign I can check)
and then I add a pedistal to match the edges of the small filters and
maybe eventually a dark exposure recorded occasionally

d(ccdT) + b'(ccdT) + os(ambientT, or whatever) = background

The only trick is that we have to find a background on the ccd.  Once
we have set that, we can bridge for other filters that don't have
that.  Eventually, we might be able find the ambient temperature
function for os.

OK, so darks need to have a bias after them so I can tell if they are
OK.  And I should probably group the biases by time as well

Sun Apr 19 20:14:10 2020 EDT  jpmorgen@snipe

bias_combine('/data/io/IoIO/raw/20200419', show=True)

The -20C evening biases came in at 1860 or so.  The AM ones at 1940.
Wow!  THere were only 572 erant pixels!  Seems suspicous
-15.24 had a consistent ramp from 1918 up to 1932

std suggests some potential ccd cooling during that time.  Or it could
be electronics cooling too. 

Wed Jul 01 21:57:04 2020 EDT  jpmorgen@snipe

Daniel wants to help me with the UserActions.wsc via his new GitHub
account.  Not quite right to put that on the main IoIO stuff, at least
not yet.  Eventually, having some sort of package that installs
everything in the correct place.  So it would have source code and
installer.  But for now consider having the 

https://stackoverflow.com/questions/22580873/how-can-i-configure-magit-to-use-my-github-user-name

git config --global github.user jpmorgen
git config --global user.name jpmorgen
git config --global user.email jpmorgen@psi.edu

remote name UserActions
https://github.com/jpmorgen

Thu Jul 02 00:49:22 2020 EDT  jpmorgen@snipe

ACP.BoltwoodFile change to WeatherSim.Weather

Having trouble debugging UserActions.wsc after Daniel and I made some
changes.

Fixed that.

So as Daniel poitns out, this doesn't work when the weather isn't connected.

Thu Jul 02 09:41:24 2020 EDT  jpmorgen@snipe

--> Consider making StowAndClose a tag!

I think I am doing the GitHub thing wrong by not merging Daniel's
changes properly on IoIO1U1

Thu Jul 02 11:47:58 2020 EDT  jpmorgen@snipe

Hey!  I have an idea about how to proceed with ACP cusom development!
I can check in the whole ACP tree (rather with lots of .gitignores)
and add to things there, like maybe in the Scripts directory, which I
currently have in Desktop\IoIO\Scripts.  That would keep everything
together although there would still be some things like the Scheduler
StartupObs....  But still, I like the way that is going to be able to
develop on greyhound with simulators and push and pull to IoIO1U1 for
production.

Update Cygwin to see if that helps the problems I was having with
password entry on GitHub/magit

Well, that doesn't seem to help.  Frustrating but not end of world.
Can work with desktop client or command line.  Remove magit so I am
not confused in the future.

Wed Aug 19 23:10:11 2020 EDT  jpmorgen@snipe

Hmm.  In a situation where weather is broken, but weather is good, so
want to run without weather.  Figured out how to trick it in
UserActions.  Need to trick it in precisionguide

Copied over precisionguide with modification of FakeWeather

Not working for some reason.

cd "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\Scripts\"
IoIO.py center --ObsClassName CorObsData

Wed Sep 02 11:32:29 2020 EDT  jpmorgen@snipe

OK, got that all worked out and also new astrometry _and guider
calibration_ as per notes of earlier this morning in ~/IoIO.notebk

Fri Sep 04 10:28:13 2020 EDT  jpmorgen@snipe

I should probably add a correction for 1/cos(DEC) in my offsets

/cygdrive/c/Program Files (x86)/ACP Obs Control/UserActions.wsc

As used, the offsets are in arcminutes, so I really do expect
arcminute in angle, not RA.  So where do I want to do the correction?
I could do it when I first put thing into Util.Script.RAoffsets[iTgt],
which happens in a couple of places.

I need to be mindful of Util.Script.RAoffset and what that reads in.
It may be the best thing to do is make the conversion just before I
reset the Target.RA

function RAOff_arcmin_to_hrs(Target)
{
    // Calculate correction factor to apply to RA offset in arcminutes
    // so that it can be added to the target RA in hours
    var radec = Math.abs(Target.DEC)
    // Make sure not to cause problems at extremely high DEC
    radec = Math.min(radec, 80);
    radec = radec * Math.PI / 180.;
    var raf = 1.0/60.0 * 24.0/360.0 / Math.cos(radec);
    return raf;
}


Maybe this should be a function: RAOff_factor(Target)

OK, getting this.  But I am finding inconsistent results when I try to
subtract to go back, since I am using the current target DEC.  What I
really want is to store the old values somehow.

Whew.  That was a bit of a pain to work with GitHub desktop.
Basically, I needed to clone into an empty directory and then move the
.git into the ACP Obs Control directory.  Then I had a bunch of files
that were changed.  Rather than .gitignore all of them, I just
deselected all of them and then selected UserActions.wsc and committed
that.  There is a little square in the bottom left to write the commit
message

--> remember to pull on ioio1u1.

Sun Sep 06 09:49:15 2020 EDT  jpmorgen@snipe

Ack!  I have other work on ioio1u1 that I haven't pushed to master
properly.

Sun Sep 06 15:50:07 2020 EDT  jpmorgen@snipe

Awesome!  That worked!  I committed to master on ioio1u1.  Then
pushed to remote.  It automatically resolve the conflicts, which were
not real conflicts, since they were independent.

Mon Jan 04 18:51:57 2021 EST  jpmorgen@snipe

Doing some cleanup work.  Moving old files to ~/py/IoIO_obsolete_stuff

ioio.py and ASCOM_namespace.py can be moved there too, but that
will be noted in revision contol.  I should coordinate that with
an edit of README.md and possibly a rename of IoIO.py to ioio.py

On that later point, IoIO.py currently does two things: CorObsData and
the telescope control.  It may be useful to separate those, just like
it might be useful to separate ObsData to a different file for clean
import.  Think about this when I have a chance
