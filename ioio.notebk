[Make a separate software development notebook so my observing
notebook doesn't get mucked up by this stuff]

Wed May  3 01:20:10 2017  jpmorgen@snipe

OK, now that I have Jupiter's center, how do I want to handle it in
real time?  That depends on what is available in the maxim object
namespace.

CCDCamera.ImageArray safearray of Long of size NumX * NumY
containing the values from the last exposure  BINGO!
I need Maxim on puppy.

CCDCamera.GuiderArray analogous for guider

Ah! There are some events that we can monitor, so we can potentially
run in parallel, saving the trouble of loading all of the Python
packages I depend on

CCDCamera.GuiderMoveStar moves the guide star _while tracking_ which
is exactly what I want! (delta move)

CCDCamera.GuiderXStarPosition plus CCDCamera.GuiderXError,
CCDCamera.GuiderYError tell exact position of the guide object


CCDCamera.SetFITSKey ( Key, Value )  Cool!  So I can record FITS
stuff in the raw files!  GetFITSKey returns a key, but you can't
seem to get the whole FITS header

CCDCamera.StartSequence HEY!  So I can do a hybrid interaction,
where I use my existing sequences

CCDCamera.PinPointStatus, ImageScale, PositionAngle, CenterDEC, and
CenterRA get at the Pintpoint stuff, but there seems to be no way to
get the info stored about the scope like the focal length, so this
is stuff we will have to store long-term.

So I envision having MaxIm running and the Python scripts
controlling it.  Lets see if we can really do this

Wed May  3 23:06:14 2017  jpmorgen@snipe

So I can do what I want with CCDCamera.GuiderMoveStar, but I have to
be the one in control of that.  So I need some sort of loop that
updates it periodically.  That would be a good thing to have be an
object, with the property of that object the rate I want, which can
be adjusted by other parts of the module that have that object.
There could be another object that keeps track of the guide scope
flexure...  Hmmm.  My original idea was to keep track of all motion
under the assumption that restarts of the guider picked up just
where the unguided scope motion left off.  I am finding that is not
the case: Jupiter can move around quite a bit when the guider
starts, so I will probably have to start fresh on motion
calculations if I really need to do a reposition.  But while I am
guiding, the motion should be relatively consistent.  So my original
idea was to have a model which set the starting rates.  I guess if
there is a deviation of Jupiter from where I want it, I want to
tweak the value used to move the guide box, but the model can still
do its thing.

Taking a step back, the guide box will have a certain trajectory
which will keep Jupiter perfectly centered.  What we really have is
a trajectory on the main camera and a separate one on the guider,
with the one on the main camera informing the one on the guider.

Trajectory is a listing of:
time, gx, gy, mx, my

We know the plate scales and orientations
(e.g. CCDCamera.GuiderAngle) of the respective cameras, so we can
use that to measure the real offset between the guider and main
scope, whether or not Jupiter is centered.

But fundamentally what we care about is putting Jupiter where we
want it and zeroing its motion.  In offset_guide.py, guide_calc did
the simple delta between adjacent points to calculate new rates.  Ah
HA.  In our move object, we could have space for the model and a
separate space for the measured.  In general, I might want an array
so arbitrary terms can be added, like for guiding on a star for a
faint non-siderial object.  So there could be some sort of a
registration process for the objects that send info to the guide box
moving object

OK, I think I have a good concept of a general guide box moving
object.  The next step is when the telescope takes an image, there
needs to be an analysis that tells us where the object is and where
we want to put it.  That analysis needs to happen in, or at least be
provided to a module that figures out how to tweak the measured
portion of the move object.  That is the module I have been
struggling with thinking about.  If we use the same registration
idea for that, the object finder/center calculators can be easily
added after-the-fact.  The module that does the calculation of the
offset rates that counteract the measured motion and delta from
desired position can then be developed independent of source of
information.

So I now am thinking about a module that uses the measured and
desired positions as a function of time and calculates the
correction rates to feed to the guide box moving object.  This is
where the trajectory concept comes in.  This module accepts a
function that feeds it the input values.  This measurement module
could use CCDCamera_Notify(ceSequenceCompleted)

So the measurement master module, or whatever I want to call it,
would handle all of the interface with MaxIm.  Hmm.  I am finding
that I might want the FITS header, but that does not seem possible.
I can, however, get one card at a time if I know what I am looking
for.  So the MMM could accept a list of FITS keys (e.g. FILTER,
DATE-OBS, etc.) which it would query when a new image is available.
It would pass the image and any desired FITS keys to the module that
does the measurement.  It could return None, if it declines to do a
measurement (wrong filter [might want to measure multiple quantities
like filters separately]).  But if it provides a measurement, the
MMM will process it.  Maybe different filters can be handled by
having different prefered centers....  And/or, it might be good to
have some sort of list of, e.g., filters, where each is only
compared to each other.  Say we do that, with a list of measurement
slots.  The MMM could calculate motions for each one separately.  If
they were "consistent enough," they could then be used by MMM to
derive the offsets.  

OK, so the MMM needs an algorithm for converting a series of
measurements to a rate for the guide box mover.  And here is where
we need the guide box mover to provide its trajectory.  Ultimately,
we just want to subtract our measurement trajectory from the
existing trajectory.  Not sure if we want to work in extrapolation
space or not.  Well, if the data are not slowly varying and
reaosnably consistent, then I am not going to be able to do anything
with them.  So applying that as a test criterion is something I
should do.

Thu May  4 15:59:26 2017  jpmorgen@snipe

OK, after some sleep, I realize that this is going to be some
background job that I am going to want a stop button for.  If I have
a stop button, I might as well have that also be a status display
panel.  Cool.  As far as measurement goes, because I can get the
absolute pixel that the object is on in both the guider and main
camera, I don't think it matters whether or not I have guided
between, just that I am guiding and the errors are reasonable when
the measurement is recorded

Wed May 10 12:31:46 2017  jpmorgen@snipe

On day schedule for concentrated effort on this.  Based on some code
I found at
http://wt5l.blogspot.com/2011/05/automated-astrophotography-with-python_28.html
I am going to make an object that contains stuff having to do with
MaxIm.  I am calling it MaxImData.  Maybe I should call the whole
package maximpy, where the offset guide component would be a
separate program to run for its event loop, but would import all the
code in maximpy.

I have some angst about whether or not maximdata or maximpy should
import numpy or just math.  Clearly I am going to need numpy to
identify Jupiter, etc., but for basic measurement, it will probably
not be needed.... No, I can't say that.  I might want to do some
pretty sophisticated estimation and fitting even if centers are
passed using guide stars or PinPoint.

Thu May 11 10:31:33 2017  jpmorgen@snipe

Got something up and running with MaxIm + now I need to get the
desired center stuff squared away.  At this point, I just want
something that works with the ND filter and a Y coordinate.  Since
the desired center moves, maybe I should call it measured center.
The routine is going to need an NDData and so does jupiter_center.
I think that it makes sense to have the NDData generated by the
desired center routine which is called first, but I can make the
logic so it can go either way.

Hmm.  Angst.  That is not clean and there isn't an easy way to get
values out into a parameter.  Things are expected to come out as
tuples.  But the function jupiter_center doesn't suggest it is
outputing the desired center, I just find it handy to do that.  I
suppose I could check on the receiving end for the second tuple/vector
and if it doesn't exist, assume center of image.

Thu May 11 11:30:13 2017  jpmorgen@snipe

OK, so jupiter_center turns into self.object_center in MaxImData.  But
it is more complicated than that.  I was thinking of having motion
calculated afer each exposure was recorded.  But it makes sense for
something else to trigger that, like a watchdog process monitoring the
events.  So I still need the intermediate level that I want to call
independently.

And I am also thinking that jupiter_center works for one image, but
ultimately I am going to want a more complicated function, like
ensemble_center that monitors the different filters, etc., and makes
decisions on whether or not to move things around.

Thu May 11 15:30:43 2017  jpmorgen@snipe

ACKK!  A hitch in my plans.  I am getting

com_error: (-2147352567, 'Exception occurred.', (65535, 'MaxIm DL 6', 'Image Not Available', None, 0, 0), None)

when I try to read an image with CCDCamera.ImageArray.
CCDCamera.ImageReady is true and the example off the next lets me
save, but it seems as though the approbation to not hand the array off
to vbscript and 

I might be able to get it through the Document object

http://www.newastro.com/tutorials/maxim_objects.html helped me with
that, but it is just from the documentation....

Ack!  What a pain.  It looks like I need to read things with
Document.GetFITSKey to get my own FITS header.  But at least I can do
it.

OK, so fundamentally I would like im to be a real astropy FITS im so I
could slog around in the FITS header at will.  To do that, I would
need to save things in an HDUlist

Fri May 12 08:54:59 2017  jpmorgen@snipe

OK, got the HDUlist thing to work, but the description of the image is
the transpose of what I want it to be.  im.shape reports X, Y as I
expect when I see the image in MaxIm and when it saves it to a FITS
file.  But when I make an HDU out of it, astropy reports the shape as
Y, X, presumably because it goes off the shape of the image assuming C
ordering.  Sigh.

There seems to be no tricky way out of this without transposition,
since the ordering of the bytes in memory are locked into the way
MaxIm sent them and Python received them.  If only a simple 1D array
had been sent, I would be fine.  At some level, that 1D array was
sent..  Let see if we can use flatten to see what it really looked
like.

BINGO!

I am reasonably happy with the solution and it checks out with
plt.imshow and the header

Now there is a problem with my approach, that the last image read in
is not necessarily the one that is going to have focus, if someone is
playing around selecting images with MaxIM.  But the Document object
is the only place I can get at the FITS keys I need.

I guess if this is running in the background the way I envision, I
shouldn't worry too much about it, because as soon as an event
happens, control is passed to the code querying the event, preventing
anything else from happening.

--> I am thinking that it might be a good idea to always have my
    coordinates transposed.  This is a pain, but it completes the job
    of transposing everything and results in things being able to plug
    right through in code.

Fri May 12 14:42:07 2017  jpmorgen@snipe

I want to be a little more clear about center pix vs center
astrometric coord.  I also now see that I can get guider images to
work with too, since I am forced to go through the Document object.

--> The watchdog should just retrieve the FITS keys to see if
    additional code should be triggered.  This saves transferring the
    whole image

Wed May 17 13:30:27 2017  jpmorgen@byted

On the way to the 'scope.

At this point I think it makes sense to subsume the maximdata
development into ioio.py so it is easier to just cut-paste

Wed May 17 17:39:05 2017  jpmorgen@byted

--> Wondering what the Pythonic way to deal with unexpected results
    is.  For now returning None seems to work pretty well.

Revisiting NDData now that I have had a little more experience with
classes.  Since I am going to slog around HDULists, I can define a
FITS key that has the ND prameters + check for that early on.

Wed May 17 19:55:20 2017  jpmorgen@byted

Cool!  I got things in the NDData object to work the way I want!  The
object stores things in the FITS header, which can bubble through
jupiter_center (or whatever I want to call it) without jupiter_center
having to worry about it.  If the MaxIm stuff works the way I think, I
can potentially write those keys back into the header before it
writes, though I may wish to let them be recalculated by reduction,
assuming it is important and needs to be rewritten

--> I want to use add_history from west_aux.py.  This highlights the
    necessity of figuring out the PYTHONPATH stuff on Windows/anaconda

Hmm.  I am running into the problem of tuple of tuple return from
jupiter_center.  It is not working the way I want.  The fundamental
problem is that I am returning TMI.  Or I am returning the I in the
wrong form.  Maybe I need to return an object that when queried, gives
the desired center, etc.

Hmm.  That is a good idea!  So the object would be of a subclass of
GetObjectCenterPix.  That object would be instantiated with the
HDUList_im_or_fname construct and then queried for the center pix of
the object and the desired center.  That object can get more
complicated if it needs to, particularly with respect to keeping track
of the desired center

Sat May 27 19:32:39 2017 EDT  jpmorgen@snipe

Think about what I want to call the object, because the method I want
is really oging to return the desired center + MaxImData.center_object
is going to move it there

So it is really going to be something like ImageHandler, or something
like that + have methods

.desired_center
.desired_rate?

Hmm.  So the ImageHandler object (or whatever I call it) is going to
accept the stream of images and make decisions about what to do with them.

I was hoping to avoid having everything centrally scripted, but the
focus stuff suggests I might need to do that.

But I still should try to keep abstraction layers sensible.  I have an
NDData object + probably should have a JupData object, or more
generally an ObjData object.

At least for JupData, I would have center and desired center

There is another set of stuff I need to keep track of for moving the
guide box.  I could potentially put that into the ObjData base class,
or have another class entirely for that

Thu Jun 01 21:24:28 2017 EDT  jpmorgen@snipe

Well, going with ObjData/JupData for now.  At the moment they are
hollow, in the sense that are not instantiated with the image as
property.  The image does get written in to property, but it can
change.  I am not sure I like that.  Potentially better to have the
layered objects, where the ObjData exists for each image that is read
in and can be queried for its obj center and prefered center.  Then
there is a separate object that keeps track of all of those, perhaps
OffsetGuide or OffsetGuideData.

OK, so how is the ObjData going to be handled with MaxImData?  I guess
a better question to ask is: who should be in charge?  The MaxImData
is going to be there connected to MaxIm.  The ObjData objects get
instantiated when an image is taken.  MaxImData might have the code
for that, but I don't think it is the right thing to be in charge of
that.  In other words, a separate application has the event-driven
logic.  Similarly, I think that I should keep the ObjData stuff out of
MaxImData, since it is just too individualized.  Rather, the ObjData,
or whatever subclass thereof should be driven by yet a third thing for
now.

Fri Jun 02 00:35:04 2017 EDT  jpmorgen@snipe

Ack.  I have to actually select the window for it to be the active one.

So next step is to read in an image

Fri Jun 02 10:36:49 2017 EDT  jpmorgen@snipe

Well, wait a minute.  I need to go back to the NDData logic since I am
using images of different size and binning.

So I want some property for the subimage and binning.  The
default_nd_pos and other nd position parameters should read in binning
= 1.

--> Either that or I just limit myself to binning = 1 cases for now

In any case, I need to make sure I check for out-of-bounds

Fri Jun 02 11:16:57 2017 EDT  jpmorgen@snipe

Now ready to read in an IPT image!

The acid test is to just read one in and have that be the active Document

It worked!

Revisited desire to just have math in MaxImData section and find that
since I am dealing with the astropy FITS stuff, I need to have
np.ndarrays, so np is necessary for MaxImdata

So now I want to see if I can make a script out of it that I can run
from the command line or with MaxIm!

Fri Jun 02 14:22:09 2017 EDT  jpmorgen@snipe

Apparently there is a thing called conda.

Ah.  Conda is like pip3 as a package manager.  It also creates
environments

python at the command prompt does bring up python

Type hello_argv.py + get the option to make a file association.  Took
a while to find python.exe, but now it is there (on puppy)

Hmm

Fri Jun 02 22:42:32 2017 EDT  jpmorgen@snipe

Got ioio.py to work on IoIO1U1! At least during twilight with old
images.

--> I need to get the default position of the current ND filter

ND=NDData('//snipe/data/io/IoIO/raw/2017-05-29/Sky_Flat-0001_Na_off-band.fit')
print(ND.get_params())

Sat Jun 03 15:27:29 2017 EDT  jpmorgen@snipe

<sigh> that is not as easy as I would like it to be.  Plus I need to
deal with binning stuff too.  So think about that for awhile.

I have been trying to keep NDData as a separate object.  I am seeing
there isn't much need for that.  As long as I don't call
get_obj_center on a flat, I am OK + I can potentially do some
safeguards against that. 

I am thinking a little more generally about the JupData.  Yes, I want
to use that to work with Jupiter, but I am also working with other
observations, like stars for focus and maybe other things.

So I am thinking that maybe ObjData should be ObsData, data about an
observation.  And I could have CorObsData for a coronagraph observation 

Wed Jun 07 10:28:03 2017 EDT  jpmorgen@snipe

Tried to work at town office + date was messed up on byted, so work
was lost.  Decided to put NDData into CorObsData.  Just need to add
nd_ to a couple of its methods + move some of the ingest_im stuff into
the base init and CorObsData init methods.

Sun Jun 11 13:39:06 2017 CEST  jpmorgen@byted

<sigh> now that the ND filter is tipped, the ND edge finding algorithm
doesn't work as well.  At least with the flats, I can use small
vertical binning and that fixes the problem for them.  Maybe for the
Jupiter images, I can rotate 

Sat Jul 01 23:34:03 2017 EDT  jpmorgen@snipe

Wonder if I can do the diagonal thing starting from the flats?

Tue Aug 01 19:17:30 2017 EDT  jpmorgen@byted

To do this effectively, I should make a decision when I am
processing the file if it is a flat or not.  I have IMAGETYP in the
list of required_FITS_keys, so it should come over fine in real time.

It would nice to have a place where I store the current paramters.  A
well-organized disk file is the right place.  That would be at the top
level of the raw data directory.  In the short term, it would be nice
to have that number in the property stashed from a previous flat run.

Well, that can just be a CorObsData on a flat!  That can be an
optional input.  Actuality the way to do that is just with a file name
and have CorObsData do it itself.

Hey, if I make the reference_flat a variable that is global to all
CorObsData types, I can at least for one session do what I am thinking of

Tue Nov 14 15:36:20 2017 EST  jpmorgen@snipe

Time to start thinking of getting this up and running, since I am 2
months out from deployment

Tried to send buffer to python:

Python 3.5.3 (default, Jan 19 2017, 14:11:04) 
[GCC 6.3.0 20170118] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jpmorgen/py/IoIO/ioio.py", line 10, in <module>
    from scipy import signal, ndimage
ImportError: No module named 'scipy'

I might need to get anaconda for snipe.  It looks like the latest
version of python is 3.6, but snipe only supports 3.5.

Since I use anaconda on puppy and IoIO1U1, it might be prudent to
install it on snipe....

OTOH, it looks like I can get scipy easily:

https://www.scipy.org/install.html

Sun Nov 26 14:43:54 2017 EST  jpmorgen@snipe

root@snipe> pip3 install -U pip

http://docs.astropy.org/en/stable/install.html

pip3 install -U numpy
  Found existing installation: numpy 1.12.1
    Not uninstalling numpy at /usr/lib/python3/dist-packages, outside environment /usr
Successfully installed numpy-1.13.3

https://askubuntu.com/questions/797058/not-uninstalling-paramiko-at-usr-lib-python2-7-dist-packages-outside-environme

OK, I think that means I have things under apt package management 

So numpy is installed and is at 1.12.1, as suggested by pip.

I have python3-astropy installed already.  Get python3-scipy

ioio.py now works!

But I need to implement the shifted row algorithm.

. Center of image = 0 shift
. dy * tan(angle) = dx, round that
. X + dx = corrected X.  Maybe shift row by -(X + dx)
. collapse shifted rows to increase signal

Sun Nov 26 17:01:28 2017 EST  jpmorgen@snipe

Reading through ioio.py and finding some things are confusing and left
over from previous iterations.

I like the ObsData and CorObsData inheritance construct.  CorObsData
replaces NDData.  "params" is not too illuminating a name.  ND_coords,
ND_edges, and ND_angle are more sensible.  ND_params might be better,
but I don't know if it is worth changing it for that

And I wanted to figure out a good place to store a file with the ND_params

https://stackoverflow.com/questions/7374748/whats-the-difference-between-a-python-property-and-attribute

Ah Ha!  I might want to define some methods __get__, __set__ and/or
__delete__ in some sort of ND_params object, so that when I call
something like print(flat.ND_params), it automatically does the
__get__ method

That is a refinement.  For now, I need to work at making it implement
the tilted algorithm.

The tilted algorithm depends on what I currently call the
default_nd_pos system, but which I think I would like to improve.

In the absence of any recorded previous ND_params and because I used a
variety of angles, 0 or 21 degrees is probably the best to start
with.  Alternately, I hard-code in ones for date ranges

It think it will be important to have a written area for this

Sun Nov 26 18:48:50 2017 EST  jpmorgen@snipe

ypt, ypts, etc. may need to change.

Mon Nov 27 16:45:31 2017 EST  jpmorgen@snipe

Having trouble with inheritance

ObsData.read_im does FITS stuff, but not y_center.  That is why I want
to override it in CorObsData.  But when I try to use the version of
read_im in CorObsData, I get passed the name...

Ahh.  The problem seems to be growing pains between old-style
functions that I am used to and doing things more with objects.  I was
not storing the image from read_im into self!

>>> [[  3.78040775e-01   3.84787113e-01]
 [  1.24664929e+03   1.35807856e+03]]
1.56926110854

Hey, that makes a big difference when I use the wrong value!

ND filter edges are not parallel.  Edges are off by 14.3094258117 pixels.
WARNING: ND filter edges are not parallel.  Edges are off by 14.3094258117 pixels. Returning initial try. [unknown]
[[  3.78040775e-01   3.84787113e-01]
 [  1.24664929e+03   1.35807856e+03]]
1.56926110854

--> Relax edges criterion a bit:
[[  3.74787350e-01   3.87795919e-01]
 [  2.56409969e+03   2.78656027e+03]]
1.57004886213

Hmm.  This seems wrong!  Intercepts are way too high

--> Oops, recursion error with default_ND_params = None

Not putting them back where they belong:

[[ -3.25342466e-03   3.00880626e-03]
 [  1.31745040e+03   1.42848171e+03]]
1.56933962744

Interesting that they are bowed
--> ND_angle is not returning the right thing

>>> [[  3.74787350e-01   3.87795919e-01]
 [  1.18909969e+03   1.41156027e+03]]
1.56925870775

OK, somne things to work on.  First of all, I want to stop the
recursion error and consider working from the center out to find the
best peaks, since the edges of the flatfield confuse the issue.  Maybe
I could just multiply the profile by some function that peaks in the middle....

OK, fixed recursion error and got angle correct

Now onto making flats more reliable.  Note that the second derivative
helps here to pslot the sharp edge and re-multiplying by the profile
de-emphasizes the noise in the middle

            profile = np.sum(subim, 0)
            smoothed_profile = signal.savgol_filter(profile, self.x_filt_width, 3)
            d = np.gradient(smoothed_profile, 10)
            d2 = np.gradient(d, 10)
            s = np.abs(d2) * profile

[[  3.77351116e-01   3.82876712e-01]
 [  1.21697817e+03   1.38464772e+03]]
0.363246546527

Second run through looks even better with no missed points
[[  3.75447820e-01   3.87551301e-01]
 [  1.18163633e+03   1.42002571e+03]]
0.364456703475

Is that algorithm good for non-flats?

[[  3.71191460e-01   4.03051953e-01]
 [  1.17661504e+03   1.29683655e+03]]
0.369355340751

Holy smokes!  That's not bad!

In fact, it is better than the other way

Well, that is because a number are being rejected

Old way:
[[  6.27488411e-01   6.60076892e-01]
 [  1.09770298e+03   1.29057039e+03]]
0.57199207656

That is pretty crummy!

SII with new way:
[[  8.30095570e-01   8.50540538e-01]
 [  1.15190956e+03   1.27540733e+03]]
0.698846271587

Not good.  Of course, I am a little off in the initial
default_ND_params, but I still want to be able to get close.

It might be that I have to just remove stars and cosmic rays first,
so they don't mess up the signal from the edge.  Or I could try that
edge detection routine....

And now that I have a cheap and dirty way to rotate the images, I
might go back to the collapse vertical idea, since mostly I want to
just get the left-right

I am not doing a true rotation, but a shift, which is why Jupiter
looks so weird, as does the flatfield image.

Tue Nov 28 17:39:39 2017 EST  jpmorgen@snipe

Not sure if that matters too much.  After fixing the algorithm to work
differently for flats and images, realizing my bounds did not need to move

[[  3.72612513e-01   3.91825984e-01]
 [  1.12312877e+03   1.47317201e+03]]
0.365084804118

Wed Nov 29 11:48:56 2017 EST  jpmorgen@snipe

OK, I think I can improve on the peak selection algorithm if I choose
peaks that are the right distance apart.   But before I do that, check
things in & re-check for flat performance

Ah Ha!  I should probably iterate when I do the point rejection
algorithm.  I do a second pass, but that is different, since lots are
missing from the first pass

I might do well to include weights.  Or not have absolute difference
but use stdev

Thu Nov 30 07:46:55 2017 EST  jpmorgen@snipe

Ah.  I can use weights in the subsequent iterations

Thu Nov 30 09:21:05 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/23797825/what-is-the-pythonic-way-to-bubble-up-error-conditions

Has a good discussion about how to handle errors and exceptions and
whether or not to return None vs a null object:

http://code.activestate.com/recipes/68205-null-object-design-pattern/

I'll have to think more about this as time goes on.

I think that I will not handle all possible errors, but just in case,
this is an interesting bit of code

        except:
            # Thanks to https://stackoverflow.com/questions/15605925/how-to-get-the-last-exception-object-after-an-error-is-raised-at-a-python-prompt
            log.error(sys.exc_info()[1])
            return None

OK, I am having trouble with the array being the wrong orientation for
my new way of fitting the lines.  When given two sets of lines points
polyfit made the first column the first line, the second column the
second line.  This is pythonic.  I did things row-by-row with

ND_params = np.asarray((ND_params0, ND_params1))

Hmm

SII =  CorObsData('/data/io/IoIO/raw/2017-05-28/Na_IPT-0035_SII_on-band.fit')
print(SII.get_ND_params())
print(SII.ND_angle())

Shows things aren't working all that well for the SII image....

I think this might benefit from the differences method

Na image
[[  3.70590906e-01   3.91039665e-01]
 [  1.11869115e+03   1.47671815e+03]]
0.363859230268

After clean up linfit, max_fit_delta_pix = 5
[[  3.72491235e-01   3.92456403e-01]
 [  1.12169240e+03   1.47507210e+03]]
0.365306905718

max_fit_delta_pix = 25
[[  3.71568935e-01   3.92436721e-01]
 [  1.12235642e+03   1.47245281e+03]]
0.364895956723


OK, that looks good, but the SII image needs help.  In particular, I
need to know when to start looking for peaks, since the cwt finds some
where there are none.

We are generally looking for [1312 1419]

OK, as I am doing the SII flat, I see that I can set an upper limit to
the spread in flat mode as just under 1/2 of the CCD width, though
that is definitely liberal + will likely have problems when close to
the edges.


Ah ha, the bounds can be the size of the SII filter for all the flats

Well, that ended up being worse.  But I can use the vertical size too
350 1900

Beautiful SII flat

[[  3.78470178e-01   3.86181647e-01]
 [  1.21542960e+03   1.38570910e+03]]
0.365177868072

Hickup in one location in Na flat
[[  3.79115598e-01   3.87003140e-01]
 [  1.21585461e+03   1.38458248e+03]]
0.365817629192

SII image
[[  3.67503733e-01   3.89594787e-01]
 [  1.11991952e+03   1.46640214e+03]]
0.361878713669

Na image (slight glip)
[[  3.72051081e-01   3.88777783e-01]
 [  1.12240319e+03   1.47295464e+03]]
0.363509099347

1.12240319e+03 - 1.11991952e+03
2.4836700000000747
>>> 1.47295464e+03 - 1.46640214e+03
6.552500000000009

I'd say that is pretty good!

1.12240319e+03 - 1.21585461e+03
-93.4514200000001

1.47295464e+03 - 1.38458248e+03
88.3721599999999

So there is some bowing, but that is probably because of the 2nd
derivative technique.  This might also explain why I have such a wide
bounds.  For now it looks like I don't need to get the flats precise,
just good enough to get the morph and bounds set

Thu Nov 30 16:37:01 2017 EST  jpmorgen@snipe

OK, reading to clean up code.  Do I want to use the getter and setter?
The advantage of doing it that way is that the caller doesn't have to
know the internal workings.  They just ask for the property and it is
produced.  Disadvantage is that there may be some instances where it
is expedient to pass parameters to tweak the algorithm used to
generate it.  Although that is not necessarily wise, since one of the
whole points is that I calculate it once and then return the cached
value.  It is more set up to tweak the property or attribute, or
whatever they are called on instantiation or shortly thereafter,
before the first call to do the long calculations.

I should have a way to re-do the calculations on an existing file with
the NDPAR* keywords, since they might refine.  Or I could remove them
externally and go with that.

It could be that I do:

ND_params = property(get_ND_params, set_ND_params, fdel=None, 'ND_params characterize the coronagraph ND filter')

for both ND_params and default_ND_params.  Of course that brings up
the long-term storage issue for default_ND_params, but I will deal
with that later.

Thu Nov 30 20:57:08 2017 EST  jpmorgen@snipe

Learning about the property() decorators and their limitations.  The
setter really takes just one argument and can't be used like a
function call to recalculate.  I would have to say something like

Na.ND_params = 'recalc'

The alternative is Na.calc_ND_params()

Either way is fine.  Might as well enable both for now.

As far as ND_angle goes, it is probably safest to recalculate it when
needed, since it is cheap, but in general I would want some sort of
registration system that listed the things that needed to be
recalced.  For now, I can just put the calculation of the angle in 

--> The ND_coords, obj_center, etc. would need to be recalculated
    too.  I could have a flat that indicated for each of those
    components if recalc had happened.  All of this to avoid just
    discarding and restarting the object, which could be expensive
    with an open file, though I could possibly extract the HDUList

My primary use for this is for a live system, with one chance to get
it right.  It will move on to the next image.

This brings up the question of efficiency.  I was hoping I could have
this running all the time, but it looks like ACP wants to call it on a
per exposure basis.  I suppose I could have it be like one long
exposure....  but worry about that later.  The point is, I don't need
to be infinitely flexible here on this particular object.

Fri Dec 01 12:09:10 2017 EST  jpmorgen@snipe

So go back to the ACP question.

It looks like AcquireImage() can completely replace what ACP does when
acquiring a single image.  ** it has to check for the need to flip **
Return True = differ to ACP, OK means user function presumably handled
acquisition and False is abort entire run.  That can handle all of the
filter motion, recentering, guiding, etc.  It could be that I have the
background helper process running & looking for images showing up in
MaxIm that have been initiated by this script.  But at the very least,
I can have this script do periodic centering on a per exposure basis

TargetStart() is also a possibility, but it is before AcquireImage()
and seems to be more for tweaking things you should probably have
tweaked in your observing plan.  TargetStart() could potentially help
redefine things based on moon position, but I might want to put all of
that logic into AcquireImage()

Aside: I still don't see anywhere where I can tweak focus, but that
might be something I can do in AqcuireImage()!
--> Want to make sure I can be tracking Jupiter properly

So if I just set up for one Jupiter AcquireImage(), I grab the
observatory for the whole of when Jupiter is up, make my own flip
decisions, autofocus, etc.  Then when I release, ACP can pick up on
whatever plan/Schedule is available.  Autofocus from there might not
be the greatest, but I could still have a general part of AcuireImage
for that.


--> Hey, on-the-fly exposure adjustment is possible with this!
http://forums.dc3.com/showthread.php?10314-Question-on-UserActions-or-similar&highlight=TargetStart

#tag can be saved in a global part of UserActions

#tag is available to AcquireImage() and Description field of ImageSet
 or Observation is available

--> I will have to dig deep into AcquireImage.js

Either that or I could just have every Nth time through my internal
AcquireImage() loop return True so that there is just a generic
picture of Jupiter recorded and scope flip, autofocus, etc. is handled
automatically

--> HEY WAIT A MINUTE!  There is an autofocus script!  No, that is
    just a shell around SUP.AutoFocus.  But if I tweak all of the
    calls to SUP.AutoFocus in AcquireImages.js to add a little bit to
    the target RA, I should be set.  I can do this in IoIO mode only

In any case, however I end up structuring the AcquireImage()

ret = SUP.UserActions.AcquireImage(Pl, Tc, Is, imgFile + ".fts");   // Call with full name

where Pl is the plan object, Tc is the telescope control object and Is
might be image set?  We would basically replace one image with many.

So my personal AcquireImage could check to see that the background
guiding process was running (if I use that) and then just bang away
and telling MaxIm to record images
--> might need to insert yield statements

Taking a step back... No, I don't think I want to use the default
AcquireImage because it does the whole tracking thing.  So even though
it gets me name logic.  Wait.  Does it?  Not sure.  Anyway it looks
like my original plan should work, with the background task looking
MaxIm and feeding it to my Python script.  If there is a fight going
on for MaxIm, I can just have my script exit (might need to learn how
to pass it messages) when I do the periodic ACP thing.  I mostly want
it running to avoid the long startup time (assuming there is one).

OK, so I should plan for occational starts to ioio.py, or whatever it
ends up being called.

So this means I am going to need a way to read in the
default_ND_params, or have them hard-coded.  It would be cushy to have
a way to write them within the object + read them back + I suppose I
could check for system names like I did for something else.

So all of this is leaning me away from a system that has the
complexity to re-process the innards

Looking into the fitsio stuff, it looks like I can extract the HDUList
object from a running ObsData and shove it into a new ObsData for
processing there.  So there is no need to do the reprocessing within &
there is possible motivation for having multiple objects storing the
results

OK, so if I open a file, keep it open, if I read a file from a
filename, close it

Fri Dec 01 20:13:05 2017 EST  jpmorgen@snipe

For some reason, when **kwargs is empty, an empty dict is passed
instead on None

Just look for falseness

Mon Dec 04 14:17:23 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference

arguments are passed by reference.  Once I rebind the reference
(physically set the parameter name to something else), it is separated
from the outer object.  But I can operate on the parameter name 

So the way I have read_im written, I assign the value of the argument
to something else, but I think that means the full object goes along
and I can mutate it

def try_to_change_list_contents(the_list):
    print('got', the_list)
    inner_list = the_list
    print('assigned to inner_list')
    inner_list.append('four')
    print('changed inner_list to', inner_list)

outer_list = ['one', 'two', 'three']

print('before, outer_list =', outer_list)
try_to_change_list_contents(outer_list)
print('after, outer_list =', outer_list)

Confirms that the inner name mutates the actual object

OK, so when I read_im an nd_array, if I were to del self.HDUList, I
would delete that original nd_array?  No, I think I would delete the
self.HDUList pointing to it, but the original nd_array would live.
No, only if something else is pointing to it.

I am planning to have a process monitor the MaxIm notify events and
grab the image then.  Whatever loop is doing that is going to call the
MaxImData.get_im and receive a tuple from MaxIm and shove that into an
NDarray that will eventually get into an ObsData.HDUList.  If the
MaxImData.get_im returns an HDUList into a loop variable, presumably
all past versions of that loop variable are not kept.  But if there
are objects that reference the NDarray(s), they will stay hogging
memory.  So the trick is to delete the objects referencing the NDarray.

Hmm.  Deleting obj.HDUList removes it from the namespace, which is
different than setting it to None.  Either one will deference and let
the memory free, but one is a little more gentle than the other.

If I really am using the ObjData to store data about the observation
and not the observation itself (which could be stored outside without
being deleted when I delete the HDUList inside), I should definitely
delete the HDUList, because there will be a hard error when I try to
improperly use the object.  The object is only for calculating,
storing and delivering the property of the obj_center and
desired_center and whatever else I may need (e.g. y_cent)

OK, I am now running into problems with the binned and unbinned
center.  I absolutely need unbinned to be able to do the re-centering
calculations.  I may want to 

Mon Dec 04 17:10:26 2017 EST  jpmorgen@snipe

OK, now I am facing the binning issue.  It might be that I just need a
method that takes care of unbinned coordinate calculation.  Maybe
something like "unbinned."

Ah, then I could have another function that would be for binned.  That
might be motivation for having the center type property be methods
again, or I could just have a separate property.

To be clear I might need to have unbinned always referenced in my
calls.  Or have both so it is always clear

Not necessarily!  I can use ObsData.binned() to do the conversion!

As far as binned exposures for calc_ND_params, the best thing might be
to just rebin them.  Apparently I need to write my own code or get
some from a wheel.

Tue Dec 05 15:55:36 2017 EST  jpmorgen@snipe

I think I can get the rebin code into ioio.py

Done!  Might be slow the way I do it rather than binning all the
calculations

Background seems to confuse:

atv, '/data/io/IoIO/raw/2017-05-28/Na_IPT-0001_moving_to_SII_on-band.fit

--> need to have checks for inside image

/data/io/IoIO/raw/2017-05-28/Trius_SX694-0009_1x1_bias.fit

crashed program

Fixed that.  Did whole directory in 1123s.  That is 252 files
1123.5540227890015/252
4.458547709480165

I can cut that a bit maybe by making the n_y_steps smaller, say 8

Center of mass is used for obj_center, so there is no risk that it
would be outside of the image, though it might be wrong.

Tue Dec 05 21:03:22 2017 EST  jpmorgen@snipe

Rj = np.asarray((50.1, 29.8))/2. # arcsec
plate = 1.59/2 # main "/pix

Rj/plate # Jupiter pixel radius
array([ 31.50943396,  18.74213836])

np.pi * (Rj/plate)**2 # Jupiter area
array([ 3119.11276312,  1103.54018437])

np.pi * (Rj/plate)**2 * 5 # Jupiter 5 sigma
array([ 15595.56381559,   5517.70092183])

Wed Dec 06 08:02:13 2017 EST  jpmorgen@snipe

Down to 966 seconds with 8, as expected
--> I should do a comparison of values



/data/io/IoIO/raw/2017-05-28/Na_IPT-0018_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0016_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0013_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0025_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0022_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0024_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0029_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0037_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0010_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0039_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0020_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0023_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0005_moving_to_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0038_moving_to_SII_on-band.fit

Seems to be the problem here is that there is just not enough signal,
which is fine


/data/io/IoIO/raw/2017-05-28/Na_IPT-0038_moving_to_SII_off-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0027_moving_to_SII_off-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0015_moving_to_SII_off-band.fit


/data/io/IoIO/raw/2017-05-28/Na_IPT-0040_moving_to_Na_on-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0001_moving_to_Na_off-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0036_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0011_SII_on-band.fit
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit

/data/io/IoIO/raw/2017-05-28/Na_IPT-0026_SII_off-band.fit


Go over worrisome pathological cases
atv, '/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit

That was cleared up with medfilt with a kernel size of 3.  Harder to
get rid of saturated moons.  On the moving_to, they are not saturated.

As I am moving on in this, I am wondering if the right thing to do is
let the files be written and handle the calculations off-line with
another program, since I am not sure they can happen quickly enough to
keep MaxIm happy.  It would be great if I could fork a child process
that takes the HDU and does its work while the primary process
returns.  But ultimately, I just need to know where Jupiter was at a
particular time and how to tweak the guider, if I am going that far.
If I am just setting things up, I have to wait for my process anyway,
reading a file might not be that much more time.

--> last thing I need to do is a sensitive adjustment for the distance
    between the peaks

Wed Dec 06 12:45:02 2017 EST  jpmorgen@snipe

Hey, I can save some time with the savgol_filter by only checking
around bounds.  Better check code in before I mess with that....

Wed Dec 06 15:58:25 2017 EST  jpmorgen@snipe

Well, I have the sorting stuff working, but it doesn't necessarily
give a better value.

Thu Dec 07 09:44:18 2017 EST  jpmorgen@snipe

Whew!  Found an error in rotating ND_params back.  Things look a bit
better now + check with reality in a very difficult case.

I am starting to think that the best place to put the
default_ND_params determination is where I call CorObsData, not in the
object itself.

OK, so I am facing the problem I had earlier, that to jump-start the
process the flats need different parameters than the objects.  DO I
want to deal with this inside the object or outside?

For now it is handy to do so inside.

Last bit of bullet proofing would be default width


1st time
[[  3.73167520e-01   3.66137275e-01]
 [  1.19204226e+03   1.40353646e+03]]
2nd time
[[  3.80135555e-01   3.84551127e-01]
 [  1.24392453e+03   1.35668924e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit
[[  3.80797076e-01   3.83683119e-01]
 [  1.24304866e+03   1.35375702e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
[[  3.89720321e-01   3.82599096e-01]
 [  1.24469871e+03   1.34865465e+03]]

I am liking this now.

1.24469871e+03   -1.34865465e+03
-103.95594000000006
>>> 1.24304866e+03   -1.35375702e+03
-110.70836000000008
>>> 1.24392453e+03   -1.35668924e+03
-112.76470999999992
>>> 1.19204226e+03   -1.40353646e+03
-211.4942000000001
>>> 

That is inverse order

1st
[[  3.73167520e-01   3.66137275e-01]
 [  1.19204226e+03   1.40353646e+03]]
2nd (one missing point in lower profile)
[[  3.79288017e-01   3.84777194e-01]
 [  1.24398821e+03   1.35656141e+03]]
3rd
[[  3.79288017e-01   3.84777194e-01]
 [  1.24398821e+03   1.35656141e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0014_SII_on-band.fit
[[  3.79359014e-01   3.84492566e-01]
 [  1.24230393e+03   1.35360561e+03]]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0028_moving_to_SII_on-band.fit
[[  3.90798410e-01   3.82329457e-01]
 [  1.24535857e+03   1.34778286e+03]]

Looking very nice

The next thing I want is a distance from the center of the ND filter

https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line

They prefer the parameterized form of the line

ax + by + c = 0

http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html

Has

y = -a/b x - c/b

That is what I am looking for

m = -a/b
h = -c/b

where h is the intercept

b = -a/m = -c/h
c/a = h/m
h = mc/a

This is just chasing my tail.  Use 2-point form:

abs((x2 - x1) * (y1 - y0) - (x1 - x0) * (y2 - y1)) /
((x2 - x1)**2 + (y2 - y1)**2)**0.5

Thu Dec 07 20:51:44 2017 EST  jpmorgen@snipe

Got that working.  It was a problem with the X origin.

Now doing the long run and finding that, predictably, all dy valyes in
the desired_center are 0.  Nicely, the dx values are pretty darn small
too.

--> the variation in the obj_center is unexpectedly large

Fri Dec 08 12:48:05 2017 EST  jpmorgen@snipe

--> first few exposures on 2017-05-28 might be having a problem with
    background being so bright -- my silliness of exposign during
    civil twilight

--> consider subtracting median of cropped image or use histogram
    technique to spot that background.


/data/io/IoIO/raw/2017-05-28/Na_IPT-0011_moving_to_SII_on-band.fit
/usr/lib/python3/dist-packages/scipy/signal/_peak_finding.py:412: RuntimeWarning: invalid value encountered in double_scalars
5.73232033471
[ 0.          7.23630139]
[ 0.  0.]
4^---8>-----
[ 0.          5.37101387]
[ 0.04228364  0.00387351]

/data/io/IoIO/raw/2017-05-28/Na_IPT-0013_moving_to_SII_on-band.fit
2.15110699901
[ 0.          4.60368123]
[-0.81430089  2.35449183]
4^---8>-----
[ 0.          2.41291612]
[-0.79947457  2.29283603]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0017_moving_to_SII_on-band.fit
0.461735778369
[ 0.         -3.19025364]
[ 0.8024765  -1.35503926]
4^---8>-----
[ 0.          5.44327348]
[-0.42432581  2.11040623]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0021_moving_to_SII_on-band.fit
3.00364028726
[ 0.          5.28533696]
[-0.16645221  0.48286966]
4^---8>-----
[ 0.          1.97240713]
[-0.00626509  0.02047843]
/data/io/IoIO/raw/2017-05-28/Na_IPT-0022_moving_to_SII_on-band.fit
1.63188808341
[ 0.         -3.67625137]
[ 0.01745688 -0.31393855]
4^---8>-----
[ 0.        -7.4422813]
[ 0.0973593  -0.86116534]

Where the top is the desired center difference between tries with
different y_steps and the bottom is the difference in the
obj_centers.  Basically, the obj_centers are very stable except for
the case where the background sky was very bright.

Sun Dec 10 15:03:27 2017 EST  jpmorgen@snipe

I think the ioio.py algorithm is shaping up pretty well.  Did a little
more streamlining and checked it in with an amendment.  I love git!

Now the big test is to see if I can find an off-ND filter image.

First of all, I can test some of my current logic with a flat

I think the way to do that is to do a walk and see if I can find any

Sun Dec 10 18:07:53 2017 EST  jpmorgen@snipe

Looking like I am having trouble with my Jupiter in ND filter testing
algorithm

Mon Dec 11 09:21:20 2017 EST  jpmorgen@snipe

Consider making ND_coords faster with some coordinate math
/data/io/IoIO/raw/2017-05-20/Sky_Flat-0010_SII_on-band.fit
((0.37978158134653572, 0.38067280430080175), (1286.5410005790682, 1286.2680292376658))

Fixed that with some proper indexing!  Lists stack up in the first index

O = CorObsData('/data/io/IoIO/raw/2017-04-18/IPT-0001_off-band.fit', default_ND_params = ((-0.07286433475733832, 1251.595679328457), (-0.068272558665046126, 1357.3942953038429)))
  File "/home/jpmorgen/py/IoIO/ioio.py", line 1055, in ND_params
    this_ND_center-subim_hw:this_ND_center+subim_hw]
ValueError: could not broadcast input array from shape (0) into shape (1456)



/data/io/IoIO/raw/2017-04-15/IPT-0017_on-band.fit
[ 1104.69385143  1273.05462992]
WARNING: Large dist: 18 [unknown]

/data/io/IoIO/raw/2017-04-15/IPT-0027_off-band.fit
[ 1114.43688405  1251.88337244]
WARNING: Large dist: 40 [unknown]
(reasonable center)

/data/io/IoIO/raw/2017-04-20/Filter_sequence-0001_10s_Na_on-band.fit
/usr/lib/python3/dist-packages/scipy/signal/_peak_finding.py:412: RuntimeWarning: divide by zero encountered in double_scalars
  snr = abs(cwt[line[0][0], line[1][0]] / noises[line[1][0]])

Good example of a complete lack of signal to detect ND filter and a
star that doesn't saturate

I want to create a routine that derives the default_ND_params for
a particular directory.  Should that be in CorObsData?  I don't think
so.  It is a separate utility that needs to be in the module and uses
CorObsData.  Hey!  It could be an object itself.  Hmm.  That is a
little awkward.  It is basically just an ndarray, so I am not sure I
need to be all that sacred about it.  If I had some larger object that
kept track of many CorObjs, I might do it as an object with property,
but that doesn't stop me from making it a simple method in the ioio module

--> Might want to test to see if ND in default par has any signal
    before trying to look for one

got ND filter, but missed star
/data/io/IoIO/raw/2017-04-20/Filter_sequence-0001_1s_open.fit
WARNING: Jupiter outside of ND filter?  obj_ND metric expected > 5000 calculated =  [unknown]

<fixed algorithm>

Bad!!!  ND filter problem?  Need wider margin?
/data/io/IoIO/raw/2017-05-27/IPT-0007_on-band.fit
[ 1059.67224866  1349.63286885]
WARNING: Large dist: 60 [unknown]

<found better flats>

Star image, not even close, metric must have been off
/data/io/IoIO/raw/2017-04-21/Filter_sequence-0001_1s_open.fit
[ 1144.33194632  1216.89788347]
WARNING: Large dist: 72 [unknown]

Mon Dec 11 19:53:54 2017 EST  jpmorgen@snipe

While I am getting more things to look into on that front, start to
look into the MaxIM/ACP side of things.

Based on behavior noted in the logs, it looks like in order to use the
guider on a non-siderial object, I need to define a SUP.UserActions.
That apparently operates on that Count level.  But I don't want to be
launching a big Python script all the time, which is why the
invitation to replace a large section of AcquireImages.js.  It would
behoove me to copy as much of Bob's code as I can to get the basics
set up, but I did the Python because there is just way too much
sophistication for that to be done in .js.

/data/PSIScope/observing/AcquireImages.js line 1774 is where he starts
the autoguider.  I may opt to just do it with my own code, since I
think he checks lots of other thigns, though I could try it either
way.  It would get the error graphs onto the the website.

Either way, once the guider is started, the next most important thing
for my code to do is command MaxIm to take pictures and watch them
come in to get the obj_center and desired_center.  Those *_centers go
on a stack that helps move the guide box or stop the guider and
totally move the telescope.  I guess the later makes it clear that I
should probably not have ACP handle the guider.


Note AcquireImages.js line 1806 + things above that got orbTrackRealRates
                       if(orbTrackRealRates)
                            SUP.SetTrackOffset(Tc.RARate, Tc.DecRate);      // Complier assures scope can do tracking

Since he is doing those calculations, it might be nice to have a user .js
script do them.  But I think I should be able to have access to all of
those objects, just like in MaxIm, which is beyond way cool!

In any case, my script is going to be called when Jupiter is near the
center <see below for argument that I can do this one image at a time>

Check if need flip (see line 2941 of AcquireImages.js), --> add time
for first alignment if not guiding and/or tracking

If not guiding and/or tracking (first entry)
def center_loop
    Loop:
        Preliminary exposure (R-band)
        Check close enough
            break if so
        Move to expected center

    Start guider
    Loop:
        Preliminary exposure (R-band)
        Check if close enough
            break if so
    	if too far warn & recenter with loop above
        Move Jupiter with guide box (separate Loop)

    else:
        Take Requested filter image
	<Possibly with ImageEnd()>
        Process image with CorObsData
	Accumulate CorObsData
	If not too far off
	    Generate guide box rate + send to guide box mover section of code
	else:
	    warn
	    If way too far off:
	        Turn guider off & return OK to trigger loop to recenter
                and initialize guider
	    else:
	        Use Start Guider loop


Guide box mover
    Initialize when guider initialized -- remember initial guide box
    position
    
    Accept rates

    Independent Loop:
        Move guide box according to rates
	
    Fail if getting close to camera edge
    Fail if Jupiter fades
    --> Add script fail to shut down

The way Bob has it structured, AcquireImage() is designed for a single
image, but I don't see why it could't be a very long image.  It is
like going off and doing DAWNFLATS.

ret = SUP.UserActions.AcquireImage(Pl, Tc, Is, imgFile + ".fts");   // Call with full name

So the first thing I need to do is check to see if I can access the
Pl, Tc, etc. objects from Python.  I kind of doubt it.  But I can
write a .js that does the looping after preliminary set up in Python.
The Python event catcher can do the guiding thing.

http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/scr-ovw.htm

Says that Python should have it

--> how are the user scripts interrupted by weather?  AcquireImages
    doesn't seem to handle weather, so maybe that is done somewhere
    else.

Tue Dec 12 08:47:57 2017 EST  jpmorgen@snipe

I think I am just going to need to work with a simulator on this.
Consider setting puppy up as the completely independent simulator 

I already have MaxIm.  It complains that my PinPoint license has
expired.  Looks like I should get a full version of that

scp "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/ACP/acp-811-setup.exe" jpmorgen@cpe-184-153-135-44.maine.res.rr.com:/data/io/IoIO/observing/ACP/

scp "/cygdrive/c/Users/PLANETARY SCIENCE/Downloads/NOVAS(2.1.1)Setup.exe" jpmorgen@cpe-184-153-135-44.maine.res.rr.com:/data/io/IoIO/observing/ACP/

Email from 04/26/2017 in Proposals/NSF folder gives download locations
for DC3 products

Oh, but I want to just install ACP and PinPoint comes along for the ride

Or so it says.

Getting USNO A2.0 catalog for snipe

/data/USNO_A2.0/


cd /data/USNO_A2.0/
ftp ftp.nofs.navy.mil
anonymous
jpmorgen@psi.edu
cd usnoa
bin
prompt noprompt
mget *

Seems to be stuck on readast.v10

Seems to stick if I try to download the whole thing at once.  After a
break, it goes OK.  Although I am trying to avoid it, possibly best to
just get from IoIO1U1.

rsync -auv  "/cygdrive/c/Users/PLANETARY SCIENCE/Desktop/IoIO/From Dean/usno/" jpmorgen@cpe-184-153-135-44.maine.res.rr.com:/data/USNO_A2.0/

Interesting.  250kb/s from PSI, 1Mbs from observatory

some stars that showed up as Jupiter
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_off-band.fit

Hey, that looks like Jupiter!

Install FocusMax 3.8.0.20, which comes with the focuser software

turn on AutoFocus on ACP restart, now that I have FocusMax installed

Choose Simulator ASCOM Focuser Driver.

Having a little trouble with the simulated focus because the MaxIm
star is too dim and it doesn't respond to exposure time changes.  But
I can lower the minimum flux requirement to 10k.

That worked.

Wed Dec 13 13:29:49 2017 EST  jpmorgen@snipe

Playing with weather simulator, which is a separate app.  Needed a
kick start to get that working, but after second try, did what I
expected.

Back working on

/data/io/IoIO/raw/2017-04-26

This is a great directory because it has some stars that are saturated
and Jupiter!

Saturated star
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0002_10s_SII_off-band.fit
sum >=40000 397222.621745
Only 9.93055 pixels, which is just a star

Others have sum >=40000 0.0 because of setting pixels to 0

'HIP62757'
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0002_1s_open.fit
sum >=40000 6768073.49695
169.201825

No OBJECT, which suggests its Jupiter + it looks like it too!
/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_off-band.fit
sum >=40000 203992874.26
5099.8218565

In my code I have 65000* 250 pixels
16250000 = 16E6.

Actual Jupiter image was 203E6.  Bright star 6.7E6

I think I am pretty good.

Check centers.  Within a pixel!

/data/io/IoIO/raw/2017-04-26/Filter_sequence-0003_10s_Na_on-band.fit
sum >=40000 155408846.013
155.40884601300002E6
Within 4 pixels

OK.  Together with the fact that this runs in 0.5s suggests that I am
ready to roll!

Wed Dec 13 13:53:39 2017 EST  jpmorgen@snipe

OK, back to the ACP simulator stuff.  Before I add user scripts, I
should make sure that a basic plan works

#DOMEOPEN

#Filter   R, [SII] on-band, Na on-band, [SII] off-band, Na off-band
#Binning  1,   		 1,          1,              1,           1
#Count    1,   		 1, 	     1,		     1,		  1
#Interval 0.5,		 0.5,	     0.5,	     0.5,	  0.5

test_meridian	17:00	00:00

#SHUTDOWN

Worked fine

Thu Dec 14 09:11:32 2017 EST  jpmorgen@snipe

At some point, I need to decide when to merge this stuff back to
IoIO.notebk.  For now continue thought here.

Camera not connected so I can't check, but I seem to recall that I did
exposures in 1-hour chunks.  Io's orbital period is 42.45930686
hours.  Sampling it during its ortbial period 10 times seems fine if
orbital period is all that is going on.  But since I am able to
resolve structure close to the moon which might be affected by the
torus, having more frequent sampling would make sense.  The torus ansa
itself changes on 15 minute time scales.  Changes at Io could be even
more frequent

1m Na off-band
5m Na on-band
9
5m [SII] on-band
1m [SII] off-band

For a total of about 60 minutes of observing time per cycle.  I could
have this be chopped up in a different way if I want.

Looking at logic in /data/PSIScope/observing/AcquireImages.js and find
that the AcquireImage user action continues back to the Count loop so all of
the logic below there is skipped, which includes messing with the
guider and it looks like tracking too.  So in my user action script, I
need to take care of all of that.  But to give me flexibility of
messing with exposures at the Scheduler level, I should probably have
my script just handle things one at a time after launching the Python
background job.

Ah, the code above the AcquireImage user action is not all that
extensive, but does include autofocus and reslew.  This means that
Jupiter might spontaneously end up in the wrong place sometimes if I
use the Count loop and the autofocus periodic or adaptive features.

The alternative is just using an hour-long (or however long)
"exposure" in scheduler and handle all of the exposure looping in
there.  Given that I want to, that sounds reasonable.  But think for a
miniute how it might work with the independent Python job.  Given that
it is only looking at the images as they are taken from MaxIm and has
no control over the initiation of the images, I don't see it working
to do guider stop, telescope move, reinitialize.  That has to be
handled by the code asking MaxIm to take an image.  But I would need
to have some code asking for the image anyway.

OK, so it looks like a question of overhead.  I could use the
individual image stream from ACP/Scheduler and do a pre-image every
time, which would be a waste, but would get me in line.  I could live
with up to a 5-minute exposure lost each hour after a focus.  That
might be more time lost to find itself.

Hey, there is a flag that gets set when the autofocus stuff is done.
That is what I was looking for!  It is AG (auto guider) and Orbital
Tracking

--> hmm.  Not sure I want to use his autoguiding stuff

This is how I would turn it on and off
SUP.AutoGuide(true);
SUP.AutoGuide(false);

This is how I test --> not sure which is best
SUP.Guiding
SUP.GuiderRunning

Other indication:
var orbTrackRealRates = (Tc.OrbTrack && (Tc.RARate !== 0 || Tc.DecRate !== 0));

This is how I would set it

if(orbTrackRealRates)
    SUP.SetTrackOffset(Tc.RARate, Tc.DecRate);      // Complier assures scope can do tracking

But not sure if that has the real test.

Anyway, I can get to that when I need to.  It definitly looks like my
first-level user action can use something like these to test to see if
it is the first time it has been entered and go through the necessary
logic loops above (search for Loop:)  Amend that

Hmm.  So where am I going to have my event loop for moving the guide
box?  That has been the hard thing.  I guess to start with I could
just skip that part and do periodic recenters when the distance gets
too large.  But what I really want is that process to be running in
the background to help MaxIm keep the object in the primary mirror
centered.

To do that I would need to learn how to launch a separate process and
pass messages to and from it.  At the most basic level, all those
messages need to be are the _rates_ in RA and DEC that I want to move
the guide box.  The process would then generate a string of the
appropriate MaxIm object commands to move the guide box.  It would
also need to have some way to know when it got to the edge

OK, back to the scheduler aspect.  I might be able to have the
Jupiter plan include a calibration star.  That would be where it gets
the right autofocus HFD.

Work in PSIScope.notebk on getting scheduler up and running for more
objects.

Sun Dec 17 15:22:07 2017 EST  jpmorgen@snipe

Ack!  Scheduler doesn't like the Foster Systems roof controller.
Sigh.

Anyway, I can get by with ACP until I resolve that issue.  Go back to
getting my Python code to run on Windows & with ACP or MaxIm or
however I do this. 

Ah, I remember why I wanted to have it running in the background: it
takes a long time to load all of the modules it needs.

This was a little complicated because I have Daniel's thing, but as
long as I put it in the same directory (as a link), it loaded OK.
First time I launched it, it took a minute.  Second time was more like
10s, but that extended back to 30s or so after another try.

Individual files in a process_dir take about 1s, as expected on a
slower computer.


https://www.pythonstudio.us/introduction-2/implementing-com-objects-in-python.html

Hey, it looks like I can create a python server!

import pythoncom

etc.  Whew!  It looks like I can get what I want in both directions.

If I end up using TakePicture to take the image, I might want to use
the ImageEnd() user action.  Or I can just do everything myself in
AcquireImage, which might be a little cleaner

Sun Dec 17 20:47:07 2017 EST  jpmorgen@snipe

http://solo.dc3.com/ar/RefDocs/HelpFiles/ACP81Help/scr-wsc.htm

This shows how I can create some WSC that lay around and do things I
want.  I think that is what the pytonstudio.us stuff is giving me in Python

Mon Dec 18 19:32:11 2017 EST  jpmorgen@snipe

So at some point, I am going to want to separate the Windows-specific
stuff from the CorObsData stuff.  I am finding thanks to Daniel's work,
that as long as the import is in the same directory as the original
script, it works just fine.  Plus I could probably figure out how to
make it work other ways.

So to start off with, I want to enable the WSC components in ACP.  No,
actually, I think I want to make sure the simulator works OK first.
Oh, I already did that with simulate.txt plan.

OK, set up WSC JS version

Tue Dec 19 09:02:53 2017 EST  jpmorgen@snipe

Did a test object in ioio.py which shows that an object with a wait
loop is not an independent thing.

So I need to create an independent program for both the guide box
mover and the CorObsData component.

Along those lines, I need to start thinking about what to call the
components of the [Python] program that are going to be collecting the
CoObsData and calculating guide box rates.

--> Check to see if FITS headers are persistent, otherwise make a list
    of keys I want to extract and have be permanent

The guide box move code should be simple enough for a js program.
that program has to run continuously and accept events

But I don't know if I want to bother learning how to do that, since I
am going to need to learn how to make one in Python anyway for the

I am sensing that I can make ioio.py have some arguments to main that
launch the various servers/clients that I want.  Otherwise, I just
import it and use the objects for reductions (or reductions will be
other arguments to main)

I have a MaxImData class definition that I will need in my guide box
mover, but the mover itself should not be in the cclass definition: it
instantiates a class member.

I wonder if I could have everything in one event loop, so the guide
box mover doesn't have to be a separate thing + can share property.
That seems to keep things a little more simple.  But I could
potentially split them out within the module if I need to.

OK, so what to call this.  We are making a server for precision
centering and dealing with differential flexure.  The fact that
Jupiter is involved is secondary

So there is basically one entry point: precision_center

Back to the guider loop.  I don't see how I can get around the fact
that I need a background process.  Looking into sched event
scheduler.  Still seems to block or need to be re-called.

Circuits is an event driven module

--> It may be that the server allows the loop to go on independent of
    other calls!  That would mean I would use the COM service to
    connect to my own server!
    
Tue Dec 19 14:47:06 2017 EST  jpmorgen@snipe

Hmm.  Doing some simple tests with HelloCom and HelloClient and find
that the COM object is instantiated on a per-client basis.  In other
words, dispatching the server starts its own instantiation of it.  I
have a feeling that what I am asking it to do is rather complex....

It might be that I can instantiate an object and store it as a global
variable in the place Bob gives me.

Looking into asyncio

Looking into ASCOM driver video https://youtu.be/XVlrDyIBd5I further
and find that the persistent state is maintained via the arduino board
not in the object.

Looking more at
http://timgolden.me.uk/pywin32-docs/html/com/win32com/HTML/QuickStartServerCom.html

_com_interfaces_

https://msdn.microsoft.com/en-us/library/windows/desktop/ms686618(v=vs.85).aspx

Ah Ha!  Persistent Object Interfaces

But there is not much by way of actual examples + it is not clear if
this is implemented in Python.

Fundamentally, if I have a process that I run separately that reads a
file with the rates, that would be sufficient.  The file could have a
control flag built in that would latch off when the MaxImDL guider
turns off.  It would work for me to do this in the ioio.py and have
the instantiation of it be a command line option.

Actually, the more politically correct way might be to have it serve
up COM object that does the interface!  Note that I have to run the
.py file once to register, but it is not clear if that goes across
boots

--> Check that object registration is persistent.  May be related to
    having MaxIm start once before all COM hooks are active and is
    likely so

--> Figure out where this goes possibly /cygdrive/c/Program Files (x86)/ACP Obs Control/Scripts/

OK, now that I think I know the limitations of the COM system, go back
to rethink the whole thing.

I basically want two things that are running all the time, or at least
persistent in memory.  The guide box mover is the one that has to
click continuously.  The rest of the code in ioio.py I just want to
sit there, ready to call.

I could make ioio.py an active X COM object with a set of exposed
methods for doing things that are called by AcquireImage.  If I make
the object a global variable, it is persistent as I want it.  I
probably wouldn't need too many exposed methods: append_obs

It would be Most Elegant if I could have guidebox_mover be an event
loop controlled within that object.

Ah. I see that what I really want is a coroutine, since that can go
along with yields

Maybe what I want is concurrent
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future

That still seems like the executors are separate processes.  The
coroutine has the example of being all one blob.  --> I could
potentially do it that way if I am not picky about how often the
GuideBoxMover gets called.  I just need to know it will be called
often enough

This just seems more trouble than it is worth

Really what I want is inter-process communication (IPC)
https://docs.python.org/3/library/ipc.html

mmap might be a way to keep this in memory

Wed Dec 20 10:20:47 2017 EST  jpmorgen@snipe

Looking into JSON and finding that I might be able to share a StringIO
object?  Maybe not.  I can't share objects across the processes

https://docs.python.org/3/library/json.html

JSON produces str not bytes, so that might not be the best choice for
mmap.

mmap seems really primitive in that it needs the size of the file and
stuff like that.

Probably a good idea to start with the regular old file first

Hey, they give me the child process example I am looking for!  Well,
that is on an OS that I would rather be working on....

So back to a JSON written to a regular file read by the

Thu Dec 21 13:20:20 2017 EST  jpmorgen@snipe

https://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3

and

https://docs.python.org/3/library/asyncio-subprocess.html

http://dabeaz.com/coroutines/Coroutines.pdf

So I think the idea is that I am going to have a generator talk to the
pipe

But https://stackoverflow.com/questions/1196074/how-to-start-a-background-process-in-python

suggests that Popen without a pipe is the right way.  I would then
need to talk to it via a file

Thu Dec 21 17:36:16 2017 EST  jpmorgen@snipe

ioio.calc_main_move is what I want when Iwant to center the object.  I
have something commented out called center_object that does that.
That would be a public method in my AcuireImage user action

--> I still need to write the thing that does the guide box rates.
    But those are looking like they will be a tuple or np.array in y,x order.

So CCDCamera.GuiderMoveStar is what I want to eventually plug into.
It can do fractional pixels, so I can do this as often as I want but
should limit bandwidth.

I like the idea of letting GuideBoxMover decide the rate at which it
will poll

Sun Dec 24 14:07:39 2017 EST  jpmorgen@snipe

At some point I will want to add the complication of flexure.
Ideally that would be done as a separate process that looks at the
scope position, calulates the rate and feeds that to the GuideBoxCommander

Hmm.  On Windows, getting an error that a Python file is not a valid
Win32 applicaiton.

<sigh> because python defaults to python 2.7, I can't use the same
command on windows and Debian

I can consider doing an update alternatives on snipe....

Did that (see snipe.notebk) and things work more smoothly across
platforms

Now think about where I am going to put the centering command.  I have
the MaxImData object, which needs to be persistent for connecting
continuously to MaxIm.  So in that loop code, I need to instantiate it
and keep it around.

That suggests that I need to make a controller object

ObsData, MaxImData.  ObsControl?  PrecisionCenter?  PrecisionGuide?
ObsGuide?

This one object is going to have property that keeps track of the
accumulation of ObsData and has methods to control the initial
centering and guide box mover.

Sun Dec 24 20:13:20 2017 EST  jpmorgen@snipe

OK, I have written PrecisionGuide.center.  How can I test it?

P = PrecisionGuide() # defaults should be good
P.center('//snipe/data/io/IoIO/raw/2017-05-28/Na_IPT-0007_Na_off-band.fit')

After a bit of struggle, seems to have worked!  At least in info message

Now that connects to MaxIm's telescope and I think I got it to work on
the real thing before.

One thing I could potentially do is just record a pre-image in R
before every image and do a move & then return "true" to move on.

Mon Dec 25 17:23:29 2017 EST  jpmorgen@snipe

So if PrecisionGuide.center doesn't have an input, maybe I should have
it take one!

So that means I am going to need to learn how to record images with
MaxIm.  And handle the filters.

Fri Dec 29 14:03:11 2017 EST  jpmorgen@byted

It looks like I don't have Python for the laptop?  No, I do, but
somehow .py files are not associated.

Sat Dec 30 14:05:53 2017 EST  jpmorgen@byted

Got python properly registered on the laptop.  Really slow to bring
MaxIm up and do P.center(), but it does seem to work!

OK, so now I think I might be ready to implement the loops above for
centering and guiding.  As I plan that, I also need to look at the ACP
side of things.

Sat Jan 06 16:40:07 2018 EST  jpmorgen@snipe

Ack.  I am getting messed up by the importlib stuff when I try to do
isinstance because Python is super literal about where the
module/class comes from.

https://stackoverflow.com/questions/4821104/python-dynamic-instantiation-from-string-name-of-a-class-in-dynamically-imported

https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string

So the idea is that getattr uses the formal import.  But the locals
and globals

Sun Jan 07 19:57:48 2018 EST  jpmorgen@snipe

https://docs.python.org/3.6/howto/argparse.html#id1

That is all well and good and I can even do the func coolness, but it
goes back to whether or not the arguments are specified

--> Getting command line to work in Windows
https://stackoverflow.com/questions/29540541/executable-python-script-not-take-sys-argv-in-windows

Tue Jan 09 12:00:43 2018 EST  jpmorgen@byted

Put that as a note in ioio.py.  Will need documentation

Need to work on

Integration with ACP UserActions <not on laptop>
Guide box rate calculation system
GuideBoxMover system

I have GuideBoxMover and GuideBoxCommander.  What is missing is
whatever takes the sequence of ObsDatas and analyses it to produce
GuideBoxCommands.  That could be GuideBoxCommander

Reading from def center_loop above and wondering if I should separate
some tasks or combine them.  start_guider looks like something I am
going to need to do.  Do I have it do a center_loop or should
I assume center_loop is done first?  I could have it do the center
loop and raise any errors itself.

Fri Jan 12 11:55:07 2018 EST  jpmorgen@byted

Thinking more about start guider.  Having it separate means I can do
what I want to position the object where I want it

there is a maxim CCDCamera.GuiderRunning property, but that only tells
if the guider is running already

CCDCamera.GuiderTrack ( Duration )

is what I want to turn it on, where duration is the exxposure time
(need to think about that)

but before I do that I need to set the position of the guide start

CCDCamera.GuiderAutoSelectStar [= Boolean]

Does that to the brightest star in the FOV.  I of course want that
for Jupiter and generally for sideral targets, but when I am going to
be doing non-sideral guiding, I am going to want to override, or
something like that to pick a star off to one side so it can move a bit

GuiderSetStarPosition is needed if this AutoSelect is False

The PrecisionGuide.acquire_image is going to need to take (all?) the
parameter that ACP shoves at it.

Or do I want one that just has regular parameters I can pass from a
script instead of ACP.  Maybe I need two, since I was thinking of
having one do ACP's take_image and one just do it by itself.

I think I can leave it to run-time, since Bob makes available the
Util, etc., objects.  I can pass them in, defaulting to None.  If they
are there, that could be a signal I want them to be used.

Fri Jan 12 16:20:17 2018 MST  jpmorgen@byted

Thiniking GuideBoxController might eventually be a separate process
that receives input from PrecisionGuide.GuideBoxAdjuster, which just
runs once per image, and separate processes of TrackRateAdjuster and
DifferentialFlexAdjuster.  GuideBoxController would have each of these
objects registered in it with file-oriented (or better) communications
which tweak the ultimate rate at which GuideBoxController commands
GuideBoxMover to move the guide box.

Hmm.  GuideBoxAdjuster could be its own object with the property of
the ObsDataList.  I could have one for each filter, but I was thinking
I would figure out how to combine them.  

Maybe it would make more sense to have the GuideBoxAdjuster make the
list of ObsDatas

Mon Jan 15 11:17:16 2018 MST  jpmorgen@byted

Tried to use at telescope!  Got as far as getting an ND_params from a
flat, but was too hard to get it into PrecisionGuide.center

--> Think about how to get ND_params into PrecisionGuide

Mon Jan 15 11:51:32 2018 MST  jpmorgen@byted

For a standard ObsData, PrecisionGuide.center is easy.  What I want is
some way to get parameters in by hand.  So rather than having the
ObsData class be a parameter, I should probably just have made a
subclass.

But really I just need arguments to the ObsData class.

What can **kwargs do for me?  It is a dictionary of keywords

OK, I think I implemented that.  But now how to pass that in from the
command line?  I might want to do a * after something like --ObsDataArgs

--> think about making an emulator of MaxImData for Linux

Hmm.  Not sure if the **kwargs is really going to work with argparse.
I basically need to just know what the arguments are going to be

OK, should now be able to do

ioio.py --ND_param_dir "C:\Users\PLANETARY SCIENCE\Desktop\IoIO\data\2018-01-16"

Mon Jan 15 20:10:30 2018 MST  jpmorgen@byted

Ack!  Passing **kwargs only works once.  Once the keywords have been
stuffed into a dictionary, they are a positional parameter [ah, I need
to pass them again as **kwargs, which puts them back into keyword
args]

--> ! script disconnects camera!

Fri Jan 19 08:08:11 2018 MST  jpmorgen@byted

So it looks like I need to do some work with the WCS keywords in order
to control guider slews properly

--> check to see where guider rate is set in APCC & if guider rates are
    different because of rectangular pixels in guider

--> I can do a sanity check with what it in MaxIm

--> guidebox move is going to need to know about rectangular pixels.
    Maybe guidebox move command should be expressed in arcsec


Indeed, I think having the WCS transformations from main camera pixels
to delta arcsec.  Guider move is going to be in delta arcsec which
needs to be translated into delta pix

--> should print be a function or a procedure?
--> a function

--> return is just a statement but can be a function

--> BASIC

Fri Jan 19 19:12:54 2018 EST  jpmorgen@byted

So I have been struggling with what to do with all of the command line
parameters that would get added by people's different modules.
Fundamentally what needs to happen is that a bunch more
center_parser.add_argument calls need to be made.  So center_parser
could be an object that gets passed around to the modules that add to
it.  So there could be some registration system.  It could be part of
CorObsData, but it really doesn't fit there.  It would need a
component that would add to the center_parser and the general parser
too.  And to the cmd_center

Mon Jan 22 08:20:19 2018 EST  jpmorgen@snipe

--> anti-stiction in DEC

Ack!  I think I have a bad pin point solution in the guider

--> get another guider plate solve

OK, PIERSIDE is what I want and not FLIPSTAT

I will want to have the MaxImData connect to the telescope itself,
since the MaxIm properties don't do all the work I need

FLIPSTAT should be '' or FLIP/MIRROR

In any case, for some reason it is not being used

--> I need to figure out what telescope object is being used

--> get guider rates

Guider rate is a setting on the Rate settings menu in APCC
http://www.ascom-standards.org/Help/Developer/html/P_ASCOM_DriverAccess_Telescope_GuideRateDeclination.htm

<sigh> so just like all ASCOM components, I have to separately specify
the equipment

AstroPhysicsV2.Telescope

Before I forget, tweak the run_level_default_ND_params

ioio.py ND_params '/data/io/IoIO/raw/2018-01-22'
    = [[  3.63686271e-01,   3.68675375e-01],
       [  1.28303305e+03,   1.39479846e+03]]

Now I would like to use that.  Difficult logic in the __init__.  I
think that I might have to use run_level_default_ND_params in the
invocation of 

Mon Jan 22 17:16:46 2018 EST  jpmorgen@snipe

--> Hey, ACP doesn't like to have MaxIm connected to the telescope, so
    maybe I should avoid doing that too, if possible

So how invovled do I want to get with the MaxIm stuff for the
telescope?

Auto Scope Dec would presumably need the scope connected to MaxIm.
But ASCOM direct might sort of do that.

Looking at the behavior of MaxIm, unless I am connected to the
telescope, Auto Scope Dec and Auto Pier flip are grayed out + Pier
Flip is active

Bob has SUP.AutoGuide(true) to turn on his own autoguiding algorithm.
I suppose I could use that.  Ugg.  That means I need to determine if I
am in his stuff or not.  Alternately, I can connect and disconnect
MaxIm to the telescope when I get out of my stuff.

No, I could potentially keep disconnected from the scope in MaxIm and
copy all that in myself.....

So what is the best way to get run_level_default_ND_params?  That
happens in populate_obj, when we would have otherwise thown an error.

Tue Jan 23 11:22:08 2018 EST  jpmorgen@snipe

So I think the astrometry files should be done in a similar way.  Got
those in with host specific paths

I think I want to have a separate astrometry routine that gives me
what I want.

--> AlignmentModes will be in that tweak
CanPulseGuide?
SideOfPier

<Sigh> I am not sure if pierEast pierWest is going to give me what I
need.  But looking at the PinPoint solutions, I see the CDELT* are
_both_ of opposite sign on pier flip.  Ah.  The trick is that the RA
axis goes in the opposite direction!

 a = np.array([[1, 2], [3, 4]])
 a[:,::-1]
array([[2, 1],
       [4, 3]])

Hey, I can use Ellipsis, or ... to skip to the last index, which helps
ensure program works if just one tuple is given

 a = np.array([[1, 2], [3, 4]])
 a[...,::-1]

Wed Jan 24 07:57:05 2018 EST  jpmorgen@snipe

OK, so I may want to rename guider_move in MaxImData

Looking at ASCOM standard to see if there is a matching name, no, I
did it with guider_move, since that matched MaxIm!

http://www.ascom-standards.org/Help/Developer/html/P_ASCOM_DriverAccess_Telescope_GuideRateDeclination.htm

PIERSIDE =EAST/WESTin hdr
SideOfPier =pierEast pierWest in ASCOM

So guider_move takes a ddec_dra pair

--> remember to set DEC in MaxIm guiding property

OK, I have center working with pixels.  But what if I can get it in
world coordinates?  That would require a special ObsData that used
PinPoint.

Hey, I could probably squeeze that in by reading the HDUList[0].header
in the ObsData.

I can standardize on having the ObsData provide pixels for obj_center
and desired_center and do the transformations on the fly as needed.

Hmm  What if I want to pass an astrometry to center?  It can be
authoritative or approximate

Ack.  I was zealous in saving memory and deleted HDUList_im_or_fname
from ObsData.  I still want the header around, if possible.

I guess that means I want to have self.header around

OK, took care of that, hopefully without inducing bugs

Now I need to think about flow.  I have scope_wcs, which returns an
HDUList (should just be a header) that

test del withhout copy in ObsData

https://stackoverflow.com/questions/22069727/python-garbage-collector-behavior-on-compound-objects

suggests I don't need to do the copy, since individual objects have
individual reference counts even if they are within a compound object

--> consider using a sequence of plate solves to get the filter
    offsets

scope_fname_HDUList_or_header

Fri Jan 26 06:55:15 2018 EST  jpmorgen@snipe

Working on ioio.py

--> enumeration of Telescope. AlignmentMode Property

--> not getting astrometry of guider right

reversing RA helped, but rates are way too high

push north button, Jupiter moves down
on east of pier, push west, Jupiter moves right

upper left resulted in dra_ddec

[ 0.15581682  0.08760853]

lower right

[-0.1570902  -0.07768477]

and that after the RA axis flip (still on ease side of pier)

KIt is almost like we are off by a factor of 2

Jupiter (star) in upper left moving -20, +34

Hmm.  Factor of 2 on guider rate did it!  Oops, that was to absolute
center of image

Oops, was using standard center!  Wow!  That worked!

ioio.py center --ObsClassName CorObsData

Works too!

Pier flip.  Jupiter is near meridian, but I should be able to track
past the meridian for a bit + I can go to Vega if worse comes to worse

Hmm.  Now it is totally not working try center again.

Moved it farther away.  But sky is super bright

Whew.  What a pain.  Lets see if we can break it down into some constituents

Fri Jan 26 11:51:56 2018 EST  jpmorgen@snipe

Ah HA!  I think I found the factor of 2!  It is the binning!

Fri Jan 26 13:24:57 2018 EST  jpmorgen@snipe

Working on understanding rates

Scope actual rates
0.004178075
0.004178075
Rates calculated from guider
0.00536077057072
0.00401567330861

Actually not too bad!

Fri Jan 26 15:28:20 2018 EST  jpmorgen@snipe

Whew!  Finally got the thing to work on the east side of the pier

Sat Jan 27 05:21:04 2018 EST  jpmorgen@snipe

Works on west side of pier!

I still have the residual E/W flip I am not sure is correct.  Delta RA
is relative to what positive RA is, which is negative X in the sense
that east is left when you look at the sky and east is positive RA.
Noted that in the code.

Now that centering is working, the next step is to work on guiding,
since I think I am going to need to turn that on and off myself

CCDCamera.GuiderCalState == 2 may be a nice thing to assert to make
sure the guider is calibrated, though I am not sure if that is on a
per launch basis

